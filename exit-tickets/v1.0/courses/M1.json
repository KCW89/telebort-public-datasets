{
  "courseId": "m1-mobile-i-love",
  "courseName": "M1-Mobile Apps I Love",
  "courseCode": "M1",
  "domain": "mobile_development",
  "tier": "intermediate",
  "difficulty": 3,
  "totalLessons": 18,
  "totalQuestions": 90,
  "sourceFile": "M1-Mobile-MCQ-12-Concepts.md",
  "lessons": [
    {
      "lessonId": "m1-mobile-i-love-lesson-1",
      "lessonNumber": 1,
      "lessonTitle": "Introduction to Mobile Development",
      "lessonSlug": "introduction-to-mobile-development",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l1-q1",
          "globalId": "exit-ticket-0586",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat is React Native and why is it considered a cross-platform framework?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "A framework for building mobile apps using JavaScript and React that allows deployment to both iOS and Android from a single codebase",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! A framework for building mobile apps using JavaScript and React that allows deployment to both iOS a... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "B",
              "text": "A native iOS development language that only works on Apple devices",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. A native iOS development language that only works on Apple devices... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "A backend database system for mobile applications",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. A backend database system for mobile applications... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "An Android-only framework that uses Java exclusively",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. An Android-only framework that uses Java exclusively... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "A framework for building mobile apps using JavaScript and React that allows deployment to both iOS and Android from a single codebase",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "react-native"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_PLATFORM_SPECIFIC"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l1-q2",
          "globalId": "exit-ticket-0587",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nAnalyze this basic React Native app structure. What does this component do?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "import React from 'react';\nimport { View, Text, StyleSheet } from 'react-native';\nconst MyFirstApp = () => {\nreturn (\n<View style={styles.container}>\n<Text style={styles.title}>Welcome to Mobile Development!</Text>\n<Text style={styles.subtitle}>Building apps with React Native</Text>\n</View>\n);\n};\nconst styles = StyleSheet.create({\ncontainer: { flex: 1, justifyContent: 'center', alignItems: 'center' },\ntitle: { fontSize: 24, fontWeight: 'bold', color: 'blue' },\nsubtitle: { fontSize: 16, marginTop: 10, color: 'gray' }\n});",
          "options": [
            {
              "key": "A",
              "text": "Creates a login screen with input validation",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Creates a login screen with input validation... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Creates a welcome screen with two text elements centered on screen using flexbox layout",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Creates a welcome screen with two text elements centered on screen using flexbox layout... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Creates a navigation drawer with menu options",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Creates a navigation drawer with menu options... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Creates a data list with scrollable content",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Creates a data list with scrollable content... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Creates a welcome screen with two text elements centered on screen using flexbox layout",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "react-native",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_STYLESHEET_INLINE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l1-q3",
          "globalId": "exit-ticket-0588",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nYou want to add a button that shows an alert when pressed to the above code. What components and event handlers would you need?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Button component, onClick handler, and window.alert() method",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Button component, onClick handler, and window.alert() method... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "TouchableOpacity component, onPress event handler, and Alert.alert() method",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! TouchableOpacity component, onPress event handler, and Alert.alert() method... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "ClickButton component, onTouch handler, and console.log() method",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. ClickButton component, onTouch handler, and console.log() method... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "ActionSheet component, onSelect handler, and Toast.show() method",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. ActionSheet component, onSelect handler, and Toast.show() method... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "TouchableOpacity component, onPress event handler, and Alert.alert() method",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_EVENT_HANDLING",
            "M1_TOUCHABLE_COMPONENTS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l1-q4",
          "globalId": "exit-ticket-0589",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat makes a mobile app idea suitable for a beginner project learning mobile development fundamentals?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Complex animations, social media integration, and real-time chat features",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Complex animations, social media integration, and real-time chat features... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Realistic scope with 2-3 screens, clear core functionality, and basic user interactions",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Realistic scope with 2-3 screens, clear core functionality, and basic user interactions... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Advanced machine learning, augmented reality, and blockchain integration",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Advanced machine learning, augmented reality, and blockchain integration... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Multi-language support, offline synchronization, and payment processing",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Multi-language support, offline synchronization, and payment processing... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Realistic scope with 2-3 screens, clear core functionality, and basic user interactions",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l1-q5",
          "globalId": "exit-ticket-0590",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhat aspects of mobile development should beginners be most excited to learn about?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Advanced server architecture and database optimization techniques",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Advanced server architecture and database optimization techniques... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "UI design, user interaction patterns, and real device testing experiences",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! UI design, user interaction patterns, and real device testing experiences... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Complex algorithms and data structure implementations",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Complex algorithms and data structure implementations... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Low-level hardware programming and system kernel modifications",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Low-level hardware programming and system kernel modifications... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "UI design, user interaction patterns, and real device testing experiences",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-2",
      "lessonNumber": 2,
      "lessonTitle": "Components and Basic Styling",
      "lessonSlug": "components-and-basic-styling",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l2-q1",
          "globalId": "exit-ticket-0591",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhy are functional components preferred over class components in modern React Native development?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "They use more memory and provide better performance",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. They use more memory and provide better performance... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "They have simpler syntax, better performance, hooks support, and easier testing",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! They have simpler syntax, better performance, hooks support, and easier testing... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "They can only be used with TypeScript applications",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. They can only be used with TypeScript applications... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "They automatically handle all state management without any setup",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. They automatically handle all state management without any setup... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "They have simpler syntax, better performance, hooks support, and easier testing",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "react-native"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l2-q2",
          "globalId": "exit-ticket-0592",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this ProfileCard component demonstrate good styling practices?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const ProfileCard = ({ name, role, onEdit }) => {\nreturn (\n<View style={styles.card}>\n<View style={styles.header}>\n<Text style={styles.name}>{name}</Text>\n<Text style={styles.role}>{role}</Text>\n</View>\n<TouchableOpacity style={styles.editButton} onPress={onEdit}>\n<Text style={styles.buttonText}>Edit Profile</Text>\n</TouchableOpacity>\n</View>\n);\n};\nconst styles = StyleSheet.create({\ncard: {\nbackgroundColor: 'white',\npadding: 20,\nborderRadius: 10,\nshadowColor: '#000',\nshadowOffset: { width: 0, height: 2 },\nshadowOpacity: 0.1,\nelevation: 3,\n},\n// ... other styles\n});",
          "options": [
            {
              "key": "A",
              "text": "Uses inline styles for better performance and readability",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Uses inline styles for better performance and readability... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Shows component composition, props usage, consistent styling patterns, and proper spacing",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Shows component composition, props usage, consistent styling patterns, and proper spacing... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Implements complex animations and gesture handling",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Implements complex animations and gesture handling... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Uses only native platform-specific styling approaches",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Uses only native platform-specific styling approaches... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Shows component composition, props usage, consistent styling patterns, and proper spacing",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_STYLESHEET_INLINE",
            "M1_EVENT_HANDLING",
            "M1_TOUCHABLE_COMPONENTS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l2-q3",
          "globalId": "exit-ticket-0593",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you modify the ProfileCard component to include a user's profile picture with proper fallback handling?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Add Image component, source prop handling, placeholder for missing images, and proper styling",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Add Image component, source prop handling, placeholder for missing images, and proper styling... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "B",
              "text": "Use only text-based avatars with initials to avoid image complexity",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only text-based avatars with initials to avoid image complexity... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "Implement a complex image caching system with compression",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Implement a complex image caching system with compression... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Load images directly from the device's camera roll",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Load images directly from the device's camera roll... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Add Image component, source prop handling, placeholder for missing images, and proper styling",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l2-q4",
          "globalId": "exit-ticket-0594",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat props would a reusable Button component need to be used throughout an app with different colors, sizes, and text?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Only title prop and onPress handler for simplicity",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only title prop and onPress handler for simplicity... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "title/text prop, onPress handler, style variants, disabled state, and accessibility props",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! title/text prop, onPress handler, style variants, disabled state, and accessibility props... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Complex animation configurations and gesture recognizers",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Complex animation configurations and gesture recognizers... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Database connection properties and API endpoints",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Database connection properties and API endpoints... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "title/text prop, onPress handler, style variants, disabled state, and accessibility props",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_STATE_VS_PROPS",
            "M1_TOUCHABLE_COMPONENTS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l2-q5",
          "globalId": "exit-ticket-0595",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow does working with React Native components change understanding of mobile UI design compared to web development?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Mobile and web development are exactly the same with no differences",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile and web development are exactly the same with no differences... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Mobile focuses on touch-first interactions, platform-specific styling, and performance considerations",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Mobile focuses on touch-first interactions, platform-specific styling, and performance consideration... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Mobile development only uses native platform languages",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile development only uses native platform languages... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Web development concepts don't apply to mobile at all",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Web development concepts don't apply to mobile at all... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Mobile focuses on touch-first interactions, platform-specific styling, and performance considerations",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "react-native"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-3",
      "lessonNumber": 3,
      "lessonTitle": "State Management Basics",
      "lessonSlug": "state-management-basics",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l3-q1",
          "globalId": "exit-ticket-0596",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat's the difference between local state and global state, and when should you use each?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Local state is for component-specific data, global state is for app-wide data shared across components",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Local state is for component-specific data, global state is for app-wide data shared across componen... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "B",
              "text": "Local state is faster, global state is slower, so always use local state",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Local state is faster, global state is slower, so always use local state... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "Global state is for iOS apps, local state is for Android apps",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Global state is for iOS apps, local state is for Android apps... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "There's no difference between local and global state in React Native",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. There's no difference between local and global state in React Native... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Local state is for component-specific data, global state is for app-wide data shared across components",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "state-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_STATE_VS_PROPS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l3-q2",
          "globalId": "exit-ticket-0597",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this component manage multiple pieces of state effectively?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const CounterWithHistory = () => {\nconst [count, setCount] = useState(0);\nconst [history, setHistory] = useState([]);\nconst [name, setName] = useState('');\nuseEffect(() => {\nsetHistory(prev => [...prev, count]);\n}, [count]);\nconst increment = () => setCount(prev => prev + 1);\n// ... rest of component\n};",
          "options": [
            {
              "key": "A",
              "text": "Uses only one useState hook for all data to simplify management",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Uses only one useState hook for all data to simplify management... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Uses multiple useState hooks, useEffect for side effects, and proper state update functions",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Uses multiple useState hooks, useEffect for side effects, and proper state update functions... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Stores all state in local storage for persistence",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Stores all state in local storage for persistence... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Relies on global variables instead of React state",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Relies on global variables instead of React state... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Uses multiple useState hooks, useEffect for side effects, and proper state update functions",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx",
              "state-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_COMPONENT_LIFECYCLE",
            "M1_USEEFFECT_DEPS",
            "M1_STATE_VS_PROPS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l3-q3",
          "globalId": "exit-ticket-0598",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you implement persistence so the counter value survives app restarts?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Use only in-memory storage for faster access",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only in-memory storage for faster access... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Use AsyncStorage for persistence, useEffect for loading saved data, and error handling",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Use AsyncStorage for persistence, useEffect for loading saved data, and error handling... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Store data in the component props for automatic persistence",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Store data in the component props for automatic persistence... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Use only server-side storage for all app data",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only server-side storage for all app data... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Use AsyncStorage for persistence, useEffect for loading saved data, and error handling",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l3-q4",
          "globalId": "exit-ticket-0599",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat state would you need for a simple todo app with adding, completing, and filtering features?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Only a single string for the current input value",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only a single string for the current input value... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "todos array with properties, filter state, input text state, and loading states",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! todos array with properties, filter state, input text state, and loading states... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Complex database schemas with user authentication",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Complex database schemas with user authentication... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Just the total count of completed tasks",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Just the total count of completed tasks... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "todos array with properties, filter state, input text state, and loading states",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "state-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_STATE_VS_PROPS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l3-q5",
          "globalId": "exit-ticket-0600",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhat strategies help debug state-related issues and follow state management best practices?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Always use global state for everything to avoid debugging issues",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Always use global state for everything to avoid debugging issues... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Console logging state values, avoiding direct mutations, using functional updates, and keeping state minimal",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Console logging state values, avoiding direct mutations, using functional updates, and keeping state... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Never use React DevTools as they slow down development",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Never use React DevTools as they slow down development... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Store all state in external files for easier debugging",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Store all state in external files for easier debugging... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Console logging state values, avoiding direct mutations, using functional updates, and keeping state minimal",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "state-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_STATE_VS_PROPS"
          ]
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-4",
      "lessonNumber": 4,
      "lessonTitle": "Working with Images",
      "lessonSlug": "working-with-images",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l4-q1",
          "globalId": "exit-ticket-0601",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat are the advantages and challenges of local images vs remote images in React Native?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Local images are always better than remote images in every situation",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Local images are always better than remote images in every situation... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Local images: faster loading and offline availability but larger bundle size; Remote images: smaller bundle but require network and loading states",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Local images: faster loading and offline availability but larger bundle size; Remote images: smaller... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Remote images are always faster and should be used exclusively",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Remote images are always faster and should be used exclusively... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "There's no difference between local and remote images in React Native",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. There's no difference between local and remote images in React Native... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Local images: faster loading and offline availability but larger bundle size; Remote images: smaller bundle but require network and loading states",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "react-native"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_IMAGE_SOURCE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l4-q2",
          "globalId": "exit-ticket-0602",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this SmartImage component handle different image loading states?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const SmartImage = ({ source, fallback, style, onPress }) => {\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(false);\nconst handleLoadStart = () => {\nsetLoading(true);\nsetError(false);\n};\nconst handleError = () => {\nsetLoading(false);\nsetError(true);\n};\nconst imageSource = error && fallback ? { uri: fallback } : source;\n// ... rest of component with loading indicators and error handling\n};",
          "options": [
            {
              "key": "A",
              "text": "Only shows images when they're fully loaded without any feedback",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only shows images when they're fully loaded without any feedback... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Manages loading, error, and success states with fallback functionality and user feedback",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Manages loading, error, and success states with fallback functionality and user feedback... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Automatically compresses all images before displaying them",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Automatically compresses all images before displaying them... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Uses only local images to avoid loading state complexity",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Uses only local images to avoid loading state complexity... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Manages loading, error, and success states with fallback functionality and user feedback",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx",
              "state-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_EVENT_HANDLING",
            "M1_STATE_VS_PROPS",
            "M1_IMAGE_SOURCE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l4-q3",
          "globalId": "exit-ticket-0603",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you optimize image performance for large user profile pictures in your app?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Load all images at full resolution for the best quality",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Load all images at full resolution for the best quality... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Use image resizing/compression, lazy loading, caching strategies, and progressive loading",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Use image resizing/compression, lazy loading, caching strategies, and progressive loading... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Convert all images to text-based representations",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Convert all images to text-based representations... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only allow very small images to avoid performance issues",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only allow very small images to avoid performance issues... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Use image resizing/compression, lazy loading, caching strategies, and progressive loading",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_IMAGE_SOURCE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l4-q4",
          "globalId": "exit-ticket-0604",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat features should an image gallery component include for a social media app displaying multiple photos efficiently?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Display all images at once in a simple scroll view",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Display all images at once in a simple scroll view... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "FlatList for performance, lazy loading, image caching, zoom gestures, and fullscreen modal view",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! FlatList for performance, lazy loading, image caching, zoom gestures, and fullscreen modal view... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only show one image at a time with pagination buttons",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only show one image at a time with pagination buttons... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Use only thumbnail previews without full-size viewing options",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only thumbnail previews without full-size viewing options... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "FlatList for performance, lazy loading, image caching, zoom gestures, and fullscreen modal view",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_IMAGE_SOURCE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l4-q5",
          "globalId": "exit-ticket-0605",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow do image challenges in mobile apps differ from web development?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Mobile and web image handling are exactly the same",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile and web image handling are exactly the same... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Mobile has specific performance constraints, device storage limitations, and resolution/density considerations",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Mobile has specific performance constraints, device storage limitations, and resolution/density cons... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Web development doesn't use images, only mobile apps do",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Web development doesn't use images, only mobile apps do... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Mobile images are always easier to work with than web images",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile images are always easier to work with than web images... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Mobile has specific performance constraints, device storage limitations, and resolution/density considerations",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_IMAGE_SOURCE"
          ]
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-5",
      "lessonNumber": 5,
      "lessonTitle": "Navigation Fundamentals",
      "lessonSlug": "navigation-fundamentals",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l5-q1",
          "globalId": "exit-ticket-0606",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhen would you use stack navigation vs tab navigation, and how can they be combined?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Stack navigation is only for iOS, tab navigation is only for Android",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Stack navigation is only for iOS, tab navigation is only for Android... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Stack navigation for hierarchical screens with back functionality; tab navigation for parallel top-level screens; combined with tabs containing stacks",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Stack navigation for hierarchical screens with back functionality; tab navigation for parallel top-l... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "They cannot be used together in the same app",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. They cannot be used together in the same app... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Tab navigation is deprecated and should not be used",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Tab navigation is deprecated and should not be used... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Stack navigation for hierarchical screens with back functionality; tab navigation for parallel top-level screens; combined with tabs containing stacks",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_NAVIGATION_STACK"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l5-q2",
          "globalId": "exit-ticket-0607",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this nested navigation structure serve different user needs?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const HomeStack = () => (\n<Stack.Navigator>\n<Stack.Screen name=\"Home\" component={HomeScreen} />\n<Stack.Screen name=\"Details\" component={DetailsScreen} />\n</Stack.Navigator>\n);\nconst TabNavigator = () => (\n<Tab.Navigator>\n<Tab.Screen name=\"HomeTab\" component={HomeStack} />\n<Tab.Screen name=\"ProfileTab\" component={ProfileStack} />\n</Tab.Navigator>\n);",
          "options": [
            {
              "key": "A",
              "text": "Creates confusing navigation that users won't understand",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Creates confusing navigation that users won't understand... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Creates nested navigation enabling quick section switching while maintaining hierarchical flows within each section",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Creates nested navigation enabling quick section switching while maintaining hierarchical flows with... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only works for simple apps with two screens maximum",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only works for simple apps with two screens maximum... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Requires separate apps for iOS and Android platforms",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Requires separate apps for iOS and Android platforms... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Creates nested navigation enabling quick section switching while maintaining hierarchical flows within each section",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_NAVIGATION_STACK"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l5-q3",
          "globalId": "exit-ticket-0608",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you implement deep linking to specific screens (e.g., direct link to a product page)?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Deep linking is not possible in React Native applications",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Deep linking is not possible in React Native applications... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Use URL scheme configuration, linking configuration object, and parameter extraction",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Use URL scheme configuration, linking configuration object, and parameter extraction... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only allow deep links to the main screen for security",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only allow deep links to the main screen for security... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Require users to manually navigate to screens instead",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Require users to manually navigate to screens instead... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Use URL scheme configuration, linking configuration object, and parameter extraction",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l5-q4",
          "globalId": "exit-ticket-0609",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nHow would you design navigation for an e-commerce app with browsing, search, cart, and user account features?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Use only one screen with everything displayed at once",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only one screen with everything displayed at once... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Conditional navigation based on auth state, persistent cart access, and proper back navigation handling",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Conditional navigation based on auth state, persistent cart access, and proper back navigation handl... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Create separate apps for each feature area",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Create separate apps for each feature area... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Use only web views for all e-commerce functionality",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only web views for all e-commerce functionality... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Conditional navigation based on auth state, persistent cart access, and proper back navigation handling",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_NAVIGATION_STACK"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l5-q5",
          "globalId": "exit-ticket-0610",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow do mobile navigation patterns differ from web navigation?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Mobile and web navigation are exactly the same",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile and web navigation are exactly the same... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Mobile uses gesture-based navigation, tab bar conventions, and platform-specific patterns",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Mobile uses gesture-based navigation, tab bar conventions, and platform-specific patterns... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Mobile apps don't need navigation systems",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile apps don't need navigation systems... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Web navigation is always superior to mobile navigation",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Web navigation is always superior to mobile navigation... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Mobile uses gesture-based navigation, tab bar conventions, and platform-specific patterns",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_NAVIGATION_STACK"
          ]
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-6",
      "lessonNumber": 6,
      "lessonTitle": "Local Data Storage and Offline-First",
      "lessonSlug": "local-data-storage-and-offline-first",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l6-q1",
          "globalId": "exit-ticket-0611",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhy is offline-first architecture important for mobile apps, and what are the main implementation challenges?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Offline-first is only needed for apps without internet access",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Offline-first is only needed for apps without internet access... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Important for reliable user experience and handling poor connectivity; challenges include data synchronization and conflict resolution",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Important for reliable user experience and handling poor connectivity; challenges include data synch... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Offline-first makes apps slower and should be avoided",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Offline-first makes apps slower and should be avoided... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only enterprise apps need offline-first architecture",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only enterprise apps need offline-first architecture... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Important for reliable user experience and handling poor connectivity; challenges include data synchronization and conflict resolution",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l6-q2",
          "globalId": "exit-ticket-0612",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this useOfflineStorage hook implement offline-first principles?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const useOfflineStorage = (key) => {\nconst [data, setData] = useState(null);\nconst [isOnline, setIsOnline] = useState(true);\nconst [pendingSync, setPendingSync] = useState([]);\nuseEffect(() => {\nloadLocalData();\nconst unsubscribe = NetInfo.addEventListener(state => {\nsetIsOnline(state.isConnected);\nif (state.isConnected) {\nsyncPendingData();\n}\n});\nreturn unsubscribe;\n}, []);\n// ... rest of hook\n};",
          "options": [
            {
              "key": "A",
              "text": "Only works when the device is online",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only works when the device is online... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Loads data from local storage first, monitors connectivity, and automatically syncs when connection returns",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Loads data from local storage first, monitors connectivity, and automatically syncs when connection ... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Stores all data on remote servers exclusively",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Stores all data on remote servers exclusively... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Requires manual synchronization by the user",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Requires manual synchronization by the user... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Loads data from local storage first, monitors connectivity, and automatically syncs when connection returns",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_COMPONENT_LIFECYCLE",
            "M1_USEEFFECT_DEPS",
            "M1_STATE_VS_PROPS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l6-q3",
          "globalId": "exit-ticket-0613",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you design conflict resolution for an offline-first note-taking app where users edit the same note on multiple devices?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Always use the first version saved and ignore later changes",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Always use the first version saved and ignore later changes... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Consider timestamp-based resolution, user-prompted conflict resolution, and version tracking",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Consider timestamp-based resolution, user-prompted conflict resolution, and version tracking... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Prevent users from editing the same note on different devices",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Prevent users from editing the same note on different devices... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only allow one device to access the app at a time",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only allow one device to access the app at a time... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Consider timestamp-based resolution, user-prompted conflict resolution, and version tracking",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l6-q4",
          "globalId": "exit-ticket-0614",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nHow would you implement offline functionality for a social media app handling posts, likes, and comments?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Require constant internet connection for all features",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Require constant internet connection for all features... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Local database design, optimistic updates, cached feeds, and queue management for actions",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Local database design, optimistic updates, cached feeds, and queue management for actions... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only allow viewing content offline, no interactions",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only allow viewing content offline, no interactions... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Create a separate offline-only version of the app",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Create a separate offline-only version of the app... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Local database design, optimistic updates, cached feeds, and queue management for actions",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l6-q5",
          "globalId": "exit-ticket-0615",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow has implementing offline functionality changed your approach to mobile app architecture?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Offline functionality is too complex and should be avoided",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Offline functionality is too complex and should be avoided... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Understanding complexity of offline sync, importance of user experience during offline states, and data consistency challenges",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Understanding complexity of offline sync, importance of user experience during offline states, and d... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "All apps should be online-only to avoid complexity",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. All apps should be online-only to avoid complexity... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Offline functionality is only for debugging purposes",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Offline functionality is only for debugging purposes... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Understanding complexity of offline sync, importance of user experience during offline states, and data consistency challenges",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-7",
      "lessonNumber": 7,
      "lessonTitle": "API Integration Basics",
      "lessonSlug": "api-integration-basics",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l7-q1",
          "globalId": "exit-ticket-0616",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat are the differences between GET, POST, PUT, and DELETE HTTP methods and when should each be used?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "All HTTP methods do the same thing and can be used interchangeably",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. All HTTP methods do the same thing and can be used interchangeably... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "GET: retrieve data, POST: create new data, PUT: update existing data, DELETE: remove data",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! GET: retrieve data, POST: create new data, PUT: update existing data, DELETE: remove data... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only GET and POST methods are available in React Native",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only GET and POST methods are available in React Native... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "HTTP methods are only used in web development, not mobile",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. HTTP methods are only used in web development, not mobile... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "GET: retrieve data, POST: create new data, PUT: update existing data, DELETE: remove data",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l7-q2",
          "globalId": "exit-ticket-0617",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this API integration implementation handle different API states effectively?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const useAPI = (url) => {\nconst [data, setData] = useState(null);\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(null);\nconst fetchData = async () => {\ntry {\nsetLoading(true);\nsetError(null);\nconst response = await fetch(url);\nif (!response.ok) {\nthrow new Error(`HTTP error! status: ${response.status}`);\n}\nconst result = await response.json();\nsetData(result);\n} catch (err) {\nsetError(err.message);\n} finally {\nsetLoading(false);\n}\n};\n// ... rest of hook\n};",
          "options": [
            {
              "key": "A",
              "text": "Only handles successful API responses",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only handles successful API responses... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Manages loading, error, and success states with proper error handling and retry functionality",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Manages loading, error, and success states with proper error handling and retry functionality... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Uses synchronous requests for simpler code",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Uses synchronous requests for simpler code... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Stores all API responses in global variables",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Stores all API responses in global variables... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Manages loading, error, and success states with proper error handling and retry functionality",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx",
              "api-integration",
              "state-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_ASYNC_AWAIT_CONFUSION",
            "M1_STATE_VS_PROPS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l7-q3",
          "globalId": "exit-ticket-0618",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you implement retry logic with exponential backoff for failed network requests?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Immediately retry failed requests without any delay",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Immediately retry failed requests without any delay... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Implement retry attempt counting, exponential delay calculation, and maximum retry limits",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Implement retry attempt counting, exponential delay calculation, and maximum retry limits... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Never retry failed requests to avoid wasting resources",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Never retry failed requests to avoid wasting resources... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only retry requests that fail due to user error",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only retry requests that fail due to user error... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Implement retry attempt counting, exponential delay calculation, and maximum retry limits",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_EXPO_VS_REACT_NATIVE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l7-q4",
          "globalId": "exit-ticket-0619",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat should an API integration strategy include for a weather app handling rate limits and caching?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Make unlimited requests without considering rate limits",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Make unlimited requests without considering rate limits... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "API key management, request throttling, response caching with expiration, and graceful degradation",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! API key management, request throttling, response caching with expiration, and graceful degradation... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only use free APIs without any rate limiting",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only use free APIs without any rate limiting... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Cache all data permanently without expiration",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Cache all data permanently without expiration... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "API key management, request throttling, response caching with expiration, and graceful degradation",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "api-integration"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l7-q5",
          "globalId": "exit-ticket-0620",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow do mobile considerations differ from web API integration when handling asynchronous operations?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Mobile and web API integration are exactly the same",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile and web API integration are exactly the same... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Mobile has network limitations, battery usage optimization, and background processing restrictions",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Mobile has network limitations, battery usage optimization, and background processing restrictions... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Web applications don't use APIs, only mobile apps do",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Web applications don't use APIs, only mobile apps do... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Mobile apps should never make network requests",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile apps should never make network requests... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Mobile has network limitations, battery usage optimization, and background processing restrictions",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "api-integration"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_ASYNC_AWAIT_CONFUSION"
          ]
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-8",
      "lessonNumber": 8,
      "lessonTitle": "User Interfaces and Data Display",
      "lessonSlug": "user-interfaces-and-data-display",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l8-q1",
          "globalId": "exit-ticket-0621",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat's the difference between controlled and uncontrolled components in form handling, and what are the advantages of each?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Controlled and uncontrolled components are the same thing",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Controlled and uncontrolled components are the same thing... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Controlled components: React state manages form data (predictable, easier validation); Uncontrolled: component manages state (simpler for basic forms)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Controlled components: React state manages form data (predictable, easier validation); Uncontrolled:... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Uncontrolled components are always better than controlled components",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Uncontrolled components are always better than controlled components... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only controlled components can be used in React Native",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only controlled components can be used in React Native... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Controlled components: React state manages form data (predictable, easier validation); Uncontrolled: component manages state (simpler for basic forms)",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l8-q2",
          "globalId": "exit-ticket-0622",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this TaskManager component demonstrate effective UI and data display patterns?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const TaskManager = () => {\nconst [tasks, setTasks] = useState([]);\nconst [newTask, setNewTask] = useState('');\nconst [filter, setFilter] = useState('all');\nconst addTask = () => {\nif (newTask.trim()) {\nsetTasks(prev => [...prev, {\nid: Date.now(),\ntext: newTask.trim(),\ncompleted: false,\ncreatedAt: new Date().toISOString()\n}]);\nsetNewTask('');\n}\n};\nconst filteredTasks = tasks.filter(task => {\nif (filter === 'active') return !task.completed;\nif (filter === 'completed') return task.completed;\nreturn true;\n});\n// ... rest of component\n};",
          "options": [
            {
              "key": "A",
              "text": "Only displays static data without user interaction",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only displays static data without user interaction... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Combines form input with data display, implements filtering functionality, and uses controlled components",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Combines form input with data display, implements filtering functionality, and uses controlled compo... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Uses only global state for all data management",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Uses only global state for all data management... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Requires server-side rendering for all functionality",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Requires server-side rendering for all functionality... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Combines form input with data display, implements filtering functionality, and uses controlled components",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_STATE_VS_PROPS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l8-q3",
          "globalId": "exit-ticket-0623",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you enhance the TaskManager with form validation and improved user experience?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Remove all validation to keep the interface simple",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Remove all validation to keep the interface simple... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Input validation with error display, duplicate detection, loading states, and confirmation dialogs",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Input validation with error display, duplicate detection, loading states, and confirmation dialogs... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only allow pre-defined tasks from a dropdown menu",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only allow pre-defined tasks from a dropdown menu... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Store all validation logic on the server side",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Store all validation logic on the server side... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Input validation with error display, duplicate detection, loading states, and confirmation dialogs",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l8-q4",
          "globalId": "exit-ticket-0624",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat UI patterns would you use for a user profile form with text inputs, image picker, dropdown selections, and real-time validation?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Display all form fields at once without any organization",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Display all form fields at once without any organization... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Progressive disclosure for complex forms, inline validation with visual feedback, and proper keyboard types",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Progressive disclosure for complex forms, inline validation with visual feedback, and proper keyboar... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Use only text inputs for all data types to maintain consistency",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only text inputs for all data types to maintain consistency... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Require users to complete forms in a separate web browser",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Require users to complete forms in a separate web browser... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Progressive disclosure for complex forms, inline validation with visual feedback, and proper keyboard types",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_IMAGE_SOURCE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l8-q5",
          "globalId": "exit-ticket-0625",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow has working with React Native forms and lists changed your understanding of mobile UI design principles?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Mobile UI design is exactly the same as web design",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile UI design is exactly the same as web design... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Understanding touch-first interaction design, keyboard management importance, and platform-specific UI patterns",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Understanding touch-first interaction design, keyboard management importance, and platform-specific ... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Mobile apps don't need forms or lists",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Mobile apps don't need forms or lists... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Desktop design principles work perfectly for mobile apps",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Desktop design principles work perfectly for mobile apps... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Understanding touch-first interaction design, keyboard management importance, and platform-specific UI patterns",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "react-native"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_FLATLIST_KEY"
          ]
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-9",
      "lessonNumber": 9,
      "lessonTitle": "Connected Features (Authentication, Real-time, Social, Notifications)",
      "lessonSlug": "connected-features-(authentication,-real-time,-social,-notifications)",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l9-q1",
          "globalId": "exit-ticket-0626",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nHow do JWT authentication, real-time data synchronization, and push notifications work together to create connected mobile experiences?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "These features cannot be used together in the same app",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. These features cannot be used together in the same app... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "JWT provides secure authentication, real-time sync enables live updates, push notifications engage users - together creating seamless social experiences",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! JWT provides secure authentication, real-time sync enables live updates, push notifications engage u... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only one of these features should be implemented in any mobile app",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only one of these features should be implemented in any mobile app... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "These features are only available for web applications",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. These features are only available for web applications... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "JWT provides secure authentication, real-time sync enables live updates, push notifications engage users - together creating seamless social experiences",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l9-q2",
          "globalId": "exit-ticket-0627",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow do the authentication, real-time, and social features in this implementation work together?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const useAuth = () => {\nconst [user, setUser] = useState(null);\nconst login = async (credentials) => {\ntry {\nconst response = await fetch('/api/login', {\nmethod: 'POST',\nbody: JSON.stringify(credentials),\n});\nconst data = await response.json();\nif (data.token) {\nawait AsyncStorage.setItem('authToken', data.token);\nsetUser(data.user);\nawait registerForPushNotifications();\n}\n} catch (error) {\nAlert.alert('Login Failed', error.message);\n}\n};\n// ... rest of auth logic\n};",
          "options": [
            {
              "key": "A",
              "text": "Only handles user interface without any backend integration",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only handles user interface without any backend integration... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Auth context provides user identity, enables push notification registration, and integrates with real-time features",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Auth context provides user identity, enables push notification registration, and integrates with rea... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Works offline without any server communication",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Works offline without any server communication... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only manages local storage without authentication",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only manages local storage without authentication... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Auth context provides user identity, enables push notification registration, and integrates with real-time features",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_ASYNC_AWAIT_CONFUSION",
            "M1_STATE_VS_PROPS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l9-q3",
          "globalId": "exit-ticket-0628",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you architect friend requests, real-time chat, and activity notifications for a social app?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Implement all features as separate, disconnected systems",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Implement all features as separate, disconnected systems... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Consider user relationship data models, real-time messaging protocols, and notification categorization with privacy controls",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Consider user relationship data models, real-time messaging protocols, and notification categorizati... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Use only email for all social interactions",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only email for all social interactions... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Avoid real-time features to reduce complexity",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Avoid real-time features to reduce complexity... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Consider user relationship data models, real-time messaging protocols, and notification categorization with privacy controls",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l9-q4",
          "globalId": "exit-ticket-0629",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat challenges would you address when designing collaborative features for a productivity app with live updates and notifications?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Prevent multiple users from working on the same project",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Prevent multiple users from working on the same project... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Operational transformation for concurrent editing, permission systems, and real-time cursor/user presence",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Operational transformation for concurrent editing, permission systems, and real-time cursor/user pre... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only allow one user to edit projects at a time",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only allow one user to edit projects at a time... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Use only static documents without collaboration features",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Use only static documents without collaboration features... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Operational transformation for concurrent editing, permission systems, and real-time cursor/user presence",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l9-q5",
          "globalId": "exit-ticket-0630",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow do you balance connected features with user privacy, performance, and battery life?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Implement all possible connected features without considering limitations",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Implement all possible connected features without considering limitations... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Use permission-first design, background processing limitations awareness, and user control over notifications",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Use permission-first design, background processing limitations awareness, and user control over noti... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Avoid all connected features to ensure privacy",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Avoid all connected features to ensure privacy... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Let users configure everything without providing reasonable defaults",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Let users configure everything without providing reasonable defaults... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Use permission-first design, background processing limitations awareness, and user control over notifications",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-10",
      "lessonNumber": 10,
      "lessonTitle": "Performance Optimization",
      "lessonSlug": "performance-optimization",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l10-q1",
          "globalId": "exit-ticket-0631",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhy is performance especially critical for mobile apps, and what are five key performance metrics developers should monitor?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Performance doesn't matter for mobile apps since devices are powerful",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Performance doesn't matter for mobile apps since devices are powerful... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Critical due to hardware constraints and battery life; monitor app launch time, frame rate, memory usage, battery consumption, and network latency",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Critical due to hardware constraints and battery life; monitor app launch time, frame rate, memory u... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only app store ratings matter, not actual performance metrics",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only app store ratings matter, not actual performance metrics... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Performance is only important for gaming apps",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Performance is only important for gaming apps... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Critical due to hardware constraints and battery life; monitor app launch time, frame rate, memory usage, battery consumption, and network latency",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l10-q2",
          "globalId": "exit-ticket-0632",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow do these optimizations improve list performance in this component?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "const OptimizedListItem = memo(({ item, onPress, isSelected }) => {\nconst handlePress = useCallback(() => {\nonPress(item.id);\n}, [item.id, onPress]);\nconst itemStyle = useMemo(() => ({\npadding: 16,\nbackgroundColor: isSelected ? '#e3f2fd' : 'white',\n}), [isSelected]);\nreturn (\n<TouchableOpacity style={itemStyle} onPress={handlePress}>\n<Text numberOfLines={1}>{item.title}</Text>\n</TouchableOpacity>\n);\n});",
          "options": [
            {
              "key": "A",
              "text": "Makes the code more complex without any performance benefits",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Makes the code more complex without any performance benefits... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Uses React.memo to prevent unnecessary re-renders, useCallback for stable function references, and useMemo for computed styles",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Uses React.memo to prevent unnecessary re-renders, useCallback for stable function references, and u... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only works for lists with fewer than 10 items",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only works for lists with fewer than 10 items... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Automatically handles all performance issues without developer involvement",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Automatically handles all performance issues without developer involvement... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Uses React.memo to prevent unnecessary re-renders, useCallback for stable function references, and useMemo for computed styles",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_TOUCHABLE_COMPONENTS",
            "M1_EVENT_HANDLING",
            "M1_FLATLIST_KEY"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l10-q3",
          "globalId": "exit-ticket-0633",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you systematically identify and fix slow startup times and memory issues on older devices?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Only test on the latest devices and ignore older hardware",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only test on the latest devices and ignore older hardware... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Use performance profiling tools, bundle size analysis, code splitting, and memory leak detection",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Use performance profiling tools, bundle size analysis, code splitting, and memory leak detection... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Rewrite the entire app in a different framework",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Rewrite the entire app in a different framework... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Add more features to mask performance issues",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Add more features to mask performance issues... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Use performance profiling tools, bundle size analysis, code splitting, and memory leak detection",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l10-q4",
          "globalId": "exit-ticket-0634",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nHow would you optimize a photo-sharing app displaying hundreds of high-resolution images with smooth scrolling?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Load all images at full resolution simultaneously for best quality",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Load all images at full resolution simultaneously for best quality... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Use image compression, progressive loading, virtualized lists, and efficient caching strategies",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Use image compression, progressive loading, virtualized lists, and efficient caching strategies... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Limit users to only 10 photos maximum",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Limit users to only 10 photos maximum... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Convert all photos to text descriptions instead",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Convert all photos to text descriptions instead... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Use image compression, progressive loading, virtualized lists, and efficient caching strategies",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_SCROLL_VIEW_PERFORMANCE",
            "M1_IMAGE_SOURCE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l10-q5",
          "globalId": "exit-ticket-0635",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow do you balance performance optimization with development speed and maintainability?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Always optimize everything from the beginning regardless of impact",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Always optimize everything from the beginning regardless of impact... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Use measurement-driven optimization, avoid premature optimization, and focus on user-perceived performance",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Use measurement-driven optimization, avoid premature optimization, and focus on user-perceived perfo... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Never optimize anything to maintain simple code",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Never optimize anything to maintain simple code... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only optimize code that looks slow without measuring actual performance",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only optimize code that looks slow without measuring actual performance... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Use measurement-driven optimization, avoid premature optimization, and focus on user-perceived performance",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-11",
      "lessonNumber": 11,
      "lessonTitle": "Testing and Quality",
      "lessonSlug": "testing-and-quality",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l11-q1",
          "globalId": "exit-ticket-0636",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat's the difference between unit tests, integration tests, and end-to-end tests in React Native development?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "All test types do the same thing and can be used interchangeably",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. All test types do the same thing and can be used interchangeably... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Unit tests: individual functions/components; Integration tests: component interactions; E2E tests: complete user flows",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Unit tests: individual functions/components; Integration tests: component interactions; E2E tests: c... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only unit tests are necessary for React Native apps",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only unit tests are necessary for React Native apps... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Testing is not important for mobile app development",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Testing is not important for mobile app development... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Unit tests: individual functions/components; Integration tests: component interactions; E2E tests: complete user flows",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "react-native"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l11-q2",
          "globalId": "exit-ticket-0637",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this testing setup ensure component quality and reliability?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "describe('LoginForm', () => {\nconst mockOnLogin = jest.fn();\ntest('shows validation errors for empty fields', async () => {\nconst { getByTestId } = render(\n<LoginForm onLogin={mockOnLogin} loading={false} />\n);\nfireEvent.press(getByTestId('login-button'));\nawait waitFor(() => {\nexpect(getByTestId('email-error')).toBeTruthy();\nexpect(getByTestId('password-error')).toBeTruthy();\n});\nexpect(mockOnLogin).not.toHaveBeenCalled();\n});\n});",
          "options": [
            {
              "key": "A",
              "text": "Only tests that components render without any behavior verification",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only tests that components render without any behavior verification... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Uses testID for reliable element selection, tests user interactions, mocks external dependencies, and covers error states",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Uses testID for reliable element selection, tests user interactions, mocks external dependencies, an... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Requires manual testing for all component functionality",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Requires manual testing for all component functionality... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only works with class components, not functional components",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only works with class components, not functional components... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Uses testID for reliable element selection, tests user interactions, mocks external dependencies, and covers error states",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_ASYNC_AWAIT_CONFUSION"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l11-q3",
          "globalId": "exit-ticket-0638",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you implement error monitoring and debugging strategies for production apps that crash on certain devices?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Ignore crashes since they're rare and difficult to fix",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Ignore crashes since they're rare and difficult to fix... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Use crash reporting tools, error boundaries for graceful failure, logging strategies, and device-specific testing",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Use crash reporting tools, error boundaries for graceful failure, logging strategies, and device-spe... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only test on one device type to ensure consistency",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only test on one device type to ensure consistency... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Ask users to report all crashes manually via email",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Ask users to report all crashes manually via email... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Use crash reporting tools, error boundaries for graceful failure, logging strategies, and device-specific testing",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l11-q4",
          "globalId": "exit-ticket-0639",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat should a quality assurance process include for a team developing a React Native app?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Only manual testing right before app store submission",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only manual testing right before app store submission... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Automated testing pipeline, code review requirements, continuous integration, and device testing lab",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Automated testing pipeline, code review requirements, continuous integration, and device testing lab... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Let individual developers handle all testing independently",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Let individual developers handle all testing independently... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only test the app on simulators, never real devices",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only test the app on simulators, never real devices... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Automated testing pipeline, code review requirements, continuous integration, and device testing lab",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "react-native"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l11-q5",
          "globalId": "exit-ticket-0640",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nHow has implementing testing and quality processes changed your development workflow and code maintainability?\n---",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Testing slows down development and should be avoided",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Testing slows down development and should be avoided... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Testing serves as documentation, provides refactoring confidence, and improves long-term code maintainability",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Testing serves as documentation, provides refactoring confidence, and improves long-term code mainta... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only senior developers need to write tests",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only senior developers need to write tests... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Manual testing is always superior to automated testing",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Manual testing is always superior to automated testing... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Testing serves as documentation, provides refactoring confidence, and improves long-term code maintainability",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-12",
      "lessonNumber": 12,
      "lessonTitle": "Launch and Deployment",
      "lessonSlug": "launch-and-deployment",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l12-q1",
          "globalId": "exit-ticket-0641",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nHow do App Store Optimization (ASO), beta testing, and CI/CD pipeline work together for successful app launches?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "These concepts are unrelated and should be handled separately",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. These concepts are unrelated and should be handled separately... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "ASO optimizes store listings for discoverability, beta testing provides pre-release feedback, CI/CD ensures quality releases through automated processes",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! ASO optimizes store listings for discoverability, beta testing provides pre-release feedback, CI/CD ... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only ASO matters for app success, testing and deployment are optional",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only ASO matters for app success, testing and deployment are optional... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "These concepts only apply to web applications, not mobile apps",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. These concepts only apply to web applications, not mobile apps... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "ASO optimizes store listings for discoverability, beta testing provides pre-release feedback, CI/CD ensures quality releases through automated processes",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l12-q2",
          "globalId": "exit-ticket-0642",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nHow does this deployment configuration support a professional app launch process?",
          "hasCodeBlock": true,
          "codeLanguage": "jsx",
          "codeContent": "export default ({ config }) => {\nconst isProduction = process.env.NODE_ENV === 'production';\nreturn {\nname: isProduction ? 'MyApp' : 'MyApp (Dev)',\nversion: process.env.APP_VERSION || '1.0.0',\nupdates: {\nurl: isProduction\n? 'https://u.expo.dev/your-project-id'\n: undefined,\n},\nextra: {\napiUrl: isProduction\n? 'https://api.myapp.com'\n: 'https://dev-api.myapp.com',\n},\n};\n};",
          "options": [
            {
              "key": "A",
              "text": "Uses the same configuration for all environments to avoid complexity",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Uses the same configuration for all environments to avoid complexity... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Provides environment-based configuration, proper versioning strategy, and OTA update capability",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Provides environment-based configuration, proper versioning strategy, and OTA update capability... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only works for development, not production deployments",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only works for development, not production deployments... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Requires manual configuration changes for each deployment",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Requires manual configuration changes for each deployment... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Provides environment-based configuration, proper versioning strategy, and OTA update capability",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "jsx"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_EXPO_VS_REACT_NATIVE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l12-q3",
          "globalId": "exit-ticket-0643",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow would you handle discovering a critical performance issue affecting 10% of users on older devices just before your app launch?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Launch immediately since it only affects a small percentage of users",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Launch immediately since it only affects a small percentage of users... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Assess impact vs delay trade-offs, consider partial rollout strategies, and implement performance monitoring",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Assess impact vs delay trade-offs, consider partial rollout strategies, and implement performance mo... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Cancel the launch permanently until the issue is completely resolved",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Cancel the launch permanently until the issue is completely resolved... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Ignore the issue since older devices will eventually be replaced",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Ignore the issue since older devices will eventually be replaced... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Assess impact vs delay trade-offs, consider partial rollout strategies, and implement performance monitoring",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l12-q4",
          "globalId": "exit-ticket-0644",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat should a complete app launch strategy include for a social networking app across pre-launch, launch day, and post-launch phases?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Only focus on the launch day with maximum marketing spend",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only focus on the launch day with maximum marketing spend... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Beta testing program, app store optimization, launch day monitoring, user onboarding optimization, and retention strategies",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Beta testing program, app store optimization, launch day monitoring, user onboarding optimization, a... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Launch without any testing to get to market quickly",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Launch without any testing to get to market quickly... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Rely only on organic growth without any marketing strategy",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Rely only on organic growth without any marketing strategy... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Beta testing program, app store optimization, launch day monitoring, user onboarding optimization, and retention strategies",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l12-q5",
          "globalId": "exit-ticket-0645",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhat's the relationship between technical excellence and market success in mobile app launches?\n---\n## Assessment Guidelines\n- **Correct Answer**: 1 point\n- **Total Possible**: 60 points (12 concepts  5 questions)\n- **A**: 54-60 points (90-100%)\n- **B**: 48-53 points (80-89%)\n- **C**: 42-47 points (70-79%)\n- **D**: 36-41 points (60-69%)\n- **F**: Below 36 points (Below 60%)\nThese 60 MCQ questions align with the M1 course's 12 concepts and support assessment of the 4 major projects students will complete throughout the course.\n---\n*MCQ version created from M1-Mobile-Exit-Tickets (new).md - Updated for 12-concept structure*",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Technical quality doesn't matter if the marketing is good enough",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Technical quality doesn't matter if the marketing is good enough... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Technical quality serves as foundation for success, impacts user experience and ratings, and enables long-term sustainability",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Technical quality serves as foundation for success, impacts user experience and ratings, and enables... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Only market timing matters, technical implementation is irrelevant",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only market timing matters, technical implementation is irrelevant... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Perfect technical implementation guarantees market success",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Perfect technical implementation guarantees market success... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Technical quality serves as foundation for success, impacts user experience and ratings, and enables long-term sustainability",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-10-15",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-13",
      "lessonNumber": 13,
      "lessonTitle": "Device Motion and Sensors",
      "lessonSlug": "device-motion-and-sensors",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l13-q1",
          "globalId": "exit-ticket-0646",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat is the key difference between an accelerometer and a gyroscope sensor in mobile devices?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Accelerometer measures rotation rate, gyroscope measures movement speed",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Accelerometer measures rotation rate, gyroscope measures movement speed... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Accelerometer measures linear acceleration (movement/gravity), gyroscope measures rotation rate (tilt/orientation)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Accelerometer measures linear acceleration (movement/gravity), gyroscope measures rotation rate (til... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "They measure the same thing but in different units",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. They measure the same thing but in different units... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Accelerometer works only on iOS, gyroscope only on Android",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Accelerometer works only on iOS, gyroscope only on Android... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Accelerometer measures linear acceleration (movement/gravity), gyroscope measures rotation rate (tilt/orientation)",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "sensors",
              "expo-sensors"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l13-q2",
          "globalId": "exit-ticket-0647",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nWhat does this shake detection code accomplish?",
          "hasCodeBlock": true,
          "codeLanguage": "javascript",
          "codeContent": "const subscription = Accelerometer.addListener(data => {\n  const threshold = 1.5;\n  const isShaking =\n    Math.abs(data.x) > threshold ||\n    Math.abs(data.y) > threshold ||\n    Math.abs(data.z) > threshold;\n\n  if (isShaking) {\n    setShakeCount(prev => prev + 1);\n  }\n});\nAccelerometer.setUpdateInterval(100);",
          "options": [
            {
              "key": "A",
              "text": "Detects device orientation changes and rotates the screen accordingly",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Detects device orientation changes and rotates the screen accordingly... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Monitors accelerometer for movements exceeding 1.5g on any axis and counts them as shakes",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Monitors accelerometer for movements exceeding 1.5g on any axis and counts them as shakes... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Measures the device's GPS location every 100 milliseconds",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Measures the device's GPS location every 100 milliseconds... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Creates a vibration pattern when the device is tilted",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Creates a vibration pattern when the device is tilted... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Monitors accelerometer for movements exceeding 1.5g on any axis and counts them as shakes",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "accelerometer",
              "javascript"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l13-q3",
          "globalId": "exit-ticket-0648",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nWhich update interval should you choose for a shake-to-undo feature in your app?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "10ms - Maximum responsiveness for best detection",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 10ms - Maximum responsiveness for best detection... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "50ms - Game-level smoothness required",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 50ms - Game-level smoothness required... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "100ms - Good balance between responsiveness and battery efficiency",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! 100ms - Good balance between responsiveness and battery efficiency... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "D",
              "text": "1000ms - Minimal battery usage is top priority",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 1000ms - Minimal battery usage is top priority... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "100ms - Good balance between responsiveness and battery efficiency",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development",
              "sensors",
              "performance"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l13-q4",
          "globalId": "exit-ticket-0649",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nYou're building a level tool app that shows if a surface is flat. Which sensor should you primarily use?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Accelerometer - measures gravity direction to detect if device is level",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Accelerometer - measures gravity direction to detect if device is level... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "B",
              "text": "Gyroscope - measures absolute position of the device",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Gyroscope - measures absolute position of the device... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "Camera - visually analyzes the surface for flatness",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Camera - visually analyzes the surface for flatness... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "GPS - uses satellite data to determine surface angle",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. GPS - uses satellite data to determine surface angle... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Accelerometer - measures gravity direction to detect if device is level",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "sensors",
              "accelerometer"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l13-q5",
          "globalId": "exit-ticket-0650",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhat happens if you forget to remove sensor subscriptions when a component unmounts?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Nothing - React Native automatically handles cleanup",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Nothing - React Native automatically handles cleanup... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "The app crashes immediately on unmount",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. The app crashes immediately on unmount... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "Memory leaks occur and battery continues to drain from background sensor updates",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Memory leaks occur and battery continues to drain from background sensor updates... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "D",
              "text": "The sensor stops working across the entire app",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. The sensor stops working across the entire app... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "Memory leaks occur and battery continues to drain from background sensor updates",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "sensors",
              "memory-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_COMPONENT_LIFECYCLE",
            "M1_USEEFFECT_DEPS"
          ]
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-14",
      "lessonNumber": 14,
      "lessonTitle": "Touch Input and Canvas Drawing",
      "lessonSlug": "touch-input-and-canvas-drawing",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l14-q1",
          "globalId": "exit-ticket-0651",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhich touch event property should you use for canvas-relative drawing coordinates?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "pageX and pageY - screen-relative coordinates",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. pageX and pageY - screen-relative coordinates... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "locationX and locationY - component-relative coordinates",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! locationX and locationY - component-relative coordinates... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "clientX and clientY - window-relative coordinates",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. clientX and clientY - window-relative coordinates... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "screenX and screenY - device-relative coordinates",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. screenX and screenY - device-relative coordinates... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "locationX and locationY - component-relative coordinates",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "touch-events",
              "drawing"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_EVENT_HANDLING"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l14-q2",
          "globalId": "exit-ticket-0652",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nWhat does the SVG path command 'M 10,20 L 30,40' do?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Draws a rectangle from (10,20) to (30,40)",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Draws a rectangle from (10,20) to (30,40)... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Moves to (10,20) and draws a line to (30,40)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Moves to (10,20) and draws a line to (30,40)... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Creates a curve between two points",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Creates a curve between two points... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Defines a circular arc between points",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Defines a circular arc between points... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Moves to (10,20) and draws a line to (30,40)",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "svg",
              "drawing"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l14-q3",
          "globalId": "exit-ticket-0653",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nWhy is it beneficial to separate 'currentStroke' from the 'strokes' array in a drawing app?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "To use less memory overall",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To use less memory overall... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "To improve performance by reducing unnecessary re-renders of completed strokes",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! To improve performance by reducing unnecessary re-renders of completed strokes... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "To make the code shorter and simpler",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To make the code shorter and simpler... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "To enable multi-touch drawing with multiple fingers",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To enable multi-touch drawing with multiple fingers... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "To improve performance by reducing unnecessary re-renders of completed strokes",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development",
              "state-management",
              "performance"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l14-q4",
          "globalId": "exit-ticket-0654",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nGiven points [{x:5, y:10}, {x:15, y:20}, {x:25, y:15}], what is the correct SVG path data string?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "L 5,10 L 15,20 L 25,15",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. L 5,10 L 15,20 L 25,15... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "M 5,10 M 15,20 M 25,15",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. M 5,10 M 15,20 M 25,15... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "M 5,10 L 15,20 L 25,15",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! M 5,10 L 15,20 L 25,15... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "D",
              "text": "5,10 15,20 25,15",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 5,10 15,20 25,15... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "M 5,10 L 15,20 L 25,15",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "svg",
              "drawing"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l14-q5",
          "globalId": "exit-ticket-0655",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhich feature is most important for a production-quality signature capture app?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Support for multiple colors and brush styles",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Support for multiple colors and brush styles... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Validation that a signature was actually provided before proceeding",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Validation that a signature was actually provided before proceeding... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Background music while signing",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Background music while signing... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Animated signature preview with special effects",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Animated signature preview with special effects... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Validation that a signature was actually provided before proceeding",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "signatures",
              "ux-design"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-15",
      "lessonNumber": 15,
      "lessonTitle": "Barcode and QR Code Scanning",
      "lessonSlug": "barcode-and-qr-code-scanning",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l15-q1",
          "globalId": "exit-ticket-0656",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat is the main difference between 1D and 2D barcodes?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "1D barcodes are older and less reliable than 2D barcodes",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 1D barcodes are older and less reliable than 2D barcodes... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "2D barcodes can store more data in a smaller space by encoding both horizontally and vertically",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! 2D barcodes can store more data in a smaller space by encoding both horizontally and vertically... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "1D barcodes work better on mobile devices",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 1D barcodes work better on mobile devices... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "2D barcodes require special hardware to scan",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 2D barcodes require special hardware to scan... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "2D barcodes can store more data in a smaller space by encoding both horizontally and vertically",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "barcodes",
              "qr-codes"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l15-q2",
          "globalId": "exit-ticket-0657",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nWhen should you request camera permission for barcode scanning?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Only when the user taps the scan button",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only when the user taps the scan button... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "When the scanner component mounts using useEffect, so it's ready when needed",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! When the scanner component mounts using useEffect, so it's ready when needed... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "After showing scan results",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. After showing scan results... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only if permission was previously denied",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only if permission was previously denied... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "When the scanner component mounts using useEffect, so it's ready when needed",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "permissions",
              "camera"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l15-q3",
          "globalId": "exit-ticket-0658",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nHow do you safely handle URLs found in QR codes?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Automatically open all URLs immediately for convenience",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Automatically open all URLs immediately for convenience... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Show a confirmation dialog with the full URL before opening external links",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Show a confirmation dialog with the full URL before opening external links... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Ignore all URLs for maximum security",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Ignore all URLs for maximum security... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Only open URLs ending in .com",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only open URLs ending in .com... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Show a confirmation dialog with the full URL before opening external links",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development",
              "security",
              "qr-codes"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_SAFE_AREA_INSETS"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l15-q4",
          "globalId": "exit-ticket-0659",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhy should you set 'scanned' to true after scanning a barcode?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "To save the scan to history automatically",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To save the scan to history automatically... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "To prevent multiple rapid scans of the same code and give users time to view results",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! To prevent multiple rapid scans of the same code and give users time to view results... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "To enable the camera flash",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To enable the camera flash... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "To improve scan accuracy",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To improve scan accuracy... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "To prevent multiple rapid scans of the same code and give users time to view results",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "state-management",
              "ux-design"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l15-q5",
          "globalId": "exit-ticket-0660",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhat free API provides product information from barcodes including name, brand, and nutrition info?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Google Product API",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Google Product API... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Amazon Product Advertising API",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Amazon Product Advertising API... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "Open Food Facts API",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Open Food Facts API... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "D",
              "text": "Barcode Lookup Premium API",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Barcode Lookup Premium API... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "Open Food Facts API",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "apis",
              "product-data"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-16",
      "lessonNumber": 16,
      "lessonTitle": "Audio Recording and Playback",
      "lessonSlug": "audio-recording-and-playback",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l16-q1",
          "globalId": "exit-ticket-0661",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat is the correct order of steps to record audio in a React Native app?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Configure mode  Request permission  Create recording  Start recording",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Configure mode  Request permission  Create recording  Start recording... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Request permission  Configure audio mode  Create recording  Start recording",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Request permission  Configure audio mode  Create recording  Start recording... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Create recording  Request permission  Configure mode  Start recording",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Create recording  Request permission  Configure mode  Start recording... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Start recording  Request permission  Configure mode  Create recording",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Start recording  Request permission  Configure mode  Create recording... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Request permission  Configure audio mode  Create recording  Start recording",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "audio",
              "expo-av"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l16-q2",
          "globalId": "exit-ticket-0662",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nWhat happens if you try to record audio without requesting microphone permission first?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "The app will crash immediately",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. The app will crash immediately... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Recording will work but with no audio captured",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Recording will work but with no audio captured... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "The recording will have static noise instead",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. The recording will have static noise instead... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "An error will be thrown that needs to be handled",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! An error will be thrown that needs to be handled... is indeed correct. This demonstrates your understanding of the concept."
              }
            }
          ],
          "correctAnswer": "D",
          "correctAnswerText": "An error will be thrown that needs to be handled",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "audio",
              "permissions"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l16-q3",
          "globalId": "exit-ticket-0663",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nWhy is it important to call unloadAsync() on sounds when you're done with them?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "To save battery life during playback",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To save battery life during playback... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "To free up memory and prevent memory leaks in your app",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! To free up memory and prevent memory leaks in your app... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "To improve audio quality for future recordings",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To improve audio quality for future recordings... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "To reduce the file size of recorded audio",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To reduce the file size of recorded audio... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "To free up memory and prevent memory leaks in your app",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development",
              "audio",
              "memory-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_ASYNC_AWAIT_CONFUSION"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l16-q4",
          "globalId": "exit-ticket-0664",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhat's the trade-off when using Audio.RecordingOptionsPresets.HIGH_QUALITY?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Better audio quality but larger file sizes requiring more storage",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Better audio quality but larger file sizes requiring more storage... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "B",
              "text": "Faster recording but lower quality output",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Faster recording but lower quality output... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "Better quality but slower playback speed",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Better quality but slower playback speed... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Smaller file size but increased battery usage",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Smaller file size but increased battery usage... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Better audio quality but larger file sizes requiring more storage",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "audio",
              "performance"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l16-q5",
          "globalId": "exit-ticket-0665",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhich approach correctly implements a recording duration timer?",
          "hasCodeBlock": true,
          "codeLanguage": "javascript",
          "codeContent": "// Option A\nconst duration = recording.getDurationMillis();\n\n// Option B\nconst [duration, setDuration] = useState(0);\nconst interval = setInterval(() => {\n  setDuration(prev => prev + 1);\n}, 1000);",
          "options": [
            {
              "key": "A",
              "text": "Option A - Use the built-in duration method directly",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Option A - Use the built-in duration method directly... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Option B - Use useState with setInterval to track seconds manually",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Option B - Use useState with setInterval to track seconds manually... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Neither - duration tracking is automatic in expo-av",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Neither - duration tracking is automatic in expo-av... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Both are valid with identical results",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Both are valid with identical results... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Option B - Use useState with setInterval to track seconds manually",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "audio",
              "state-management"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_STATE_VS_PROPS"
          ]
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-17",
      "lessonNumber": 17,
      "lessonTitle": "Haptic Feedback and Vibration",
      "lessonSlug": "haptic-feedback-and-vibration",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l17-q1",
          "globalId": "exit-ticket-0666",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhat are the three types of haptic feedback available in expo-haptics?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Light, Medium, and Heavy vibrations only",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Light, Medium, and Heavy vibrations only... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Impact (physical bump), Notification (contextual patterns), and Selection (subtle tick)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Impact (physical bump), Notification (contextual patterns), and Selection (subtle tick)... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Vibrate, Pulse, and Rhythm patterns",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Vibrate, Pulse, and Rhythm patterns... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Short, Long, and Continuous vibrations",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Short, Long, and Continuous vibrations... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Impact (physical bump), Notification (contextual patterns), and Selection (subtle tick)",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "haptics",
              "ux-design"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_EXPO_VS_REACT_NATIVE"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l17-q2",
          "globalId": "exit-ticket-0667",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nWhat haptic feedback will this code trigger?",
          "hasCodeBlock": true,
          "codeLanguage": "javascript",
          "codeContent": "const handleSave = async () => {\n  if (!validateInput()) {\n    await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);\n    return;\n  }\n  await saveData();\n  await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);\n};",
          "options": [
            {
              "key": "A",
              "text": "Only Success feedback regardless of validation",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only Success feedback regardless of validation... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Only Error feedback regardless of validation",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Only Error feedback regardless of validation... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "Error feedback if validation fails, Success feedback if save completes",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Error feedback if validation fails, Success feedback if save completes... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "D",
              "text": "Both Error and Success feedback always",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Both Error and Success feedback always... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "Error feedback if validation fails, Success feedback if save completes",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "haptics",
              "javascript"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_ASYNC_AWAIT_CONFUSION"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l17-q3",
          "globalId": "exit-ticket-0668",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nWhich of these is a good use of haptic feedback?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Vibrating on every scroll event",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Vibrating on every scroll event... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Haptic feedback on button press for confirmation",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Haptic feedback on button press for confirmation... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Continuous vibration during loading states",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Continuous vibration during loading states... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Haptic feedback for background data sync completion",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Haptic feedback for background data sync completion... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Haptic feedback on button press for confirmation",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development",
              "haptics",
              "ux-design"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l17-q4",
          "globalId": "exit-ticket-0669",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhy should you check AccessibilityInfo.isReduceMotionEnabled() before triggering haptics?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "To improve battery life on older devices",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To improve battery life on older devices... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "To respect users with motion sensitivity or vestibular disorders who may be uncomfortable with vibrations",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! To respect users with motion sensitivity or vestibular disorders who may be uncomfortable with vibra... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "To make haptics stronger for accessibility",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To make haptics stronger for accessibility... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "To enable haptics on devices that normally don't support them",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. To enable haptics on devices that normally don't support them... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "To respect users with motion sensitivity or vestibular disorders who may be uncomfortable with vibrations",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "haptics",
              "accessibility"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l17-q5",
          "globalId": "exit-ticket-0670",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhat haptic pattern sequence is appropriate for a delete button that requires confirmation?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Light impact on press, no feedback on confirm",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Light impact on press, no feedback on confirm... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Heavy impact on press to signal important action, Success notification after confirmed deletion",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Heavy impact on press to signal important action, Success notification after confirmed deletion... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Error notification on press, Error notification on confirm",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Error notification on press, Error notification on confirm... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Selection tick repeated continuously until confirmed",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Selection tick repeated continuously until confirmed... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Heavy impact on press to signal important action, Success notification after confirmed deletion",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "haptics",
              "ux-design"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_TOUCHABLE_COMPONENTS"
          ]
        }
      ]
    },
    {
      "lessonId": "m1-mobile-i-love-lesson-18",
      "lessonNumber": 18,
      "lessonTitle": "Performance and Testing",
      "lessonSlug": "performance-and-testing",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "m1-mobile-i-love-l18-q1",
          "globalId": "exit-ticket-0671",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Vocabulary/Concepts\nWhy are both performance and testing equally important for portfolio-quality mobile apps?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Testing is more important because users don't notice performance issues",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Testing is more important because users don't notice performance issues... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Performance is more important because bugs can be fixed after launch",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Performance is more important because bugs can be fixed after launch... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "C",
              "text": "Quality = Speed + Reliability - a fast app that crashes or a reliable but laggy app both look unprofessional",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Quality = Speed + Reliability - a fast app that crashes or a reliable but laggy app both look unprof... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "D",
              "text": "Neither matters as much as having good visual design",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Neither matters as much as having good visual design... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "Quality = Speed + Reliability - a fast app that crashes or a reliable but laggy app both look unprofessional",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 45,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mobile-development",
              "performance",
              "testing"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l18-q2",
          "globalId": "exit-ticket-0672",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "Code Understanding\nWhat does wrapping a component with React.memo() accomplish?",
          "hasCodeBlock": true,
          "codeLanguage": "javascript",
          "codeContent": "const OptimizedComponent = memo(({ title, description }) => {\n  return (\n    <View>\n      <Text>{title}</Text>\n      <Text>{description}</Text>\n    </View>\n  );\n});",
          "options": [
            {
              "key": "A",
              "text": "Automatically caches all data in the component",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Automatically caches all data in the component... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Prevents unnecessary re-renders when props haven't changed",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Prevents unnecessary re-renders when props haven't changed... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Makes the component render faster by using native code",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Makes the component render faster by using native code... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Stores the component in memory permanently",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Stores the component in memory permanently... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Prevents unnecessary re-renders when props haven't changed",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mobile-development",
              "react",
              "performance"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        },
        {
          "questionId": "m1-mobile-i-love-l18-q3",
          "globalId": "exit-ticket-0673",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Problem-Solving\nWhich FlatList prop helps improve scrolling performance by unmounting items that are off-screen?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "maxToRenderPerBatch",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. maxToRenderPerBatch... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "removeClippedSubviews",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! removeClippedSubviews... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "getItemLayout",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. getItemLayout... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "keyExtractor",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. keyExtractor... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "removeClippedSubviews",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "apply",
            "tags": [
              "mobile-development",
              "flatlist",
              "performance"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_COMPONENT_LIFECYCLE",
            "M1_USEEFFECT_DEPS",
            "M1_SCROLL_VIEW_PERFORMANCE",
            "M1_FLATLIST_KEY"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l18-q4",
          "globalId": "exit-ticket-0674",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "Application\nWhich of these causes memory leaks that must be prevented in useEffect?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Calling setState too frequently",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Calling setState too frequently... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "Uncleared intervals, unremoved event listeners, and unclosed subscriptions",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! Uncleared intervals, unremoved event listeners, and unclosed subscriptions... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "Using too many props in a component",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Using too many props in a component... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Having too many nested components",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Having too many nested components... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Uncleared intervals, unremoved event listeners, and unclosed subscriptions",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "mobile-development",
              "memory-management",
              "useeffect"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": [
            "M1_EVENT_HANDLING"
          ]
        },
        {
          "questionId": "m1-mobile-i-love-l18-q5",
          "globalId": "exit-ticket-0675",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Reflection/Meta-learning\nWhat is the recommended test coverage goal for utility functions in a portfolio-quality app?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "100% coverage is always required",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 100% coverage is always required... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "B",
              "text": "80%+ coverage for utility functions, with focus on critical user flows",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the right answer.",
                "detailed": "Excellent work! 80%+ coverage for utility functions, with focus on critical user flows... is indeed correct. This demonstrates your understanding of the concept."
              }
            },
            {
              "key": "C",
              "text": "50% coverage is sufficient for portfolio projects",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. 50% coverage is sufficient for portfolio projects... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            },
            {
              "key": "D",
              "text": "Testing is optional for portfolio projects",
              "isCorrect": false,
              "feedback": {
                "short": "Not quite right.",
                "detailed": "This answer is incorrect. Testing is optional for portfolio projects... is not the best choice here. Review the concept and try again.",
                "socraticHint": "Think about the key differences between the options. What makes one answer more accurate than the others?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "80%+ coverage for utility functions, with focus on critical user flows",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "mobile-development",
              "testing",
              "best-practices"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-11-27",
            "lastModified": "2025-12-24"
          },
          "misconceptionTargets": []
        }
      ]
    }
  ],
  "metadata": {
    "version": "1.1",
    "generatedBy": "claude-code",
    "totalLessons": 18,
    "totalQuestions": 90,
    "lastModified": "2025-12-24"
  },
  "staticVersion": "1.0.0",
  "generatedAt": "2025-12-24T00:53:48.939Z"
}