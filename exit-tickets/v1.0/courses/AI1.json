{
  "courseId": "ai-1",
  "courseName": "AI-1 Data Analysis and Data Science",
  "courseCode": "AI1",
  "domain": "ai_data_science",
  "tier": "intermediate",
  "difficulty": 2,
  "totalLessons": 20,
  "totalQuestions": 100,
  "sourceFile": "AI-1-Data-Analysis-MCQ.md",
  "lessons": [
    {
      "lessonId": "ai-1-lesson-1",
      "lessonNumber": 1,
      "lessonTitle": "Introduction to Python\n\n### Q1: Vocabulary/Concepts\nWhat is Python and why is it considered a \"high-level programming language\"?\nA) Python is a web browser that makes coding easier\nB) Python is a programming language with simple syntax that requires fewer lines of code to complete tasks ✓\nC) Python is a database system for storing information\nD) Python is a type of computer hardware\n\n### Q2: Code Understanding\nWhat will be displayed if a user enters \"reading\" for this code?\n```python\nname = input(\"What is your favorite hobby? \")\nprint(\"I love\", name, \"too!\")\n```\nA) What is your favorite hobby?\nB) I love reading too! ✓\nC) I love, reading, too!\nD) reading\n\n### Q3: Problem-Solving\nWhich code correctly asks for a user's age and displays a personalized message?\nA) age = input(\"What is your age? \"); print(\"You are\", age, \"years old! That's awesome!\") ✓\nB) print(\"What is your age? \"); age = input(); print(age)\nC) age = print(\"What is your age? \"); input(\"You are awesome!\")\nD) input(age); print(\"You are old!\")\n\n### Q4: Application\nWhat functions would a data scientist use to gather and display user information?\nA) print() only\nB) input() only\nC) input() to gather information and print() to display results ✓\nD) Neither function is useful for data collection\n\n### Q5: Reflection/Meta-learning\nWhat is the main difference between print() and input() functions?\nA) print() gets information from users, input() displays information\nB) print() displays information to users, input() gets information from users ✓\nC) Both functions do the same thing\nD) print() is for numbers, input() is for text\n\n---",
      "lessonSlug": "introduction-to-python-q1-vocabularyconcepts-what-is-python-and-why-is-it-considered-a-high-level-programming-language-a-python-is-a-web-browser-that-makes-coding-easier-b-python-is-a-programming-language-with-simple-syntax-that-requires-fewer-lines-of-code-to-complete-tasks-c-python-is-a-database-system-for-storing-information-d-python-is-a-type-of-computer-hardware-q2-code-understanding-what-will-be-displayed-if-a-user-enters-reading-for-this-code-python-name-inputwhat-is-your-favorite-hobby-printi-love-name-too-a-what-is-your-favorite-hobby-b-i-love-reading-too-c-i-love-reading-too-d-reading-q3-problem-solving-which-code-correctly-asks-for-a-users-age-and-displays-a-personalized-message-a-age-inputwhat-is-your-age-printyou-are-age-years-old-thats-awesome-b-printwhat-is-your-age-age-input-printage-c-age-printwhat-is-your-age-inputyou-are-awesome-d-inputage-printyou-are-old-q4-application-what-functions-would-a-data-scientist-use-to-gather-and-display-user-information-a-print-only-b-input-only-c-input-to-gather-information-and-print-to-display-results-d-neither-function-is-useful-for-data-collection-q5-reflectionmeta-learning-what-is-the-main-difference-between-print-and-input-functions-a-print-gets-information-from-users-input-displays-information-b-print-displays-information-to-users-input-gets-information-from-users-c-both-functions-do-the-same-thing-d-print-is-for-numbers-input-is-for-text",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l1-q1",
          "globalId": "exit-ticket-0351",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is Python and why is it considered a \"high-level programming language\"?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PY_TOOL_CATEGORY_CONFUSION",
            "HARDWARE_SOFTWARE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Python is a web browser that makes coding easier",
              "isCorrect": false,
              "misconceptionId": "PY_TOOL_CATEGORY_CONFUSION",
              "feedback": {
                "short": "Not quite! Python isn't a web browser.",
                "detailed": "A web browser (like Chrome or Firefox) displays websites. Python is a programming language—a tool for writing instructions that computers can execute. Think of it like this: browsers consume content, Python creates it.",
                "socraticHint": "What do you use Chrome or Safari for? How is that different from writing code?"
              }
            },
            {
              "key": "B",
              "text": "Python is a programming language with simple syntax that requires fewer lines of code to complete tasks",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Python is a high-level language known for readable, concise code.",
                "detailed": "Python is called 'high-level' because it abstracts away complex hardware details, letting you focus on problem-solving. Its simple syntax means tasks that take 10 lines in other languages might only need 3 in Python."
              }
            },
            {
              "key": "C",
              "text": "Python is a database system for storing information",
              "isCorrect": false,
              "misconceptionId": "PY_TOOL_CATEGORY_CONFUSION",
              "feedback": {
                "short": "Not quite! Python isn't a database.",
                "detailed": "Databases (like MySQL or PostgreSQL) store and organize data. Python is a programming language that can connect to and query databases, but it's not a database itself. Python is the tool; the database is where data lives.",
                "socraticHint": "If Python stores the data, what would you use to write the instructions that retrieve it?"
              }
            },
            {
              "key": "D",
              "text": "Python is a type of computer hardware",
              "isCorrect": false,
              "misconceptionId": "HARDWARE_SOFTWARE_CONFUSION",
              "feedback": {
                "short": "Not quite! Python is software, not hardware.",
                "detailed": "Hardware refers to physical components you can touch—like keyboards, monitors, and CPUs. Python is software: it's a set of instructions and rules that run on hardware. You can't hold Python in your hand!",
                "socraticHint": "Can you touch or hold Python? What's the difference between things you can physically touch and programs you run?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Python is a programming language with simple syntax that requires fewer lines of code to complete tasks",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "python",
              "programming-language",
              "high-level"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-19"
          }
        },
        {
          "questionId": "ai-1-l1-q2",
          "globalId": "exit-ticket-0352",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What will be displayed if a user enters \"reading\" for this code?",
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "name = input(\"What is your favorite hobby? \")\nprint(\"I love\", name, \"too!\")",
          "misconceptionTargets": [
            "FUNC_RETURN_PRINT",
            "PRINT_OUTPUT_FORMAT"
          ],
          "options": [
            {
              "key": "A",
              "text": "What is your favorite hobby?",
              "isCorrect": false,
              "misconceptionId": "INPUT_PROMPT_VS_OUTPUT",
              "feedback": {
                "short": "Not quite! That's the prompt, not the output.",
                "detailed": "The text in input() is a prompt—it asks the user a question. The print() statement produces the actual output. Think: input() asks, print() shows.",
                "socraticHint": "Where does the program display its result to the user?"
              }
            },
            {
              "key": "B",
              "text": "I love reading too!",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! The print() function joins the strings with spaces.",
                "detailed": "When you use commas in print(), Python automatically adds spaces between each item. So \"I love\", name, \"too!\" becomes \"I love reading too!\" with spaces."
              }
            },
            {
              "key": "C",
              "text": "I love, reading, too!",
              "isCorrect": false,
              "misconceptionId": "PRINT_COMMA_LITERAL",
              "feedback": {
                "short": "Not quite! Commas in print() separate values, not add literal commas.",
                "detailed": "The commas between items in print() tell Python to print each item separately with a space. They don't appear in the output. To print actual commas, you'd include them in the strings.",
                "socraticHint": "What character does Python use to separate printed items?"
              }
            },
            {
              "key": "D",
              "text": "reading",
              "isCorrect": false,
              "misconceptionId": "PRINT_PARTIAL_OUTPUT",
              "feedback": {
                "short": "Not quite! This is only the variable value, not the full output.",
                "detailed": "The print() statement includes three parts: \"I love\", name, and \"too!\". Only showing 'name' ignores the other strings. Always trace through ALL parts of print().",
                "socraticHint": "How many items does the print() statement contain?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "I love reading too!",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "python",
              "print",
              "input",
              "string-output"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-19"
          }
        },
        {
          "questionId": "ai-1-l1-q3",
          "globalId": "exit-ticket-0353",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "bebras",
          "prompt": "Which code correctly asks for a user's age and displays a personalized message?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PY_INPUT_PROMPT_SEPARATION",
            "FUNC_RETURN_PRINT",
            "VAR_UNINITIALIZED"
          ],
          "options": [
            {
              "key": "A",
              "text": "age = input(\"What is your age? \"); print(\"You are\", age, \"years old! That's awesome!\")",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This code properly uses input() to gather data and print() to display a personalized message.",
                "detailed": "The pattern is: (1) input() asks the question AND stores the answer, (2) print() uses that stored value in a friendly message. The prompt is inside input(), so the user sees it when asked for input."
              }
            },
            {
              "key": "B",
              "text": "print(\"What is your age? \"); age = input(); print(age)",
              "isCorrect": false,
              "misconceptionId": "PY_INPUT_PROMPT_SEPARATION",
              "feedback": {
                "short": "Close! But this separates the prompt from the input.",
                "detailed": "While this technically works, it's not the best approach. Using print() for the question and input() separately means the question appears, then the cursor waits on a new line. The better pattern puts the prompt INSIDE input() so the user types on the same line as the question.",
                "socraticHint": "Where does the user's cursor appear when they need to type their answer?"
              }
            },
            {
              "key": "C",
              "text": "age = print(\"What is your age? \"); input(\"You are awesome!\")",
              "isCorrect": false,
              "misconceptionId": "FUNC_RETURN_PRINT",
              "feedback": {
                "short": "Not quite! You can't store a print() result.",
                "detailed": "print() displays text but returns None—it doesn't capture user input. Assigning print() to a variable gives you None, not the user's age. To get user input, you need input(). Also, input(\"You are awesome!\") asks a question but throws away the answer!",
                "socraticHint": "What does print() give back after it runs? What does input() give back?"
              }
            },
            {
              "key": "D",
              "text": "input(age); print(\"You are old!\")",
              "isCorrect": false,
              "misconceptionId": "VAR_UNINITIALIZED",
              "feedback": {
                "short": "Not quite! This code has a variable error and an unhelpful message.",
                "detailed": "Two problems: (1) 'age' isn't defined yet, so input(age) causes an error—you need a string prompt like \"What is your age?\". (2) The print message doesn't use the age variable at all, so it's not personalized. A good message should include the user's actual input.",
                "socraticHint": "What value does 'age' have before the user types anything? How can you use someone's answer in your response to them?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "age = input(\"What is your age? \"); print(\"You are\", age, \"years old! That's awesome!\")",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "python",
              "input",
              "print",
              "user-interaction"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-19"
          }
        },
        {
          "questionId": "ai-1-l1-q4",
          "globalId": "exit-ticket-0354",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "blockmodel",
          "prompt": "What functions would a data scientist use to gather and display user information?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "FUNC_UNIDIRECTIONAL_IO",
            "FUNC_PURPOSE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "print() only",
              "isCorrect": false,
              "misconceptionId": "FUNC_UNIDIRECTIONAL_IO",
              "feedback": {
                "short": "Not quite! print() only displays—it can't gather information.",
                "detailed": "print() is one-way: it sends information TO the user. To gather information FROM the user, you need input(). A data scientist needs both: input() to collect data and print() to show results. Think of it as a conversation—you need to both listen AND speak.",
                "socraticHint": "If you only have print(), how would you ask someone their name and capture their response?"
              }
            },
            {
              "key": "B",
              "text": "input() only",
              "isCorrect": false,
              "misconceptionId": "FUNC_UNIDIRECTIONAL_IO",
              "feedback": {
                "short": "Not quite! input() gathers data but can't display results.",
                "detailed": "input() collects information from users, but how would you show them the analysis results? You need print() to display findings. Data science is about collecting data AND communicating insights—both directions of the conversation matter.",
                "socraticHint": "After analyzing someone's data, how would you show them what you discovered?"
              }
            },
            {
              "key": "C",
              "text": "input() to gather information and print() to display results",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Data scientists need both functions for a complete workflow.",
                "detailed": "The data science workflow involves: (1) Gathering data with input() or file reading, (2) Processing/analyzing the data, (3) Displaying results with print() or visualizations. These two functions represent the fundamental input/output pattern in programming."
              }
            },
            {
              "key": "D",
              "text": "Neither function is useful for data collection",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! These are foundational tools every data scientist uses.",
                "detailed": "While data scientists use more advanced tools too (like pandas for files, matplotlib for graphs), print() and input() are fundamental. Every program needs ways to get data in and show results out. Even complex data pipelines start with these basic concepts.",
                "socraticHint": "When a data scientist writes their first Python program, what's the simplest way to test if their code works?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "input() to gather information and print() to display results",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "python",
              "data-science",
              "input-output",
              "workflow"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-19"
          }
        },
        {
          "questionId": "ai-1-l1-q5",
          "globalId": "exit-ticket-0355",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "blockmodel",
          "prompt": "What is the main difference between print() and input() functions?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PY_INPUT_OUTPUT_REVERSAL",
            "FUNC_EQUIVALENCE",
            "TYPE_FUNCTION_RESTRICTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "print() gets information from users, input() displays information",
              "isCorrect": false,
              "misconceptionId": "PY_INPUT_OUTPUT_REVERSAL",
              "feedback": {
                "short": "Not quite! You've got them backwards.",
                "detailed": "This swaps the functions' roles. Remember: INPUT brings data IN from the user (like typing your name). PRINT sends data OUT to the screen (like showing a message). The names hint at their purpose: input takes input, print prints output.",
                "socraticHint": "When you type your name into a program, which direction is the data flowing—toward you or toward the computer?"
              }
            },
            {
              "key": "B",
              "text": "print() displays information to users, input() gets information from users",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! print() outputs TO users, input() takes FROM users.",
                "detailed": "These two functions handle opposite directions of communication: print() sends information OUT to the screen (computer → user), while input() brings information IN from the keyboard (user → computer). Together, they create two-way interaction."
              }
            },
            {
              "key": "C",
              "text": "Both functions do the same thing",
              "isCorrect": false,
              "misconceptionId": "FUNC_EQUIVALENCE",
              "feedback": {
                "short": "Not quite! They have opposite purposes.",
                "detailed": "These functions do opposite things: print() shows information (output), input() collects information (input). If they were the same, we'd only need one function! Think of a conversation: speaking and listening are different actions, but both are needed.",
                "socraticHint": "If both functions did the same thing, why would Python have two of them?"
              }
            },
            {
              "key": "D",
              "text": "print() is for numbers, input() is for text",
              "isCorrect": false,
              "misconceptionId": "TYPE_FUNCTION_RESTRICTION",
              "feedback": {
                "short": "Not quite! Both functions work with any data type.",
                "detailed": "There's no type restriction. print() can display numbers, text, or anything: print(42), print(\"hello\"), print(3.14). Similarly, input() can receive any characters the user types. The difference isn't WHAT data they handle, but WHICH DIRECTION the data flows.",
                "socraticHint": "Can you print a sentence? Can you print a number? What about with input()—could someone type numbers?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "print() displays information to users, input() gets information from users",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "python",
              "input",
              "print",
              "comparison"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-19"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-2",
      "lessonNumber": 2,
      "lessonTitle": "Jupyter Notebook\n\n### Q1: Vocabulary/Concepts\nWhat are the two main types of cells in Jupyter Notebook?\nA) Data cells and text cells\nB) Code cells and markdown cells ✓\nC) Input cells and output cells\nD) Python cells and HTML cells\n\n### Q2: Code Understanding\nIf you run Cell 1, then Cell 3, then Cell 2 in this order, what happens?\n```python\n# Cell 1: x = 10\n# Cell 2: y = x + 5\n# Cell 3: print(y)\n```\nA) Everything works perfectly\nB) Cell 3 gives an error because y is not defined yet ✓\nC) Cell 1 gives an error\nD) All cells run without any output\n\n### Q3: Problem-Solving\nWhat is the correct structure for a data analysis project in Jupyter Notebook?\nA) All code in one cell with no explanations\nB) Markdown headers for sections, code cells for analysis, explanations throughout ✓\nC) Only code cells, no text needed\nD) Only markdown cells, no code needed\n\n### Q4: Application\nHow does Jupyter Notebook help research teams create comprehensive reports?\nA) It only stores code\nB) It mixes code, output, and documentation in one place for complete analysis ✓\nC) It automatically writes research papers\nD) It only creates graphs\n\n### Q5: Reflection/Meta-learning\nWhat is the main advantage of Jupyter Notebook over regular text editors for coding?\nA) It's faster to type in\nB) It has better colors\nC) It allows interactive testing and visual feedback with mixed documentation ✓\nD) It automatically fixes all errors\n\n---",
      "lessonSlug": "jupyter-notebook-q1-vocabularyconcepts-what-are-the-two-main-types-of-cells-in-jupyter-notebook-a-data-cells-and-text-cells-b-code-cells-and-markdown-cells-c-input-cells-and-output-cells-d-python-cells-and-html-cells-q2-code-understanding-if-you-run-cell-1-then-cell-3-then-cell-2-in-this-order-what-happens-python-cell-1-x-10-cell-2-y-x-5-cell-3-printy-a-everything-works-perfectly-b-cell-3-gives-an-error-because-y-is-not-defined-yet-c-cell-1-gives-an-error-d-all-cells-run-without-any-output-q3-problem-solving-what-is-the-correct-structure-for-a-data-analysis-project-in-jupyter-notebook-a-all-code-in-one-cell-with-no-explanations-b-markdown-headers-for-sections-code-cells-for-analysis-explanations-throughout-c-only-code-cells-no-text-needed-d-only-markdown-cells-no-code-needed-q4-application-how-does-jupyter-notebook-help-research-teams-create-comprehensive-reports-a-it-only-stores-code-b-it-mixes-code-output-and-documentation-in-one-place-for-complete-analysis-c-it-automatically-writes-research-papers-d-it-only-creates-graphs-q5-reflectionmeta-learning-what-is-the-main-advantage-of-jupyter-notebook-over-regular-text-editors-for-coding-a-its-faster-to-type-in-b-it-has-better-colors-c-it-allows-interactive-testing-and-visual-feedback-with-mixed-documentation-d-it-automatically-fixes-all-errors",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l2-q1",
          "globalId": "exit-ticket-0356",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What are the two main types of cells in Jupyter Notebook?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "JUPYTER_TERM_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Data cells and text cells",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_TERM_CONFUSION",
              "feedback": {
                "short": "Not quite! Jupyter uses specific cell type names.",
                "detailed": "Jupyter Notebook has two main cell types: 'code cells' (for Python) and 'markdown cells' (for formatted text). 'Data cells' isn't a Jupyter term—you might be thinking of how the cells hold data.",
                "socraticHint": "What do you write in each type of cell?"
              }
            },
            {
              "key": "B",
              "text": "Code cells and markdown cells",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Code cells run Python, markdown cells display formatted text.",
                "detailed": "Jupyter Notebooks use code cells to write and execute Python code, and markdown cells to write explanations, headers, and documentation using Markdown formatting."
              }
            },
            {
              "key": "C",
              "text": "Input cells and output cells",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_TERM_CONFUSION",
              "feedback": {
                "short": "Not quite! Those aren't the official cell type names.",
                "detailed": "While cells do have input (what you type) and output (what appears), the cell TYPES are 'code' and 'markdown'. Output isn't a cell type—it's what appears after running a code cell.",
                "socraticHint": "If 'output' were a cell type, how would you create one?"
              }
            },
            {
              "key": "D",
              "text": "Python cells and HTML cells",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_TERM_CONFUSION",
              "feedback": {
                "short": "Not quite! The cell types aren't named after languages.",
                "detailed": "Jupyter uses 'code cells' (not 'Python cells') because notebooks can run different languages. Markdown cells CAN render HTML, but they're called 'markdown cells' not 'HTML cells'.",
                "socraticHint": "What if you wanted to use Jupyter with R instead of Python?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Code cells and markdown cells",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l2-q2",
          "globalId": "exit-ticket-0357",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "If you run Cell 1, then Cell 3, then Cell 2 in this order, what happens?",
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "# Cell 1: x = 10\n# Cell 2: y = x + 5\n# Cell 3: print(y)",
          "misconceptionTargets": [
            "JUPYTER_CELL_ORDER",
            "VAR_UNINITIALIZED"
          ],
          "options": [
            {
              "key": "A",
              "text": "Everything works perfectly",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_CELL_ORDER",
              "feedback": {
                "short": "Not quite! Cell execution order matters in Jupyter.",
                "detailed": "Running Cell 1 → Cell 3 → Cell 2 causes an error. When Cell 3 runs, it tries to print 'y', but 'y' is only created in Cell 2, which hasn't run yet! Order matters.",
                "socraticHint": "What value does 'y' have when Cell 3 tries to print it?"
              }
            },
            {
              "key": "B",
              "text": "Cell 3 gives an error because y is not defined yet",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Cell 3 tries to use 'y' before Cell 2 creates it.",
                "detailed": "Since you run cells in order 1 → 3 → 2, when Cell 3 executes, 'y' doesn't exist yet. Python raises a NameError: 'y' is not defined. This is why cell execution order matters!"
              }
            },
            {
              "key": "C",
              "text": "Cell 1 gives an error",
              "isCorrect": false,
              "misconceptionId": "VAR_UNINITIALIZED",
              "feedback": {
                "short": "Not quite! Cell 1 runs just fine.",
                "detailed": "Cell 1 only does 'x = 10', which creates a new variable and assigns 10 to it. There's no error here—the problem comes later when Cell 3 tries to use a variable that doesn't exist yet.",
                "socraticHint": "What does Cell 1 need to run successfully?"
              }
            },
            {
              "key": "D",
              "text": "All cells run without any output",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_CELL_ORDER",
              "feedback": {
                "short": "Not quite! Cell 3 will produce output—an error message.",
                "detailed": "Cell 3 contains print(y), which will definitely try to produce output. Since 'y' doesn't exist when Cell 3 runs, the output is an error: NameError: name 'y' is not defined.",
                "socraticHint": "What happens when Python can't find a variable you're trying to use?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Cell 3 gives an error because y is not defined yet",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "python"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l2-q3",
          "globalId": "exit-ticket-0358",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "What is the correct structure for a data analysis project in Jupyter Notebook?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "JUPYTER_CELL_STATE",
            "JUPYTER_TERM_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "All code in one cell with no explanations",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_CELL_STATE",
              "feedback": {
                "short": "Not quite! Notebooks are designed for modular, documented analysis.",
                "detailed": "Putting all code in one cell defeats the purpose of Jupyter! Notebooks excel at breaking analysis into logical sections with explanations. This makes your work reproducible and understandable by others (including future you).",
                "socraticHint": "Why might a research team want to see your reasoning alongside the code?"
              }
            },
            {
              "key": "B",
              "text": "Markdown headers for sections, code cells for analysis, explanations throughout",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This structure makes notebooks powerful for data analysis.",
                "detailed": "A well-structured notebook combines markdown headers for organization, code cells for executable analysis, and explanations throughout. This 'literate programming' approach makes your analysis reproducible and shareable."
              }
            },
            {
              "key": "C",
              "text": "Only code cells, no text needed",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_TERM_CONFUSION",
              "feedback": {
                "short": "Not quite! Markdown cells are essential for documentation.",
                "detailed": "Code alone doesn't tell the full story. Markdown cells add context: why you're doing each analysis, what the results mean, and how to interpret outputs. Without them, your notebook is just a script.",
                "socraticHint": "If someone reads your notebook in 6 months, how would they understand your reasoning?"
              }
            },
            {
              "key": "D",
              "text": "Only markdown cells, no code needed",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_TERM_CONFUSION",
              "feedback": {
                "short": "Not quite! Code cells are what make notebooks executable.",
                "detailed": "Without code cells, you'd just have a document—not a notebook. The power of Jupyter is that code runs right next to your explanations, producing outputs that update when you change the code.",
                "socraticHint": "What makes Jupyter different from a regular text document?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Markdown headers for sections, code cells for analysis, explanations throughout",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l2-q4",
          "globalId": "exit-ticket-0359",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "How does Jupyter Notebook help research teams create comprehensive reports?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "JUPYTER_TERM_CONFUSION",
            "FUNC_PURPOSE_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "It only stores code",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_TERM_CONFUSION",
              "feedback": {
                "short": "Not quite! Jupyter does much more than store code.",
                "detailed": "While Jupyter does store code, that's just one part. It also stores outputs (charts, tables, text results), markdown documentation, and everything together in a shareable format. That's what makes it powerful for research.",
                "socraticHint": "What else besides code might a research team want to include in their report?"
              }
            },
            {
              "key": "B",
              "text": "It mixes code, output, and documentation in one place for complete analysis",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This integration is Jupyter's superpower for research.",
                "detailed": "Jupyter combines executable code, visible outputs, and narrative documentation in a single document. This 'literate programming' approach means research teams can share their entire analysis pipeline, not just the final results."
              }
            },
            {
              "key": "C",
              "text": "It automatically writes research papers",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Jupyter is a tool, not an AI writer.",
                "detailed": "Jupyter doesn't write content for you—it provides a structured environment where YOU write code, run analysis, and document your findings. The writing and analysis still require human expertise and judgment.",
                "socraticHint": "What's the difference between a tool that helps you organize work versus one that does the work for you?"
              }
            },
            {
              "key": "D",
              "text": "It only creates graphs",
              "isCorrect": false,
              "misconceptionId": "JUPYTER_TERM_CONFUSION",
              "feedback": {
                "short": "Not quite! Graphs are just one output type in Jupyter.",
                "detailed": "While Jupyter displays graphs beautifully, it can output anything Python can produce: tables, statistics, text, images, even interactive widgets. Plus, it stores your code and explanations alongside those outputs.",
                "socraticHint": "What other types of analysis results might you want to show in a report?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "It mixes code, output, and documentation in one place for complete analysis",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l2-q5",
          "globalId": "exit-ticket-0360",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "What is the main advantage of Jupyter Notebook over regular text editors for coding?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "JUPYTER_TERM_CONFUSION",
            "FUNC_PURPOSE_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "It's faster to type in",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Typing speed isn't Jupyter's main advantage.",
                "detailed": "Regular text editors are often faster for pure typing. Jupyter's advantage is what happens AFTER you type: you can run code, see outputs, and add explanations—all in one place. It's about the workflow, not typing speed.",
                "socraticHint": "What can you do in Jupyter that you can't do in a regular text file?"
              }
            },
            {
              "key": "B",
              "text": "It has better colors",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Syntax highlighting exists in most code editors.",
                "detailed": "While Jupyter does have syntax highlighting (colors for code), so do most modern code editors like VS Code or Sublime Text. The real difference is that Jupyter shows your code OUTPUT right below the code, creating an interactive workflow.",
                "socraticHint": "If you run code in a text editor, where do you see the results?"
              }
            },
            {
              "key": "C",
              "text": "It allows interactive testing and visual feedback with mixed documentation",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This interactive, integrated approach is Jupyter's superpower.",
                "detailed": "Jupyter lets you write code, run it immediately, see results inline, and add rich documentation—all in the same document. This 'notebook' paradigm is perfect for data exploration and analysis where you need to experiment and explain."
              }
            },
            {
              "key": "D",
              "text": "It automatically fixes all errors",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Jupyter doesn't automatically fix errors.",
                "detailed": "No tool automatically fixes all errors—that's still your job as a programmer! Jupyter shows you error messages when code fails, but you need to read and understand them to fix the problem yourself.",
                "socraticHint": "What would happen if you ran code with a typo in Jupyter?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "It allows interactive testing and visual feedback with mixed documentation",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-3",
      "lessonNumber": 3,
      "lessonTitle": "Variables & Operators\n\n### Q1: Vocabulary/Concepts\nWhat does the % (modulus) operator do?\nA) Calculates percentage\nB) Returns the remainder after division ✓\nC) Multiplies two numbers\nD) Divides two numbers\n\n### Q2: Code Understanding\nWhat is the output of `print(15 // 4)`?\nA) 3.75\nB) 3 ✓\nC) 4\nD) 15\n\n### Q3: Problem-Solving\nWhich code correctly calculates the area of a rectangle from user input?\nA) area = length + width\nB) length = input(); width = input(); area = length * width\nC) length = float(input(\"Enter length: \")); width = float(input(\"Enter width: \")); area = length * width ✓\nD) area = input(\"Enter area: \")\n\n### Q4: Application\nHow would you calculate a total price with 8.5% tax on a $50 item?\nA) total = 50 + 8.5\nB) total = 50 * 1.085 ✓\nC) total = 50 / 8.5\nD) total = 50 - 8.5\n\n### Q5: Reflection/Meta-learning\nWhen should you use floor division (//) instead of regular division (/)?\nA) When you need decimal results\nB) When you need whole number results ✓\nC) When working with text\nD) When calculating percentages\n\n---",
      "lessonSlug": "variables-operators-q1-vocabularyconcepts-what-does-the-modulus-operator-do-a-calculates-percentage-b-returns-the-remainder-after-division-c-multiplies-two-numbers-d-divides-two-numbers-q2-code-understanding-what-is-the-output-of-print15-4-a-375-b-3-c-4-d-15-q3-problem-solving-which-code-correctly-calculates-the-area-of-a-rectangle-from-user-input-a-area-length-width-b-length-input-width-input-area-length-width-c-length-floatinputenter-length-width-floatinputenter-width-area-length-width-d-area-inputenter-area-q4-application-how-would-you-calculate-a-total-price-with-85-tax-on-a-50-item-a-total-50-85-b-total-50-1085-c-total-50-85-d-total-50-85-q5-reflectionmeta-learning-when-should-you-use-floor-division-instead-of-regular-division-a-when-you-need-decimal-results-b-when-you-need-whole-number-results-c-when-working-with-text-d-when-calculating-percentages",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l3-q1",
          "globalId": "exit-ticket-0361",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "What does the % (modulus) operator do?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "OP_MODULUS_PERCENT_CONFUSION",
            "OP_OPERATOR_SYMBOL_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Calculates percentage",
              "isCorrect": false,
              "misconceptionId": "OP_MODULUS_PERCENT_CONFUSION",
              "feedback": {
                "short": "Not quite! The % symbol in Python doesn't mean 'percent.'",
                "detailed": "In everyday life, % means percentage, but in Python, % is the MODULUS operator. It returns the remainder after division: 10 % 3 = 1 (because 10 ÷ 3 = 3 remainder 1). To calculate a percentage, you'd use regular multiplication: price * 0.10 for 10%.",
                "socraticHint": "What is the remainder when you divide 10 by 3?"
              }
            },
            {
              "key": "B",
              "text": "Returns the remainder after division",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Modulus gives you the remainder.",
                "detailed": "The modulus operator (%) returns what's left over after division. For example, 10 % 3 = 1 because 3 goes into 10 three times (9) with 1 remaining. It's useful for checking even/odd numbers, cycling through values, and more."
              }
            },
            {
              "key": "C",
              "text": "Multiplies two numbers",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Multiplication uses the * symbol.",
                "detailed": "In Python, multiplication uses the asterisk (*), not the percent sign (%). So 5 * 3 = 15 for multiplication, while 5 % 3 = 2 for the remainder after division.",
                "socraticHint": "What symbol do you use on a calculator for multiplication?"
              }
            },
            {
              "key": "D",
              "text": "Divides two numbers",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Division uses the / symbol.",
                "detailed": "Regular division uses the forward slash (/), not the percent sign. So 10 / 3 = 3.333... for division, while 10 % 3 = 1 for the remainder. There's also floor division (//) that gives whole number results.",
                "socraticHint": "What's the difference between 10 / 3 and 10 % 3?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Returns the remainder after division",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l3-q2",
          "globalId": "exit-ticket-0362",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "What is the output of `print(15 // 4)`?",
          "questionArchetype": "trace",
          "misconceptionTargets": [
            "OP_FLOOR_DIVISION_ROUNDING",
            "OP_OPERATOR_SYMBOL_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "3.75",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! That would be regular division (/).",
                "detailed": "3.75 is correct for 15 / 4 (regular division), but the question uses // (floor division). Floor division discards the decimal part and returns a whole number. So 15 // 4 = 3, not 3.75.",
                "socraticHint": "What's the difference between / and // in Python?"
              }
            },
            {
              "key": "B",
              "text": "3",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Floor division returns the whole number part.",
                "detailed": "Floor division (//) divides and then rounds DOWN to the nearest integer. 15 ÷ 4 = 3.75, and the floor of 3.75 is 3. This is useful when you need whole number results, like counting how many complete groups you can make."
              }
            },
            {
              "key": "C",
              "text": "4",
              "isCorrect": false,
              "misconceptionId": "OP_FLOOR_DIVISION_ROUNDING",
              "feedback": {
                "short": "Not quite! Floor division rounds DOWN, not to the nearest.",
                "detailed": "You might be thinking of normal rounding (3.75 rounds to 4), but floor division always rounds DOWN. So 15 // 4 = 3, not 4. The 'floor' in floor division means the result 'falls' to the lower integer.",
                "socraticHint": "What does 'floor' mean in math?"
              }
            },
            {
              "key": "D",
              "text": "15",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Floor division still performs division.",
                "detailed": "15 would only be the result if no division happened at all. Floor division (//) first divides 15 by 4 (getting 3.75), then takes the floor (getting 3). The second number (4) is the divisor, not ignored.",
                "socraticHint": "What happens when you divide 15 by 4?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "3",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l3-q3",
          "globalId": "exit-ticket-0363",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Which code correctly calculates the area of a rectangle from user input?",
          "questionArchetype": "blockmodel",
          "misconceptionTargets": [
            "OP_OPERATOR_SYMBOL_CONFUSION",
            "TYPE_INPUT_STRING_RETURN"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "area = length + width",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Addition (+) doesn't calculate area.",
                "detailed": "The area of a rectangle is length × width (multiplication), not length + width (addition). Adding length and width gives you part of the perimeter, not the area. Remember: area = length * width.",
                "socraticHint": "What's the formula for the area of a rectangle?"
              }
            },
            {
              "key": "B",
              "text": "length = input(); width = input(); area = length * width",
              "isCorrect": false,
              "misconceptionId": "TYPE_INPUT_STRING_RETURN",
              "feedback": {
                "short": "Not quite! This will cause an error because input() returns strings.",
                "detailed": "The input() function always returns a string, even if the user types a number. So length and width would be strings like '5' and '3', and you can't multiply strings. You need to convert: float(input(...)) or int(input(...)).",
                "socraticHint": "What type of value does input() return?"
              }
            },
            {
              "key": "C",
              "text": "length = float(input(\"Enter length: \")); width = float(input(\"Enter width: \")); area = length * width",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This properly converts input and calculates area.",
                "detailed": "This code: 1) prompts the user for length and width, 2) converts the string inputs to floats (numbers with decimals), and 3) multiplies them to get the area. Using float() instead of int() allows for decimal measurements like 5.5."
              }
            },
            {
              "key": "D",
              "text": "area = input(\"Enter area: \")",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! This asks for the area instead of calculating it.",
                "detailed": "This code asks the user to type in the area themselves—it doesn't calculate anything! The goal is to get length and width inputs, then compute the area using the formula: area = length * width.",
                "socraticHint": "What values do you need from the user to calculate area?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "length = float(input(\"Enter length: \")); width = float(input(\"Enter width: \")); area = length * width",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l3-q4",
          "globalId": "exit-ticket-0364",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "How would you calculate a total price with 8.5% tax on a $50 item?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "FORMULA_PERCENTAGE_CALCULATION",
            "OP_OPERATOR_SYMBOL_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "total = 50 + 8.5",
              "isCorrect": false,
              "misconceptionId": "FORMULA_PERCENTAGE_CALCULATION",
              "feedback": {
                "short": "Not quite! You can't just add the percentage number.",
                "detailed": "50 + 8.5 = 58.50, but that's adding $8.50, not 8.5%. The 8.5 in '8.5%' means '8.5 per hundred' or 0.085 as a decimal. For 8.5% tax: tax amount = 50 × 0.085 = $4.25, so total = $54.25.",
                "socraticHint": "What is 8.5% of $50?"
              }
            },
            {
              "key": "B",
              "text": "total = 50 * 1.085",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Multiplying by 1.085 adds 8.5% in one step.",
                "detailed": "50 × 1.085 = $54.25. This works because 1.085 = 1 + 0.085 (the original price plus 8.5%). This is a shortcut: instead of calculating tax separately (50 × 0.085 = $4.25) and adding it, you multiply by 1.085 directly."
              }
            },
            {
              "key": "C",
              "text": "total = 50 / 8.5",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Division doesn't help calculate percentage tax.",
                "detailed": "50 / 8.5 ≈ 5.88, which makes no sense for adding tax. To add a percentage, you multiply (scale up), not divide. The formula is: total = price × (1 + percent/100) = 50 × 1.085.",
                "socraticHint": "Would adding tax make the total higher or lower than $50?"
              }
            },
            {
              "key": "D",
              "text": "total = 50 - 8.5",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Subtraction would reduce the price, not add tax.",
                "detailed": "50 - 8.5 = 41.50, which is less than the original $50. Adding tax should increase the total, not decrease it. You'd use subtraction for a discount, not for tax.",
                "socraticHint": "Does paying tax increase or decrease what you pay?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "total = 50 * 1.085",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l3-q5",
          "globalId": "exit-ticket-0365",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "When should you use floor division (//) instead of regular division (/)?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "OP_FLOOR_DIVISION_ROUNDING",
            "OP_OPERATOR_SYMBOL_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "When you need decimal results",
              "isCorrect": false,
              "misconceptionId": "OP_FLOOR_DIVISION_ROUNDING",
              "feedback": {
                "short": "Not quite! Floor division removes decimals.",
                "detailed": "Floor division (//) is the opposite of what you'd use for decimals. 15 // 4 = 3 (no decimals), while 15 / 4 = 3.75 (with decimals). Use regular division (/) when you need precise decimal results.",
                "socraticHint": "What does 'floor' mean in floor division?"
              }
            },
            {
              "key": "B",
              "text": "When you need whole number results",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Floor division gives whole numbers only.",
                "detailed": "Floor division (//) is perfect when you need integer results: counting how many complete groups fit (e.g., 15 // 4 = 3 complete groups), working with array indices, or calculating pages needed. It always rounds down to the nearest integer."
              }
            },
            {
              "key": "C",
              "text": "When working with text",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Division operators work with numbers, not text.",
                "detailed": "Both // and / are math operators that work with numbers. You can't divide text (strings) in Python. For text operations, you'd use string methods like split(), join(), or slicing.",
                "socraticHint": "What types of values can you divide?"
              }
            },
            {
              "key": "D",
              "text": "When calculating percentages",
              "isCorrect": false,
              "misconceptionId": "OP_MODULUS_PERCENT_CONFUSION",
              "feedback": {
                "short": "Not quite! Percentages use multiplication, not floor division.",
                "detailed": "To calculate a percentage, you multiply: 50 * 0.20 for 20% of 50. Floor division (//) is for getting whole numbers after division. The confusion might be that % looks like 'percent' but in Python it's the modulus operator.",
                "socraticHint": "How do you calculate 10% of a number?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "When you need whole number results",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-4",
      "lessonNumber": 4,
      "lessonTitle": "List\n\n### Q1: Vocabulary/Concepts\nWhat is the index of the first item in a Python list?\nA) 1\nB) 0 ✓\nC) -1\nD) First\n\n### Q2: Code Understanding\nWhat does `fruits[-1]` return for the list `fruits = [\"apple\", \"banana\", \"cherry\"]`?\nA) apple\nB) banana\nC) cherry ✓\nD) Error\n\n### Q3: Problem-Solving\nWhich method adds an item to the end of a list?\nA) insert()\nB) append() ✓\nC) add()\nD) extend()\n\n### Q4: Application\nHow would you find the average of scores in the list `scores = [85, 92, 78]`?\nA) sum(scores) / len(scores) ✓\nB) scores / 3\nC) average(scores)\nD) mean(scores)\n\n### Q5: Reflection/Meta-learning\nWhat's the difference between append() and insert() methods?\nA) No difference\nB) append() adds to end, insert() adds at specific position ✓\nC) insert() adds to end, append() adds at beginning\nD) append() is faster, insert() is slower\n\n---",
      "lessonSlug": "list-q1-vocabularyconcepts-what-is-the-index-of-the-first-item-in-a-python-list-a-1-b-0-c-1-d-first-q2-code-understanding-what-does-fruits-1-return-for-the-list-fruits-apple-banana-cherry-a-apple-b-banana-c-cherry-d-error-q3-problem-solving-which-method-adds-an-item-to-the-end-of-a-list-a-insert-b-append-c-add-d-extend-q4-application-how-would-you-find-the-average-of-scores-in-the-list-scores-85-92-78-a-sumscores-lenscores-b-scores-3-c-averagescores-d-meanscores-q5-reflectionmeta-learning-whats-the-difference-between-append-and-insert-methods-a-no-difference-b-append-adds-to-end-insert-adds-at-specific-position-c-insert-adds-to-end-append-adds-at-beginning-d-append-is-faster-insert-is-slower",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l4-q1",
          "globalId": "exit-ticket-0366",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "What is the index of the first item in a Python list?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "ARRAY_ONE_INDEX",
            "LIST_NEGATIVE_INDEX"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "1",
              "isCorrect": false,
              "misconceptionId": "ARRAY_ONE_INDEX",
              "feedback": {
                "short": "Not quite! Python counting starts at 0, not 1.",
                "detailed": "In Python (and most programming languages), lists are 'zero-indexed'. The first item is at position 0, second at position 1, and so on. So for `fruits = ['apple', 'banana']`, `fruits[0]` gives 'apple'.",
                "socraticHint": "If you have 3 items at positions 0, 1, 2—how many items is that?"
              }
            },
            {
              "key": "B",
              "text": "0",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Python uses zero-based indexing.",
                "detailed": "Python lists are zero-indexed, meaning the first item is at index 0. This is common across most programming languages and makes certain calculations (like finding item position) more elegant."
              }
            },
            {
              "key": "C",
              "text": "-1",
              "isCorrect": false,
              "misconceptionId": "LIST_NEGATIVE_INDEX",
              "feedback": {
                "short": "Not quite! -1 refers to the LAST item, not the first.",
                "detailed": "In Python, negative indices count from the end: -1 is the last item, -2 is second-to-last, etc. For `fruits = ['apple', 'banana', 'cherry']`, `fruits[-1]` gives 'cherry', not 'apple'.",
                "socraticHint": "If -1 is the last item, what index would the first item have?"
              }
            },
            {
              "key": "D",
              "text": "First",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Indices are numbers, not words.",
                "detailed": "Python uses numbers for list indices, not words like 'First' or 'Last'. The word 'first' would cause an error. Use the number 0 to access the first item: `list[0]`.",
                "socraticHint": "What type of value goes inside the square brackets?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "0",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l4-q2",
          "globalId": "exit-ticket-0367",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "What does `fruits[-1]` return for the list `fruits = [\"apple\", \"banana\", \"cherry\"]`?",
          "questionArchetype": "trace",
          "misconceptionTargets": [
            "LIST_NEGATIVE_INDEX",
            "ARRAY_ONE_INDEX"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "apple",
              "isCorrect": false,
              "misconceptionId": "ARRAY_ONE_INDEX",
              "feedback": {
                "short": "Not quite! 'apple' is the first item, not the last.",
                "detailed": "You might be confusing indices. `fruits[-1]` means 'go backwards 1 from the end', which gives the last item. 'apple' is at index 0 (the first position), accessed via `fruits[0]`.",
                "socraticHint": "If we count backwards from the end, where does -1 land?"
              }
            },
            {
              "key": "B",
              "text": "banana",
              "isCorrect": false,
              "misconceptionId": "LIST_NEGATIVE_INDEX",
              "feedback": {
                "short": "Not quite! 'banana' is the middle item.",
                "detailed": "With `fruits[-1]`, you're accessing the LAST item, not the middle. 'banana' is at index 1 (or -2 counting from the end). The -1 index specifically gives you the final element.",
                "socraticHint": "What index would give you 'banana'?"
              }
            },
            {
              "key": "C",
              "text": "cherry",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! -1 gives you the last item.",
                "detailed": "In Python, negative indices count backwards from the end. `list[-1]` is always the last item, `list[-2]` is second-to-last, and so on. This is a convenient shorthand for `list[len(list)-1]`."
              }
            },
            {
              "key": "D",
              "text": "Error",
              "isCorrect": false,
              "misconceptionId": "LIST_NEGATIVE_INDEX",
              "feedback": {
                "short": "Not quite! Negative indices are valid in Python.",
                "detailed": "Unlike some other languages, Python supports negative indexing. It's a feature, not a bug! `-1` means 'last item', `-2` means 'second-to-last', etc. It only causes an error if the negative index goes beyond the list length.",
                "socraticHint": "When would a negative index cause an error?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "cherry",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l4-q3",
          "globalId": "exit-ticket-0368",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Which method adds an item to the end of a list?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "LIST_METHOD_NONEXISTENT",
            "LIST_EXTEND_VS_APPEND"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "insert()",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! insert() adds at a specific position, not the end.",
                "detailed": "`insert()` requires TWO arguments: position and value. For example, `list.insert(0, 'x')` adds 'x' at the beginning. To add to the END specifically, use `append()` which only needs the value.",
                "socraticHint": "What extra information does insert() need that append() doesn't?"
              }
            },
            {
              "key": "B",
              "text": "append()",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! append() adds one item to the end.",
                "detailed": "`append()` is the go-to method for adding a single item to the end of a list. It's simple: `fruits.append('mango')` puts 'mango' after all existing items. Fast and efficient!"
              }
            },
            {
              "key": "C",
              "text": "add()",
              "isCorrect": false,
              "misconceptionId": "LIST_METHOD_NONEXISTENT",
              "feedback": {
                "short": "Not quite! Python lists don't have an add() method.",
                "detailed": "Python lists use `append()`, not `add()`. The `add()` method exists for sets, not lists. This is a common confusion when learning Python. Remember: lists → append(), sets → add().",
                "socraticHint": "What data structure in Python does use add()?"
              }
            },
            {
              "key": "D",
              "text": "extend()",
              "isCorrect": false,
              "misconceptionId": "LIST_EXTEND_VS_APPEND",
              "feedback": {
                "short": "Not quite! extend() adds MULTIPLE items from another iterable.",
                "detailed": "`extend()` takes a list (or any iterable) and adds each element individually. `fruits.extend(['x', 'y'])` adds both 'x' and 'y' as separate items. For adding ONE item, use `append()`.",
                "socraticHint": "What's the difference between append(['a', 'b']) and extend(['a', 'b'])?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "append()",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l4-q4",
          "globalId": "exit-ticket-0369",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "How would you find the average of scores in the list `scores = [85, 92, 78]`?",
          "questionArchetype": "blockmodel",
          "misconceptionTargets": [
            "PY_BUILTIN_AVERAGE",
            "TYPE_INPUT_STRING_RETURN"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "sum(scores) / len(scores)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the formula for average.",
                "detailed": "Average = total sum divided by count. Python provides `sum()` to add all numbers and `len()` to count items. So `sum([85, 92, 78]) / len([85, 92, 78])` = 255 / 3 = 85. Simple and readable!"
              }
            },
            {
              "key": "B",
              "text": "scores / 3",
              "isCorrect": false,
              "misconceptionId": "TYPE_INPUT_STRING_RETURN",
              "feedback": {
                "short": "Not quite! You can't divide a list by a number.",
                "detailed": "`scores` is a LIST, not a number. Python doesn't know how to divide a list by 3. You need to first convert the list to a sum using `sum(scores)`, then divide by the count: `sum(scores) / len(scores)`.",
                "socraticHint": "What operation do you need to do to the list items before dividing?"
              }
            },
            {
              "key": "C",
              "text": "average(scores)",
              "isCorrect": false,
              "misconceptionId": "PY_BUILTIN_AVERAGE",
              "feedback": {
                "short": "Not quite! Python doesn't have a built-in average() function.",
                "detailed": "There's no `average()` in Python's standard functions. You calculate average manually: `sum(scores) / len(scores)`. Alternatively, you can `from statistics import mean` and use `mean(scores)`.",
                "socraticHint": "What two values do you need to calculate an average?"
              }
            },
            {
              "key": "D",
              "text": "mean(scores)",
              "isCorrect": false,
              "misconceptionId": "PY_BUILTIN_AVERAGE",
              "feedback": {
                "short": "Close! mean() exists but needs to be imported first.",
                "detailed": "`mean()` does exist in Python's `statistics` module, but you must import it: `from statistics import mean`. Without the import, you'll get a NameError. The built-in approach is `sum(scores) / len(scores)`.",
                "socraticHint": "What do you need to do before using functions from external modules?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "sum(scores) / len(scores)",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "rag",
              "retrieval"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l4-q5",
          "globalId": "exit-ticket-0370",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "What's the difference between append() and insert() methods?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "FUNC_EQUIVALENCE",
            "FUNC_PURPOSE_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "No difference",
              "isCorrect": false,
              "misconceptionId": "FUNC_EQUIVALENCE",
              "feedback": {
                "short": "Not quite! They have different purposes.",
                "detailed": "append() and insert() do different things: `append()` always adds to the END (no position needed), while `insert()` requires a position and can add ANYWHERE. Use append() for queues, insert() for precise placement.",
                "socraticHint": "What if you wanted to add an item at the beginning of a list?"
              }
            },
            {
              "key": "B",
              "text": "append() adds to end, insert() adds at specific position",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! They serve different use cases.",
                "detailed": "`append(item)` is simple—just add to the end. `insert(index, item)` gives you control—add at any position. For example, `list.insert(0, 'x')` adds 'x' at the beginning. Choose based on where you need the item."
              }
            },
            {
              "key": "C",
              "text": "insert() adds to end, append() adds at beginning",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! You have them backwards.",
                "detailed": "It's the opposite: `append()` adds to the END (no position needed), while `insert()` CAN add at the beginning if you specify position 0. Think of 'append' like appending to a document—it goes at the end.",
                "socraticHint": "What does 'append' mean in everyday English?"
              }
            },
            {
              "key": "D",
              "text": "append() is faster, insert() is slower",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Partially true but misses the main difference!",
                "detailed": "While append() IS typically faster (O(1) vs O(n) for insert at beginning), the key difference is WHERE they add items. Speed is a side effect of their different behaviors, not the defining feature.",
                "socraticHint": "If you need to add at a specific position, does speed matter more than correctness?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "append() adds to end, insert() adds at specific position",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-5",
      "lessonNumber": 5,
      "lessonTitle": "Conditional Statement\n\n### Q1: Vocabulary/Concepts\nWhat does the == operator do?\nA) Assigns a value to a variable\nB) Checks if two values are equal ✓\nC) Checks if one value is greater than another\nD) Adds two numbers together\n\n### Q2: Code Understanding\nWhat output will score = 75 produce in this code?\n```python\nif score >= 80:\n    print(\"Excellent!\")\nelif score >= 70:\n    print(\"Good job!\")\nelse:\n    print(\"Study more\")\n```\nA) Excellent!\nB) Good job! ✓\nC) Study more\nD) No output\n\n### Q3: Problem-Solving\nWhat logical operator checks if a person is 18+ AND a citizen?\nA) or\nB) and ✓\nC) not\nD) if\n\n### Q4: Application\nHow would you classify a bank account with $5000 balance?\nA) Premium (≥$10,000)\nB) Standard ($1,000-$9,999) ✓\nC) Basic (<$1,000)\nD) Cannot determine\n\n### Q5: Reflection/Meta-learning\nWhat is overfitting in conditional statements?\nA) Using too many conditions\nB) Not covering all possible cases\nC) Making conditions too specific without considering edge cases ✓\nD) Using incorrect operators\n\n---",
      "lessonSlug": "conditional-statement-q1-vocabularyconcepts-what-does-the-operator-do-a-assigns-a-value-to-a-variable-b-checks-if-two-values-are-equal-c-checks-if-one-value-is-greater-than-another-d-adds-two-numbers-together-q2-code-understanding-what-output-will-score-75-produce-in-this-code-python-if-score-80-printexcellent-elif-score-70-printgood-job-else-printstudy-more-a-excellent-b-good-job-c-study-more-d-no-output-q3-problem-solving-what-logical-operator-checks-if-a-person-is-18-and-a-citizen-a-or-b-and-c-not-d-if-q4-application-how-would-you-classify-a-bank-account-with-5000-balance-a-premium-10000-b-standard-1000-9999-c-basic-1000-d-cannot-determine-q5-reflectionmeta-learning-what-is-overfitting-in-conditional-statements-a-using-too-many-conditions-b-not-covering-all-possible-cases-c-making-conditions-too-specific-without-considering-edge-cases-d-using-incorrect-operators",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l5-q1",
          "globalId": "exit-ticket-0371",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "What does the == operator do?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "BOOL_ASSIGNMENT_TEST",
            "OP_OPERATOR_SYMBOL_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Assigns a value to a variable",
              "isCorrect": false,
              "misconceptionId": "BOOL_ASSIGNMENT_TEST",
              "feedback": {
                "short": "Not quite! That's the single = operator.",
                "detailed": "The SINGLE equals (=) assigns values: `x = 5` stores 5 in x. The DOUBLE equals (==) compares values: `x == 5` asks 'is x equal to 5?' and returns True or False. This is a critical distinction!",
                "socraticHint": "What would happen if you used = in an if statement?"
              }
            },
            {
              "key": "B",
              "text": "Checks if two values are equal",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! == compares for equality.",
                "detailed": "The == operator is a comparison that returns True if both sides are equal, False otherwise. It's essential for conditionals: `if age == 18:` checks if age is exactly 18. Remember: = assigns, == compares."
              }
            },
            {
              "key": "C",
              "text": "Checks if one value is greater than another",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Greater-than uses the > symbol.",
                "detailed": "For comparisons: `>` means greater than, `<` means less than, `==` means equal. So `x > y` checks if x is greater, while `x == y` checks if they're exactly the same.",
                "socraticHint": "What symbol would you use to check if a score is greater than 90?"
              }
            },
            {
              "key": "D",
              "text": "Adds two numbers together",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! Addition uses the + symbol.",
                "detailed": "The + operator adds numbers: `5 + 3` gives 8. The == operator COMPARES: `5 == 3` gives False. Different symbols, completely different purposes.",
                "socraticHint": "What would 5 == 5 return—a number or True/False?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Checks if two values are equal",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l5-q2",
          "globalId": "exit-ticket-0372",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "What output will score = 75 produce in this code?",
          "questionArchetype": "trace",
          "misconceptionTargets": [
            "LOOP_INCLUSIVE_BOUND",
            "BOOL_PRECEDENCE"
          ],
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "if score >= 80:\n    print(\"Excellent!\")\nelif score >= 70:\n    print(\"Good job!\")\nelse:\n    print(\"Study more\")",
          "options": [
            {
              "key": "A",
              "text": "Excellent!",
              "isCorrect": false,
              "misconceptionId": "LOOP_INCLUSIVE_BOUND",
              "feedback": {
                "short": "Not quite! 75 is NOT >= 80.",
                "detailed": "Let's trace: Is 75 >= 80? No! So we skip 'Excellent!' and check the elif. Is 75 >= 70? Yes! So we print 'Good job!' and stop. The first FALSE condition doesn't run—Python moves to the next check.",
                "socraticHint": "Is 75 greater than or equal to 80?"
              }
            },
            {
              "key": "B",
              "text": "Good job!",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! 75 satisfies the elif condition.",
                "detailed": "Python checks conditions in order: 75 >= 80? No. 75 >= 70? Yes! So 'Good job!' prints. Once a condition matches, Python skips the rest. This is how if-elif-else chains work—first match wins."
              }
            },
            {
              "key": "C",
              "text": "Study more",
              "isCorrect": false,
              "misconceptionId": "BOOL_PRECEDENCE",
              "feedback": {
                "short": "Not quite! 75 meets the elif condition.",
                "detailed": "The else only runs if ALL previous conditions fail. Here, 75 >= 70 is TRUE, so elif runs. 'Study more' would only print for scores below 70.",
                "socraticHint": "When does the else block run?"
              }
            },
            {
              "key": "D",
              "text": "No output",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! One of the conditions will always match.",
                "detailed": "With if-elif-else, something ALWAYS runs. The else acts as a catch-all for anything not matching earlier conditions. For score = 75, the elif (75 >= 70) matches, so 'Good job!' prints.",
                "socraticHint": "What's the purpose of the else clause?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Good job!",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "python"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l5-q3",
          "globalId": "exit-ticket-0373",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "What logical operator checks if a person is 18+ AND a citizen?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "BOOL_AND_OR",
            "FUNC_PURPOSE_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "or",
              "isCorrect": false,
              "misconceptionId": "BOOL_AND_OR",
              "feedback": {
                "short": "Not quite! 'or' means EITHER condition can be true.",
                "detailed": "The `or` operator is True if EITHER side is true. 'age >= 18 or is_citizen' would be True if the person is 18+ OR a citizen (or both). But the question requires BOTH conditions—that's what `and` is for.",
                "socraticHint": "If someone is 17 but a citizen, should they pass the check?"
              }
            },
            {
              "key": "B",
              "text": "and",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! 'and' requires BOTH conditions to be true.",
                "detailed": "The `and` operator returns True only if BOTH sides are true. `age >= 18 and is_citizen` is True only if the person is both 18+ AND a citizen. This is exactly what the question asks for."
              }
            },
            {
              "key": "C",
              "text": "not",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! 'not' reverses a single condition.",
                "detailed": "The `not` operator flips True to False and vice versa. It works on ONE condition, not two. `not is_adult` means 'is NOT an adult'. To combine two conditions, you need `and` or `or`.",
                "socraticHint": "How many conditions does 'not' work with?"
              }
            },
            {
              "key": "D",
              "text": "if",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! 'if' is a statement, not an operator.",
                "detailed": "`if` starts a conditional statement—it's not a logical operator. Inside an if statement, you USE operators like `and`, `or`, `not` to combine conditions: `if age >= 18 and is_citizen:`",
                "socraticHint": "What goes AFTER the 'if' keyword?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "and",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l5-q4",
          "globalId": "exit-ticket-0374",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "How would you classify a bank account with $5000 balance?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "LOOP_INCLUSIVE_BOUND",
            "BOOL_PRECEDENCE"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Premium (≥$10,000)",
              "isCorrect": false,
              "misconceptionId": "LOOP_INCLUSIVE_BOUND",
              "feedback": {
                "short": "Not quite! $5000 is less than $10,000.",
                "detailed": "Premium requires $10,000 or MORE. Since $5000 < $10,000, this account doesn't qualify for Premium. It falls into the Standard range ($1,000-$9,999).",
                "socraticHint": "What condition must be met for Premium?"
              }
            },
            {
              "key": "B",
              "text": "Standard ($1,000-$9,999)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! $5000 falls in the Standard range.",
                "detailed": "Standard accounts have balances between $1,000 and $9,999. Since $5000 is within this range (1000 ≤ 5000 < 10000), it's classified as Standard. This is a classic if-elif-else classification problem."
              }
            },
            {
              "key": "C",
              "text": "Basic (<$1,000)",
              "isCorrect": false,
              "misconceptionId": "LOOP_INCLUSIVE_BOUND",
              "feedback": {
                "short": "Not quite! $5000 is much more than $1,000.",
                "detailed": "Basic is for accounts with LESS than $1,000. Since $5000 > $1000, this account has too much money for Basic tier. It belongs in Standard.",
                "socraticHint": "Is 5000 less than 1000?"
              }
            },
            {
              "key": "D",
              "text": "Cannot determine",
              "isCorrect": false,
              "misconceptionId": "BOOL_PRECEDENCE",
              "feedback": {
                "short": "Not quite! We have all the information we need.",
                "detailed": "The criteria are clear: Premium (≥$10K), Standard ($1K-$9,999), Basic (<$1K). With $5000, we can definitely determine it's Standard. In conditional logic, clear boundaries make classification straightforward.",
                "socraticHint": "Which range does $5000 fit into?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Standard ($1,000-$9,999)",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l5-q5",
          "globalId": "exit-ticket-0375",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "What is overfitting in conditional statements?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "FUNC_PURPOSE_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Using too many conditions",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Many conditions isn't necessarily overfitting.",
                "detailed": "Having many conditions isn't a problem if they're necessary. Overfitting is about conditions being too SPECIFIC to known examples, not about quantity. A well-designed program might need many conditions to handle different valid cases.",
                "socraticHint": "Could a complex problem legitimately require many conditions?"
              }
            },
            {
              "key": "B",
              "text": "Not covering all possible cases",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! That's actually underfitting.",
                "detailed": "Not covering all cases is the opposite problem—underfitting or incomplete logic. Overfitting means your conditions are TOO specific, working only for examples you've seen but failing on new, valid inputs.",
                "socraticHint": "What's the difference between too specific and not specific enough?"
              }
            },
            {
              "key": "C",
              "text": "Making conditions too specific without considering edge cases",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Overfitting means conditions that are too narrow.",
                "detailed": "Overfitting happens when your conditions work perfectly for known examples but fail on new, valid inputs. For example, checking 'if name == \"John\"' instead of 'if len(name) > 0'. Good conditions generalize to handle various valid cases."
              }
            },
            {
              "key": "D",
              "text": "Using incorrect operators",
              "isCorrect": false,
              "misconceptionId": "FUNC_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! That's a syntax/logic error, not overfitting.",
                "detailed": "Using wrong operators (like > instead of <) is a bug, not overfitting. Overfitting is a design problem where conditions are technically correct but too narrow, only matching specific examples rather than the general pattern.",
                "socraticHint": "Could correct operators still lead to overfitting?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "Making conditions too specific without considering edge cases",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "overfitting",
              "model-evaluation"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-6",
      "lessonNumber": 6,
      "lessonTitle": "Loop\n\n### Q1: Vocabulary/Concepts\nWhen should you use a while loop instead of a for loop?\nA) When you know exactly how many times to repeat\nB) When you repeat until a condition changes ✓\nC) When working with lists\nD) When you want faster execution\n\n### Q2: Code Understanding\nWhat does `range(3)` generate in a for loop?\nA) [1, 2, 3]\nB) [0, 1, 2] ✓\nC) [3]\nD) [0, 1, 2, 3]\n\n### Q3: Problem-Solving\nWhich code correctly calculates the sum of even numbers from 1 to 10?\nA) `for i in range(1, 11): if i % 2 == 0: total += i` ✓\nB) `for i in range(1, 10): total += i`\nC) `for i in range(2, 11, 2): total = i`\nD) `while i < 10: total += i`\n\n### Q4: Application\nHow would you calculate bonuses for employees with sales over $50,000?\nA) Give everyone the same bonus\nB) Check each employee's sales and calculate 5% bonus if over $50,000 ✓\nC) Only give bonuses to the top performer\nD) Calculate average sales first\n\n### Q5: Reflection/Meta-learning\nHow do you prevent infinite loops?\nA) Use for loops only\nB) Ensure the loop condition eventually becomes false ✓\nC) Use break statements everywhere\nD) Avoid using loops entirely\n\n---",
      "lessonSlug": "loop-q1-vocabularyconcepts-when-should-you-use-a-while-loop-instead-of-a-for-loop-a-when-you-know-exactly-how-many-times-to-repeat-b-when-you-repeat-until-a-condition-changes-c-when-working-with-lists-d-when-you-want-faster-execution-q2-code-understanding-what-does-range3-generate-in-a-for-loop-a-1-2-3-b-0-1-2-c-3-d-0-1-2-3-q3-problem-solving-which-code-correctly-calculates-the-sum-of-even-numbers-from-1-to-10-a-for-i-in-range1-11-if-i-2-0-total-i-b-for-i-in-range1-10-total-i-c-for-i-in-range2-11-2-total-i-d-while-i-10-total-i-q4-application-how-would-you-calculate-bonuses-for-employees-with-sales-over-50000-a-give-everyone-the-same-bonus-b-check-each-employees-sales-and-calculate-5-bonus-if-over-50000-c-only-give-bonuses-to-the-top-performer-d-calculate-average-sales-first-q5-reflectionmeta-learning-how-do-you-prevent-infinite-loops-a-use-for-loops-only-b-ensure-the-loop-condition-eventually-becomes-false-c-use-break-statements-everywhere-d-avoid-using-loops-entirely",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l6-q1",
          "globalId": "exit-ticket-0376",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "When should you use a while loop instead of a for loop?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "LOOP_FOR_WHILE_CHOICE",
            "FUNC_EQUIVALENCE"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "When you know exactly how many times to repeat",
              "isCorrect": false,
              "misconceptionId": "LOOP_FOR_WHILE_CHOICE",
              "feedback": {
                "short": "Not quite! That's when you use a FOR loop.",
                "detailed": "When you know the exact count (iterate 10 times, process 5 items), a `for` loop is ideal: `for i in range(10)`. While loops are for when you DON'T know how many times—you just keep going until something changes.",
                "socraticHint": "What loop would you use to process each item in a list?"
              }
            },
            {
              "key": "B",
              "text": "When you repeat until a condition changes",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! While loops continue until a condition becomes False.",
                "detailed": "While loops are perfect when you don't know how many iterations you need. Examples: keep asking for input until valid, keep playing until game over, keep reading until end of file. The loop continues until the condition becomes False."
              }
            },
            {
              "key": "C",
              "text": "When working with lists",
              "isCorrect": false,
              "misconceptionId": "LOOP_FOR_WHILE_CHOICE",
              "feedback": {
                "short": "Not quite! FOR loops are better for lists.",
                "detailed": "For loops are ideal for lists: `for item in my_list` iterates through each item cleanly. While loops CAN work with lists but require manual index tracking, making code more complex and error-prone.",
                "socraticHint": "Which is cleaner: 'for item in list' or manually tracking an index?"
              }
            },
            {
              "key": "D",
              "text": "When you want faster execution",
              "isCorrect": false,
              "misconceptionId": "FUNC_EQUIVALENCE",
              "feedback": {
                "short": "Not quite! Both loop types have similar speed.",
                "detailed": "There's no significant speed difference between for and while loops. The choice depends on LOGIC, not performance. Use for when you know the count, while when you're waiting for a condition. Choose based on clarity, not speed.",
                "socraticHint": "What should guide your choice of loop type?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "When you repeat until a condition changes",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.0",
            "createdDate": "2024-08-13",
            "lastModified": "2025-11-07"
          }
        },
        {
          "questionId": "ai-1-l6-q2",
          "globalId": "exit-ticket-0377",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "What does `range(3)` generate in a for loop?",
          "questionArchetype": "trace",
          "misconceptionTargets": [
            "LOOP_RANGE_START_ONE",
            "LOOP_RANGE_INCLUSIVE"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "[1, 2, 3]",
              "isCorrect": false,
              "misconceptionId": "LOOP_RANGE_START_ONE",
              "feedback": {
                "short": "Not quite! Python's range() starts at 0, not 1.",
                "detailed": "range(3) generates numbers starting from 0: [0, 1, 2]. Many beginners expect 1-based counting, but Python uses 0-based indexing. Think: range(n) gives you n numbers, starting from 0.",
                "socraticHint": "If range() started at 1, how many numbers would range(3) give you?"
              }
            },
            {
              "key": "B",
              "text": "[0, 1, 2]",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! range(3) generates 0, 1, 2—three numbers starting from 0.",
                "detailed": "Python's range() starts at 0 and stops BEFORE the number you specify. So range(3) gives exactly 3 values: 0, 1, and 2. This is consistent with 0-based indexing throughout Python."
              }
            },
            {
              "key": "C",
              "text": "[3]",
              "isCorrect": false,
              "misconceptionId": "LOOP_RANGE_INCLUSIVE",
              "feedback": {
                "short": "Not quite! The number in range() is the count, not the only value.",
                "detailed": "range(3) doesn't return just [3]—it generates a sequence of 3 numbers: 0, 1, 2. The argument tells Python HOW MANY numbers to generate, starting from 0.",
                "socraticHint": "If range(3) only gave you [3], what would range(10) give you?"
              }
            },
            {
              "key": "D",
              "text": "[0, 1, 2, 3]",
              "isCorrect": false,
              "misconceptionId": "LOOP_RANGE_INCLUSIVE",
              "feedback": {
                "short": "Not quite! range() stops BEFORE the endpoint, not at it.",
                "detailed": "range(3) generates [0, 1, 2]—exactly 3 numbers. It EXCLUDES the endpoint. This 'exclusive endpoint' pattern is common in Python (and many languages) because it makes range(n) give exactly n items.",
                "socraticHint": "If range(3) included 3, how many numbers would that be?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "[0, 1, 2]",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l6-q3",
          "globalId": "exit-ticket-0378",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Which code correctly calculates the sum of even numbers from 1 to 10?",
          "questionArchetype": "blockmodel",
          "misconceptionTargets": [
            "LOOP_RANGE_INCLUSIVE",
            "VAR_REASSIGNMENT",
            "VAR_UNINITIALIZED"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "`for i in range(1, 11): if i % 2 == 0: total += i`",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This loops 1-10, filters for evens, and accumulates the sum.",
                "detailed": "This code correctly: (1) iterates from 1 to 10 using range(1, 11), (2) checks if each number is even using modulo (% 2 == 0), and (3) accumulates the sum with += operator. Result: 2+4+6+8+10 = 30."
              }
            },
            {
              "key": "B",
              "text": "`for i in range(1, 10): total += i`",
              "isCorrect": false,
              "misconceptionId": "LOOP_RANGE_INCLUSIVE",
              "feedback": {
                "short": "Not quite! This misses 10 AND adds ALL numbers, not just evens.",
                "detailed": "Two problems: (1) range(1, 10) stops at 9, missing 10. (2) There's no condition to filter even numbers—it adds ALL numbers. Remember: range() excludes the endpoint, and filtering requires an if statement.",
                "socraticHint": "What would happen if you added an if statement to check for even numbers?"
              }
            },
            {
              "key": "C",
              "text": "`for i in range(2, 11, 2): total = i`",
              "isCorrect": false,
              "misconceptionId": "VAR_REASSIGNMENT",
              "feedback": {
                "short": "Not quite! Using `=` replaces the total instead of accumulating it.",
                "detailed": "The range(2, 11, 2) cleverly generates only evens [2, 4, 6, 8, 10], BUT `total = i` REPLACES the value each iteration instead of adding. After the loop, total would just be 10 (the last value), not 30. Use `+=` to accumulate!",
                "socraticHint": "What's the difference between `total = i` and `total += i`?"
              }
            },
            {
              "key": "D",
              "text": "`while i < 10: total += i`",
              "isCorrect": false,
              "misconceptionId": "VAR_UNINITIALIZED",
              "feedback": {
                "short": "Not quite! Variable `i` is never initialized or incremented.",
                "detailed": "This code has multiple issues: (1) `i` is never initialized—NameError! (2) `i` is never incremented inside the loop—infinite loop! (3) No filter for even numbers. While loops require manual setup: initialize before, increment inside.",
                "socraticHint": "What three things does a while loop need: initialization, condition, and ___?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "`for i in range(1, 11): if i % 2 == 0: total += i`",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l6-q4",
          "globalId": "exit-ticket-0379",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "How would you calculate bonuses for employees with sales over $50,000?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "BOOL_CONDITION_IGNORE",
            "ALGO_REQUIREMENTS_DRIFT"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Give everyone the same bonus",
              "isCorrect": false,
              "misconceptionId": "BOOL_CONDITION_IGNORE",
              "feedback": {
                "short": "Not quite! This ignores the $50,000 threshold requirement.",
                "detailed": "The problem specifies 'employees with sales OVER $50,000'—a conditional requirement. Giving everyone the same bonus ignores this filtering condition. In code, you need: for employee in employees: if sales > 50000: give_bonus().",
                "socraticHint": "Why would a business want to differentiate bonuses based on performance?"
              }
            },
            {
              "key": "B",
              "text": "Check each employee's sales and calculate 5% bonus if over $50,000",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This combines iteration (each employee) + condition (if over $50,000) + calculation (5%).",
                "detailed": "This answer correctly identifies the three components: (1) Loop through all employees, (2) Check if sales > $50,000 (condition), (3) Calculate bonus based on their performance. This is how you translate business requirements into algorithmic thinking."
              }
            },
            {
              "key": "C",
              "text": "Only give bonuses to the top performer",
              "isCorrect": false,
              "misconceptionId": "ALGO_REQUIREMENTS_DRIFT",
              "feedback": {
                "short": "Not quite! The requirement is 'over $50,000', not 'top performer'.",
                "detailed": "This changes the problem requirements. 'Over $50,000' could include MULTIPLE employees (anyone above the threshold), while 'top performer' is only ONE person. Always solve the ACTUAL problem, not a modified version!",
                "socraticHint": "What if 5 employees all had sales over $50,000?"
              }
            },
            {
              "key": "D",
              "text": "Calculate average sales first",
              "isCorrect": false,
              "misconceptionId": "ALGO_REQUIREMENTS_DRIFT",
              "feedback": {
                "short": "Not quite! Averages aren't needed—we have a fixed $50,000 threshold.",
                "detailed": "Calculating average adds unnecessary complexity. The threshold is explicitly $50,000—not 'above average'. Adding extra steps that aren't required is a common algorithmic mistake. Stick to the requirements: check if individual sales > $50,000.",
                "socraticHint": "Would the average change whether an employee with $60,000 sales deserves a bonus?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Check each employee's sales and calculate 5% bonus if over $50,000",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l6-q5",
          "globalId": "exit-ticket-0380",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "How do you prevent infinite loops?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "LOOP_FOR_WHILE_CHOICE",
            "LOOP_BREAK_OVERUSE",
            "FEATURE_AVOIDANCE"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Use for loops only",
              "isCorrect": false,
              "misconceptionId": "LOOP_FOR_WHILE_CHOICE",
              "feedback": {
                "short": "Not quite! For loops can also be infinite if misused.",
                "detailed": "While for loops with range() have built-in termination, you can still create infinite for loops (e.g., iterating over a list that keeps growing). The real solution is ensuring your loop condition changes over time, regardless of loop type.",
                "socraticHint": "What happens in a for loop if you keep appending to the list you're iterating over?"
              }
            },
            {
              "key": "B",
              "text": "Ensure the loop condition eventually becomes false",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Every loop needs a termination condition that will eventually trigger.",
                "detailed": "The key insight: loops must progress toward termination. For while loops, ensure something in the loop body changes the condition (like incrementing a counter or updating a flag). This is called 'loop invariant progress'—each iteration should bring you closer to exit."
              }
            },
            {
              "key": "C",
              "text": "Use break statements everywhere",
              "isCorrect": false,
              "misconceptionId": "LOOP_BREAK_OVERUSE",
              "feedback": {
                "short": "Not quite! Break statements are tools, not prevention strategies.",
                "detailed": "Break statements exit a loop early, but they don't prevent infinite loops—they just provide an escape hatch. If the break condition is never met, the loop is still infinite! Proper loop design with clear termination conditions is more robust than relying on break.",
                "socraticHint": "What if the break condition inside the loop is never true?"
              }
            },
            {
              "key": "D",
              "text": "Avoid using loops entirely",
              "isCorrect": false,
              "misconceptionId": "FEATURE_AVOIDANCE",
              "feedback": {
                "short": "Not quite! Loops are essential—learn to use them correctly instead.",
                "detailed": "Avoiding loops isn't practical—they're fundamental to programming! Tasks like processing lists, reading files, and handling user input all require loops. The solution is understanding loop mechanics, not avoiding them. Master the tool!",
                "socraticHint": "How would you process a list of 1000 items without any kind of loop?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Ensure the loop condition eventually becomes false",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-7",
      "lessonNumber": 7,
      "lessonTitle": "Dictionary\n\n### Q1: Vocabulary/Concepts\nHow is a dictionary different from a list?\nA) Dictionaries use key-value pairs, lists use indexed positions ✓\nB) Dictionaries are faster than lists\nC) Lists can store more data than dictionaries\nD) There is no difference\n\n### Q2: Code Understanding\nWhat happens when you run `student[\"grade\"] = 90` on an existing dictionary?\nA) Creates a new dictionary\nB) Updates the value for the \"grade\" key ✓\nC) Deletes the \"grade\" key\nD) Causes an error\n\n### Q3: Problem-Solving\nHow do you safely check if a key exists in a dictionary before accessing it?\nA) Use try/except\nB) Use the `in` keyword ✓\nC) Use the get() method\nD) Both B and C are correct ✓\n\n### Q4: Application\nHow would you calculate total inventory value from this structure?\n```python\ninventory = {\"apples\": {\"quantity\": 50, \"price\": 2.50}}\n```\nA) quantity + price\nB) quantity * price ✓\nC) quantity / price\nD) quantity - price\n\n### Q5: Reflection/Meta-learning\nWhen should you use a dictionary instead of a list?\nA) When you need to associate data with meaningful labels ✓\nB) When you need ordered data\nC) When you have numeric data only\nD) When you need faster sorting\n\n---",
      "lessonSlug": "dictionary-q1-vocabularyconcepts-how-is-a-dictionary-different-from-a-list-a-dictionaries-use-key-value-pairs-lists-use-indexed-positions-b-dictionaries-are-faster-than-lists-c-lists-can-store-more-data-than-dictionaries-d-there-is-no-difference-q2-code-understanding-what-happens-when-you-run-studentgrade-90-on-an-existing-dictionary-a-creates-a-new-dictionary-b-updates-the-value-for-the-grade-key-c-deletes-the-grade-key-d-causes-an-error-q3-problem-solving-how-do-you-safely-check-if-a-key-exists-in-a-dictionary-before-accessing-it-a-use-tryexcept-b-use-the-in-keyword-c-use-the-get-method-d-both-b-and-c-are-correct-q4-application-how-would-you-calculate-total-inventory-value-from-this-structure-python-inventory-apples-quantity-50-price-250-a-quantity-price-b-quantity-price-c-quantity-price-d-quantity-price-q5-reflectionmeta-learning-when-should-you-use-a-dictionary-instead-of-a-list-a-when-you-need-to-associate-data-with-meaningful-labels-b-when-you-need-ordered-data-c-when-you-have-numeric-data-only-d-when-you-need-faster-sorting",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l7-q1",
          "globalId": "exit-ticket-0381",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "How is a dictionary different from a list?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "DICT_LIST_EQUIVALENCE",
            "DICT_PERFORMANCE_MYTH",
            "DICT_CAPACITY_MYTH"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Dictionaries use key-value pairs, lists use indexed positions",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Dictionaries map keys to values; lists use numeric indices.",
                "detailed": "This is the fundamental difference: Lists use sequential numbers (0, 1, 2...) to access items. Dictionaries use meaningful keys ('name', 'age', 'grade'). Think: list = numbered slots, dictionary = labeled drawers."
              }
            },
            {
              "key": "B",
              "text": "Dictionaries are faster than lists",
              "isCorrect": false,
              "misconceptionId": "DICT_PERFORMANCE_MYTH",
              "feedback": {
                "short": "Not quite! Speed depends on the operation, not the data structure itself.",
                "detailed": "This is a common oversimplification. Dictionaries are fast for LOOKUP by key (O(1)), but lists are fast for ordered iteration and index access. The best structure depends on your use case, not raw 'speed'.",
                "socraticHint": "Would you use a dictionary to store items that need to stay in order?"
              }
            },
            {
              "key": "C",
              "text": "Lists can store more data than dictionaries",
              "isCorrect": false,
              "misconceptionId": "DICT_CAPACITY_MYTH",
              "feedback": {
                "short": "Not quite! Both can store unlimited data (limited only by memory).",
                "detailed": "Python lists and dictionaries have no built-in size limits. Both grow dynamically and are constrained only by available memory. The difference is ACCESS METHOD, not capacity.",
                "socraticHint": "What actually limits how much data you can store in Python?"
              }
            },
            {
              "key": "D",
              "text": "There is no difference",
              "isCorrect": false,
              "misconceptionId": "DICT_LIST_EQUIVALENCE",
              "feedback": {
                "short": "Not quite! Lists and dictionaries have fundamentally different structures.",
                "detailed": "Lists and dictionaries serve different purposes. Lists: ordered collections accessed by position. Dictionaries: key-value mappings for labeled data. Choosing the right structure is a core programming skill!",
                "socraticHint": "How would you store a student's name, age, and grade—would numeric indices be meaningful?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Dictionaries use key-value pairs, lists use indexed positions",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l7-q2",
          "globalId": "exit-ticket-0382",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "What happens when you run `student[\"grade\"] = 90` on an existing dictionary?",
          "questionArchetype": "trace",
          "misconceptionTargets": [
            "DICT_ASSIGNMENT_CREATE",
            "DICT_ASSIGNMENT_DELETE",
            "DICT_KEY_ERROR"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Creates a new dictionary",
              "isCorrect": false,
              "misconceptionId": "DICT_ASSIGNMENT_CREATE",
              "feedback": {
                "short": "Not quite! Assignment to a key modifies the EXISTING dictionary.",
                "detailed": "dict[key] = value updates the dictionary IN PLACE—it doesn't create a new one. The original dictionary object gets modified. If you wanted a new dictionary, you'd use dict.copy() or dict() constructor.",
                "socraticHint": "If you had a reference to this dictionary elsewhere, would it see the change?"
              }
            },
            {
              "key": "B",
              "text": "Updates the value for the \"grade\" key",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! dict[key] = value updates (or creates) the key-value pair.",
                "detailed": "This is the standard way to update dictionary values. If the key exists, the value is replaced. If the key doesn't exist, a new key-value pair is added. The dictionary is modified in place."
              }
            },
            {
              "key": "C",
              "text": "Deletes the \"grade\" key",
              "isCorrect": false,
              "misconceptionId": "DICT_ASSIGNMENT_DELETE",
              "feedback": {
                "short": "Not quite! Assignment sets a value; deletion requires del or pop().",
                "detailed": "The = operator assigns values, not deletes. To delete a key, use: del dict['key'] or dict.pop('key'). Assignment with = always ADDS or UPDATES, never removes.",
                "socraticHint": "What command would you use to remove a key from a dictionary?"
              }
            },
            {
              "key": "D",
              "text": "Causes an error",
              "isCorrect": false,
              "misconceptionId": "DICT_KEY_ERROR",
              "feedback": {
                "short": "Not quite! Assignment always works—it creates the key if missing.",
                "detailed": "Unlike READING a missing key (which raises KeyError), ASSIGNING to a missing key always succeeds—Python simply creates the key. This is a key difference: dict['x'] fails if x missing, but dict['x'] = 5 creates it.",
                "socraticHint": "What operation would cause a KeyError—reading or writing?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Updates the value for the \"grade\" key",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l7-q3",
          "globalId": "exit-ticket-0383",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "How do you safely check if a key exists in a dictionary before accessing it?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "DICT_TRY_EXCEPT_ONLY",
            "DICT_IN_ONLY",
            "DICT_GET_ONLY"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Use try/except",
              "isCorrect": false,
              "misconceptionId": "DICT_TRY_EXCEPT_ONLY",
              "feedback": {
                "short": "Partially right, but there are cleaner methods for dictionaries.",
                "detailed": "try/except works but follows 'ask forgiveness' style—it catches KeyError after it happens. For dictionaries, 'ask permission' using `in` or get() is often cleaner and more explicit. try/except is better when you expect the key to usually exist.",
                "socraticHint": "Which is more readable: checking first or catching errors?"
              }
            },
            {
              "key": "B",
              "text": "Use the `in` keyword",
              "isCorrect": false,
              "misconceptionId": "DICT_IN_ONLY",
              "feedback": {
                "short": "This works, but it's not the ONLY correct approach!",
                "detailed": "Using `if 'key' in dict:` is a clean, Pythonic way to check. But get() also safely handles missing keys by returning a default value. Both are valid—read the other options carefully!",
                "socraticHint": "Is there another method that also safely handles missing keys?"
              }
            },
            {
              "key": "C",
              "text": "Use the get() method",
              "isCorrect": false,
              "misconceptionId": "DICT_GET_ONLY",
              "feedback": {
                "short": "This works, but it's not the ONLY correct approach!",
                "detailed": "dict.get('key', default) safely returns the value OR a default (None if not specified). But the `in` keyword also safely checks without raising errors. Both are valid—read the other options carefully!",
                "socraticHint": "What other method can check if a key exists without raising an error?"
              }
            },
            {
              "key": "D",
              "text": "Both B and C are correct",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Both `in` and get() safely handle missing keys.",
                "detailed": "Python offers multiple safe patterns: `if 'key' in dict:` checks existence explicitly, while `dict.get('key', default)` returns a safe default. Both avoid KeyError. The choice depends on whether you need to check first or get with a fallback."
              }
            }
          ],
          "correctAnswer": "D",
          "correctAnswerText": "Both B and C are correct",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l7-q4",
          "globalId": "exit-ticket-0384",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "How would you calculate total inventory value from this structure?",
          "questionArchetype": "blockmodel",
          "misconceptionTargets": [
            "FORMULA_OPERATION_CONFUSION",
            "MATH_OPERATOR_MISUSE"
          ],
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "inventory = {\"apples\": {\"quantity\": 50, \"price\": 2.50}}",
          "options": [
            {
              "key": "A",
              "text": "quantity + price",
              "isCorrect": false,
              "misconceptionId": "FORMULA_OPERATION_CONFUSION",
              "feedback": {
                "short": "Not quite! Adding quantity and price doesn't give value.",
                "detailed": "50 apples + $2.50 = 52.50 what? That's mixing units meaninglessly. Value = how many items × price per item. Think of it like buying groceries: 3 apples at $1 each = 3 × $1 = $3.",
                "socraticHint": "If you buy 5 items at $10 each, is the total $15 or $50?"
              }
            },
            {
              "key": "B",
              "text": "quantity * price",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Total value = quantity × price per unit.",
                "detailed": "50 apples × $2.50/apple = $125.00 total value. This is the fundamental formula for inventory value: count times unit price. In code: inventory['apples']['quantity'] * inventory['apples']['price']."
              }
            },
            {
              "key": "C",
              "text": "quantity / price",
              "isCorrect": false,
              "misconceptionId": "MATH_OPERATOR_MISUSE",
              "feedback": {
                "short": "Not quite! Division would tell you how many items per dollar.",
                "detailed": "50 / 2.50 = 20—that tells you '20 apples per dollar', not the total value. Division inverts the relationship. Value calculation always uses multiplication: quantity × unit price.",
                "socraticHint": "What does dividing quantity by price actually represent?"
              }
            },
            {
              "key": "D",
              "text": "quantity - price",
              "isCorrect": false,
              "misconceptionId": "MATH_OPERATOR_MISUSE",
              "feedback": {
                "short": "Not quite! Subtraction has no meaning here.",
                "detailed": "50 - 2.50 = 47.50—this number has no real-world meaning. You can't subtract a price from a count. Value calculations use multiplication: quantity × price per item.",
                "socraticHint": "What would '50 apples minus $2.50' even represent?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "quantity * price",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "python"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l7-q5",
          "globalId": "exit-ticket-0385",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "When should you use a dictionary instead of a list?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "DICT_ORDER_ASSUMPTION",
            "DICT_NUMERIC_ONLY",
            "DICT_SORT_ADVANTAGE"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "When you need to associate data with meaningful labels",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Dictionaries excel at mapping meaningful keys to values.",
                "detailed": "Dictionaries shine when your data has natural labels: student['name'], config['port'], inventory['apples']. The keys describe WHAT the data represents. Lists are better when position matters more than labels."
              }
            },
            {
              "key": "B",
              "text": "When you need ordered data",
              "isCorrect": false,
              "misconceptionId": "DICT_ORDER_ASSUMPTION",
              "feedback": {
                "short": "Not quite! Lists are better for ordered sequences.",
                "detailed": "While Python 3.7+ dictionaries maintain insertion order, lists are purpose-built for ordered data. If you need index-based access, iteration by position, or ordered manipulation (insert, sort, reverse), lists are the right choice.",
                "socraticHint": "Would you use dict[0], dict[1] to access items in order, or list[0], list[1]?"
              }
            },
            {
              "key": "C",
              "text": "When you have numeric data only",
              "isCorrect": false,
              "misconceptionId": "DICT_NUMERIC_ONLY",
              "feedback": {
                "short": "Not quite! Data type doesn't determine the structure choice.",
                "detailed": "Both lists and dictionaries can store numeric data. The choice depends on ACCESS patterns, not data types. Use lists for sequences of numbers; use dictionaries when numbers need meaningful labels (like 'temperature': 98.6).",
                "socraticHint": "Could you store test scores in both a list AND a dictionary?"
              }
            },
            {
              "key": "D",
              "text": "When you need faster sorting",
              "isCorrect": false,
              "misconceptionId": "DICT_SORT_ADVANTAGE",
              "feedback": {
                "short": "Not quite! Dictionaries aren't designed for sorting—lists are.",
                "detailed": "Lists have built-in sort() and can be easily sorted. Dictionaries maintain key-value pairs, so 'sorting a dictionary' is more complex (sort by keys? by values?). If sorting is your primary need, lists are typically better.",
                "socraticHint": "How would you even 'sort' a dictionary—by keys or by values?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "When you need to associate data with meaningful labels",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-8",
      "lessonNumber": 8,
      "lessonTitle": "Function\n\n### Q1: Vocabulary/Concepts\nWhat is the difference between parameters and arguments?\nA) No difference\nB) Parameters are in function definition, arguments are values passed when calling ✓\nC) Arguments are in function definition, parameters are passed values\nD) Parameters are for numbers, arguments are for text\n\n### Q2: Code Understanding\nWhat does this function return for `calculate_grade(85)`?\n```python\ndef calculate_grade(score):\n    if score >= 90: return \"A\"\n    elif score >= 80: return \"B\"\n    else: return \"C\"\n```\nA) A\nB) B ✓\nC) C\nD) 85\n\n### Q3: Problem-Solving\nWhich function correctly calculates circle area?\nA) `def circle_area(r): return 3.14 * r * 2`\nB) `def circle_area(r): return 3.14 * r ** 2` ✓\nC) `def circle_area(r): return 3.14 + r ** 2`\nD) `def circle_area(r): return 3.14 / r ** 2`\n\n### Q4: Application\nHow should a restaurant bill calculator function be structured?\nA) Take meal cost only, return total\nB) Take meal cost, tax rate, tip percentage; return calculated total ✓\nC) Take total amount, return breakdown\nD) No parameters needed\n\n### Q5: Reflection/Meta-learning\nWhat makes a good function?\nA) As long as possible\nB) Does one thing well with a descriptive name ✓\nC) Uses global variables\nD) Never returns values\n\n---",
      "lessonSlug": "function-q1-vocabularyconcepts-what-is-the-difference-between-parameters-and-arguments-a-no-difference-b-parameters-are-in-function-definition-arguments-are-values-passed-when-calling-c-arguments-are-in-function-definition-parameters-are-passed-values-d-parameters-are-for-numbers-arguments-are-for-text-q2-code-understanding-what-does-this-function-return-for-calculate_grade85-python-def-calculate_gradescore-if-score-90-return-a-elif-score-80-return-b-else-return-c-a-a-b-b-c-c-d-85-q3-problem-solving-which-function-correctly-calculates-circle-area-a-def-circle_arear-return-314-r-2-b-def-circle_arear-return-314-r-2-c-def-circle_arear-return-314-r-2-d-def-circle_arear-return-314-r-2-q4-application-how-should-a-restaurant-bill-calculator-function-be-structured-a-take-meal-cost-only-return-total-b-take-meal-cost-tax-rate-tip-percentage-return-calculated-total-c-take-total-amount-return-breakdown-d-no-parameters-needed-q5-reflectionmeta-learning-what-makes-a-good-function-a-as-long-as-possible-b-does-one-thing-well-with-a-descriptive-name-c-uses-global-variables-d-never-returns-values",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l8-q1",
          "globalId": "exit-ticket-0386",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "What is the difference between parameters and arguments?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "FUNC_PARAM_ARG_CONFUSION",
            "FUNC_PARAM_TYPE_RESTRICTION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "No difference",
              "isCorrect": false,
              "misconceptionId": "FUNC_PARAM_ARG_CONFUSION",
              "feedback": {
                "short": "Not quite! They're related but refer to different things.",
                "detailed": "Parameters and arguments are often used interchangeably in casual speech, but they have distinct meanings. Parameters are the PLACEHOLDERS in the function definition; arguments are the actual VALUES you pass when calling. Think: parameters = variable names, arguments = values.",
                "socraticHint": "In `def greet(name):`, what is `name`? When you call `greet('Alice')`, what is 'Alice'?"
              }
            },
            {
              "key": "B",
              "text": "Parameters are in function definition, arguments are values passed when calling",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Parameters are placeholders; arguments are actual values.",
                "detailed": "In `def greet(name):`, 'name' is a PARAMETER (placeholder). In `greet('Alice')`, 'Alice' is an ARGUMENT (actual value). Memory trick: Parameters are Placeholders; Arguments are Actual values."
              }
            },
            {
              "key": "C",
              "text": "Arguments are in function definition, parameters are passed values",
              "isCorrect": false,
              "misconceptionId": "FUNC_PARAM_ARG_CONFUSION",
              "feedback": {
                "short": "Not quite! You have it backwards.",
                "detailed": "This reverses the correct definition. PARAMETERS appear in the function definition (the 'P' for Placeholder). ARGUMENTS are the actual values passed when calling (the 'A' for Actual). Memory trick: think alphabetically—P comes before A, just like definition comes before calling.",
                "socraticHint": "In `def add(x, y):`, which part is the definition—the def line or the function call?"
              }
            },
            {
              "key": "D",
              "text": "Parameters are for numbers, arguments are for text",
              "isCorrect": false,
              "misconceptionId": "FUNC_PARAM_TYPE_RESTRICTION",
              "feedback": {
                "short": "Not quite! Both can be any data type.",
                "detailed": "Parameters and arguments aren't separated by data type. Both can be numbers, text, lists, or any Python type. The distinction is WHEN they're used: parameters in definition, arguments when calling—regardless of data type.",
                "socraticHint": "Can you pass a number as an argument to a function that expects text?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Parameters are in function definition, arguments are values passed when calling",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l8-q2",
          "globalId": "exit-ticket-0387",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "What does this function return for `calculate_grade(85)`?",
          "questionArchetype": "trace",
          "misconceptionTargets": [
            "BOOL_CONDITION_ORDER",
            "FUNC_RETURN_PRINT",
            "FUNC_RETURN_INPUT"
          ],
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "def calculate_grade(score):\n    if score >= 90: return \"A\"\n    elif score >= 80: return \"B\"\n    else: return \"C\"",
          "options": [
            {
              "key": "A",
              "text": "A",
              "isCorrect": false,
              "misconceptionId": "BOOL_CONDITION_ORDER",
              "feedback": {
                "short": "Not quite! Check the condition: is 85 >= 90?",
                "detailed": "For grade 'A', the condition is score >= 90. Since 85 < 90, the first condition is FALSE. Python then checks the next condition (elif score >= 80). Trace step by step: 85 >= 90? No → 85 >= 80? Yes → return 'B'.",
                "socraticHint": "What's the first condition that Python checks, and is 85 greater than or equal to 90?"
              }
            },
            {
              "key": "B",
              "text": "B",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! 85 fails the >=90 test but passes >=80.",
                "detailed": "Tracing: 85 >= 90? False (skip A). 85 >= 80? True! Return 'B' immediately. The else branch never runs. This if/elif/else pattern checks conditions in ORDER and stops at the first match."
              }
            },
            {
              "key": "C",
              "text": "C",
              "isCorrect": false,
              "misconceptionId": "BOOL_CONDITION_ORDER",
              "feedback": {
                "short": "Not quite! The else only runs if ALL previous conditions fail.",
                "detailed": "The else branch runs only when both if AND elif conditions are false. Since 85 >= 80 is TRUE, Python returns 'B' and never reaches else. Trace: 85 >= 90? No → 85 >= 80? Yes → return 'B' (stop here).",
                "socraticHint": "Does 85 >= 80 evaluate to True or False?"
              }
            },
            {
              "key": "D",
              "text": "85",
              "isCorrect": false,
              "misconceptionId": "FUNC_RETURN_INPUT",
              "feedback": {
                "short": "Not quite! The function returns a GRADE letter, not the input score.",
                "detailed": "Functions transform inputs into outputs. This function takes a numeric score (85) and returns a letter grade ('A', 'B', or 'C'). The input value isn't automatically returned—the function's logic determines the output.",
                "socraticHint": "What does the 'return' statement actually return—is it ever 'score' directly?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "B",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "python"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l8-q3",
          "globalId": "exit-ticket-0388",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Which function correctly calculates circle area?",
          "questionArchetype": "blockmodel",
          "misconceptionTargets": [
            "FORMULA_AREA_CIRCUMFERENCE",
            "FORMULA_OPERATION_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "`def circle_area(r): return 3.14 * r * 2`",
              "isCorrect": false,
              "misconceptionId": "FORMULA_AREA_CIRCUMFERENCE",
              "feedback": {
                "short": "Not quite! That calculates circumference, not area.",
                "detailed": "This formula (π × r × 2 = 2πr) is for CIRCUMFERENCE (perimeter), not area. Area formula: π × r². Think: area is about covering SPACE (squared), circumference is about going AROUND (linear).",
                "socraticHint": "If you double the radius, does area double or quadruple?"
              }
            },
            {
              "key": "B",
              "text": "`def circle_area(r): return 3.14 * r ** 2`",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Area = π × r² — pi times radius squared.",
                "detailed": "The circle area formula is A = πr². In Python: 3.14 * r ** 2. The ** operator means 'to the power of', so r ** 2 = r². For a circle with radius 5: 3.14 × 25 = 78.5 square units."
              }
            },
            {
              "key": "C",
              "text": "`def circle_area(r): return 3.14 + r ** 2`",
              "isCorrect": false,
              "misconceptionId": "FORMULA_OPERATION_CONFUSION",
              "feedback": {
                "short": "Not quite! You need multiplication, not addition.",
                "detailed": "Adding π to r² makes no geometric sense. The area formula is π TIMES r² (multiplication). Think: π is a scaling factor for the squared radius, not something added to it.",
                "socraticHint": "What operation connects π and r² in the formula A = πr²?"
              }
            },
            {
              "key": "D",
              "text": "`def circle_area(r): return 3.14 / r ** 2`",
              "isCorrect": false,
              "misconceptionId": "FORMULA_OPERATION_CONFUSION",
              "feedback": {
                "short": "Not quite! Division would make larger circles have smaller areas!",
                "detailed": "Dividing by r² inverts the relationship—larger radii would give smaller areas, which is backwards! The correct formula multiplies π by r². Area grows with radius squared, not shrinks.",
                "socraticHint": "If you divide by a larger number, does the result get bigger or smaller?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "`def circle_area(r): return 3.14 * r ** 2`",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l8-q4",
          "globalId": "exit-ticket-0389",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "How should a restaurant bill calculator function be structured?",
          "questionArchetype": "bebras",
          "misconceptionTargets": [
            "FUNC_INCOMPLETE_PARAMS",
            "FUNC_IO_REVERSAL",
            "FUNC_HARDCODED_VALUES"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Take meal cost only, return total",
              "isCorrect": false,
              "misconceptionId": "FUNC_INCOMPLETE_PARAMS",
              "feedback": {
                "short": "Not quite! How would you calculate tax and tip without those rates?",
                "detailed": "A useful bill calculator needs ALL the variable inputs: meal cost, tax rate, AND tip percentage. Hardcoding tax/tip rates makes the function inflexible—different restaurants have different rates! Good function design: parameterize what changes.",
                "socraticHint": "What if you eat in a city with 9% tax vs one with 6% tax?"
              }
            },
            {
              "key": "B",
              "text": "Take meal cost, tax rate, tip percentage; return calculated total",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! All variable inputs as parameters, calculated result as output.",
                "detailed": "This follows function design best practices: (1) Parameters for all VARIABLE inputs (meal, tax, tip), (2) Function does the CALCULATION internally, (3) Returns the RESULT. Example: calculate_bill(50.00, 0.08, 0.20) → 64.80."
              }
            },
            {
              "key": "C",
              "text": "Take total amount, return breakdown",
              "isCorrect": false,
              "misconceptionId": "FUNC_IO_REVERSAL",
              "feedback": {
                "short": "Not quite! That's backwards—you're calculating the total, not breaking it down.",
                "detailed": "The goal is to CALCULATE the total from components, not reverse-engineer components from a total. Input: raw data (meal cost, rates). Output: computed result (total bill). This reverses the natural data flow.",
                "socraticHint": "When you get a restaurant bill, do you know the subtotal first or the total first?"
              }
            },
            {
              "key": "D",
              "text": "No parameters needed",
              "isCorrect": false,
              "misconceptionId": "FUNC_HARDCODED_VALUES",
              "feedback": {
                "short": "Not quite! Without parameters, where would the data come from?",
                "detailed": "A function with no parameters can only use hardcoded values or global variables—both are bad practice. Parameters make functions REUSABLE: the same calculate_bill() works for any meal at any restaurant.",
                "socraticHint": "How would the function know the meal cost if you don't pass it as input?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Take meal cost, tax rate, tip percentage; return calculated total",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l8-q5",
          "globalId": "exit-ticket-0390",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "What makes a good function?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "FUNC_LENGTH_QUALITY",
            "FUNC_GLOBAL_PREFERENCE",
            "FUNC_NO_RETURN"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "As long as possible",
              "isCorrect": false,
              "misconceptionId": "FUNC_LENGTH_QUALITY",
              "feedback": {
                "short": "Not quite! Shorter, focused functions are usually better.",
                "detailed": "Long functions are harder to understand, test, and debug. Good functions are SHORT and do ONE thing well. The 'single responsibility principle' says each function should have one clear purpose. If it's too long, break it into smaller functions!",
                "socraticHint": "If a function does 10 things, how do you find which part has a bug?"
              }
            },
            {
              "key": "B",
              "text": "Does one thing well with a descriptive name",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Single purpose + clear name = good function.",
                "detailed": "Good functions follow two key principles: (1) DO ONE THING WELL—focused, testable, reusable. (2) DESCRIPTIVE NAME—`calculate_tax()` is better than `ct()`. These make code readable, maintainable, and debuggable."
              }
            },
            {
              "key": "C",
              "text": "Uses global variables",
              "isCorrect": false,
              "misconceptionId": "FUNC_GLOBAL_PREFERENCE",
              "feedback": {
                "short": "Not quite! Global variables make functions unpredictable.",
                "detailed": "Functions that use global variables are harder to test and can cause hidden bugs. Good functions use PARAMETERS for input and RETURN for output—this makes them self-contained and predictable. You can test them in isolation!",
                "socraticHint": "If a function uses a global, can you know what it will do just by looking at its inputs?"
              }
            },
            {
              "key": "D",
              "text": "Never returns values",
              "isCorrect": false,
              "misconceptionId": "FUNC_NO_RETURN",
              "feedback": {
                "short": "Not quite! Return values are how functions communicate results.",
                "detailed": "Functions that return values are more versatile—you can use the result in other calculations, store it, or pass it to other functions. While some functions perform actions (like print), MOST should return a value to be useful.",
                "socraticHint": "How would you use a function's result in another calculation if it doesn't return anything?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Does one thing well with a descriptive name",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-9",
      "lessonNumber": 9,
      "lessonTitle": "Package\n\n### Q1: Vocabulary/Concepts\nWhat is the difference between `import math` and `from math import sqrt`?\nA) No difference\nB) First imports whole package, second imports specific function ✓\nC) First is faster, second is slower\nD) First is for advanced users only\n\n### Q2: Code Understanding\nWhat does `random.randint(1, 6)` return?\nA) Always 1\nB) Always 6\nC) A random integer between 1 and 6 (inclusive) ✓\nD) A random decimal between 1 and 6\n\n### Q3: Problem-Solving\nWhich package would you use for mathematical calculations?\nA) random\nB) math ✓\nC) time\nD) os\n\n### Q4: Application\nHow would you convert 75°F to Celsius using Python?\nA) celsius = (75 - 32) * 5/9 ✓\nB) celsius = 75 * 9/5 + 32\nC) celsius = 75 - 32\nD) celsius = 75 + 32\n\n### Q5: Reflection/Meta-learning\nWhy are packages useful in Python?\nA) They make code longer\nB) They provide pre-written, tested functionality ✓\nC) They are required for all programs\nD) They slow down execution\n\n---",
      "lessonSlug": "package-q1-vocabularyconcepts-what-is-the-difference-between-import-math-and-from-math-import-sqrt-a-no-difference-b-first-imports-whole-package-second-imports-specific-function-c-first-is-faster-second-is-slower-d-first-is-for-advanced-users-only-q2-code-understanding-what-does-randomrandint1-6-return-a-always-1-b-always-6-c-a-random-integer-between-1-and-6-inclusive-d-a-random-decimal-between-1-and-6-q3-problem-solving-which-package-would-you-use-for-mathematical-calculations-a-random-b-math-c-time-d-os-q4-application-how-would-you-convert-75f-to-celsius-using-python-a-celsius-75-32-59-b-celsius-75-95-32-c-celsius-75-32-d-celsius-75-32-q5-reflectionmeta-learning-why-are-packages-useful-in-python-a-they-make-code-longer-b-they-provide-pre-written-tested-functionality-c-they-are-required-for-all-programs-d-they-slow-down-execution",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l9-q1",
          "globalId": "exit-ticket-0391",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "What is the difference between `import math` and `from math import sqrt`?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "IMPORT_EQUIVALENCE",
            "IMPORT_PERFORMANCE_MYTH",
            "IMPORT_SKILL_LEVEL"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "No difference",
              "isCorrect": false,
              "misconceptionId": "IMPORT_EQUIVALENCE",
              "feedback": {
                "short": "Not quite! The syntax affects what you can access and how.",
                "detailed": "These imports work differently: `import math` → use `math.sqrt()`. `from math import sqrt` → use `sqrt()` directly. The first gives access to ALL math functions, the second imports only what you specify.",
                "socraticHint": "After `import math`, can you use `sqrt(4)` directly, or do you need `math.sqrt(4)`?"
              }
            },
            {
              "key": "B",
              "text": "First imports whole package, second imports specific function",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! `import X` gets everything; `from X import Y` gets only Y.",
                "detailed": "`import math` brings in the entire module—access via math.sqrt(), math.pi, etc. `from math import sqrt` brings only sqrt into your namespace—use directly as sqrt(). Choose based on whether you need many functions or just a few."
              }
            },
            {
              "key": "C",
              "text": "First is faster, second is slower",
              "isCorrect": false,
              "misconceptionId": "IMPORT_PERFORMANCE_MYTH",
              "feedback": {
                "short": "Not quite! Import performance difference is negligible.",
                "detailed": "Both import methods have essentially the same performance. The difference is about NAMESPACE organization and CONVENIENCE, not speed. Python imports are cached, so repeated imports don't reload the module.",
                "socraticHint": "When would you prefer typing `sqrt(4)` vs `math.sqrt(4)`?"
              }
            },
            {
              "key": "D",
              "text": "First is for advanced users only",
              "isCorrect": false,
              "misconceptionId": "IMPORT_SKILL_LEVEL",
              "feedback": {
                "short": "Not quite! Both are standard Python—choose based on your needs.",
                "detailed": "Both import styles are used by beginners and experts alike. The choice depends on: (1) How many functions you need, (2) Whether you want to avoid name conflicts, (3) Personal/team preference for code readability.",
                "socraticHint": "If you only need one function from a module, which style is more convenient?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "First imports whole package, second imports specific function",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l9-q2",
          "globalId": "exit-ticket-0392",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "prompt": "What does `random.randint(1, 6)` return?",
          "questionArchetype": "trace",
          "misconceptionTargets": [
            "RANDOM_DETERMINISTIC",
            "RANDOM_INT_VS_FLOAT"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "Always 1",
              "isCorrect": false,
              "misconceptionId": "RANDOM_DETERMINISTIC",
              "feedback": {
                "short": "Not quite! 'Random' means the result varies each time.",
                "detailed": "random.randint(1, 6) returns a DIFFERENT value each time you call it—that's what 'random' means! It could be 1, 2, 3, 4, 5, or 6. The first argument isn't 'always' returned; it's just the minimum possible value.",
                "socraticHint": "If it always returned 1, why would we call it 'random'?"
              }
            },
            {
              "key": "B",
              "text": "Always 6",
              "isCorrect": false,
              "misconceptionId": "RANDOM_DETERMINISTIC",
              "feedback": {
                "short": "Not quite! The result changes unpredictably each call.",
                "detailed": "Like rolling a die, random.randint(1, 6) gives different results each time. The second argument (6) is the maximum, not a fixed return value. You might get 1, 2, 3, 4, 5, OR 6—equally likely.",
                "socraticHint": "When you roll a 6-sided die, do you always get 6?"
              }
            },
            {
              "key": "C",
              "text": "A random integer between 1 and 6 (inclusive)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! randint returns a random whole number including both endpoints.",
                "detailed": "random.randint(a, b) returns a random INTEGER where a ≤ result ≤ b. Both endpoints are INCLUDED (unlike range()!). This simulates dice, coin flips, and other random selections. Each call gives a new random value."
              }
            },
            {
              "key": "D",
              "text": "A random decimal between 1 and 6",
              "isCorrect": false,
              "misconceptionId": "RANDOM_INT_VS_FLOAT",
              "feedback": {
                "short": "Not quite! 'randint' specifically returns integers.",
                "detailed": "The 'int' in 'randint' means INTEGER—whole numbers only (1, 2, 3, 4, 5, 6). For random decimals, use random.uniform(1, 6) which could return 3.14159... or any float in the range.",
                "socraticHint": "What does 'int' in 'randint' suggest about the return type?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "A random integer between 1 and 6 (inclusive)",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l9-q3",
          "globalId": "exit-ticket-0393",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "prompt": "Which package would you use for mathematical calculations?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "PKG_PURPOSE_CONFUSION"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "random",
              "isCorrect": false,
              "misconceptionId": "PKG_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! 'random' is for randomness, not general math.",
                "detailed": "The random module generates random numbers (dice rolls, shuffling). For mathematical operations like sqrt(), sin(), log(), or constants like pi, use the math module. Each module has a specific purpose!",
                "socraticHint": "Would you use 'random' to calculate the square root of 16?"
              }
            },
            {
              "key": "B",
              "text": "math",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! The math module provides mathematical functions and constants.",
                "detailed": "math includes: sqrt(), sin(), cos(), log(), floor(), ceil(), pi, e, and more. It's Python's standard library for mathematical operations. For even more advanced math (matrices, statistics), see NumPy and SciPy."
              }
            },
            {
              "key": "C",
              "text": "time",
              "isCorrect": false,
              "misconceptionId": "PKG_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! 'time' is for time operations, not math.",
                "detailed": "The time module handles time-related operations: getting current time, pausing execution (sleep), measuring elapsed time. For mathematical calculations, use math.",
                "socraticHint": "What would you use time.sleep(5) for?"
              }
            },
            {
              "key": "D",
              "text": "os",
              "isCorrect": false,
              "misconceptionId": "PKG_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! 'os' is for operating system interactions.",
                "detailed": "The os module interacts with your computer's operating system: file paths, environment variables, running commands. For mathematical functions, use math. Package names often hint at their purpose!",
                "socraticHint": "What does 'os' stand for?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "math",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l9-q4",
          "globalId": "exit-ticket-0394",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "prompt": "How would you convert 75°F to Celsius using Python?",
          "questionArchetype": "blockmodel",
          "misconceptionTargets": [
            "FORMULA_DIRECTION_REVERSAL",
            "FORMULA_INCOMPLETE"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "celsius = (75 - 32) * 5/9",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Subtract 32 first, then multiply by 5/9.",
                "detailed": "The F→C formula: C = (F - 32) × 5/9. Steps: (1) Subtract 32 to adjust for different zero points, (2) Multiply by 5/9 to convert the scale. 75°F = (75-32) × 5/9 = 43 × 0.556 ≈ 23.9°C."
              }
            },
            {
              "key": "B",
              "text": "celsius = 75 * 9/5 + 32",
              "isCorrect": false,
              "misconceptionId": "FORMULA_DIRECTION_REVERSAL",
              "feedback": {
                "short": "Not quite! That's the Celsius TO Fahrenheit formula!",
                "detailed": "You've got the formula backwards. F = C × 9/5 + 32 converts Celsius to Fahrenheit. For F→C, you need to REVERSE the operations: subtract 32, then multiply by 5/9 (not 9/5).",
                "socraticHint": "If you apply this formula to 0°C, what would you get? Does that make sense?"
              }
            },
            {
              "key": "C",
              "text": "celsius = 75 - 32",
              "isCorrect": false,
              "misconceptionId": "FORMULA_INCOMPLETE",
              "feedback": {
                "short": "Not quite! You also need to scale by 5/9.",
                "detailed": "Subtracting 32 is only HALF the conversion. You also need to multiply by 5/9 because Fahrenheit degrees are smaller than Celsius degrees. The full formula: (F - 32) × 5/9.",
                "socraticHint": "Why do we need 5/9? What does that scaling represent?"
              }
            },
            {
              "key": "D",
              "text": "celsius = 75 + 32",
              "isCorrect": false,
              "misconceptionId": "FORMULA_DIRECTION_REVERSAL",
              "feedback": {
                "short": "Not quite! That would make the result higher, not lower.",
                "detailed": "75°F is about 24°C—the Celsius value should be LOWER. Adding 32 makes it higher (107), which is backwards. The correct formula subtracts 32 and scales down. Think: Celsius numbers are typically smaller than Fahrenheit for the same temperature.",
                "socraticHint": "Is 75°F warmer or cooler than 107°C?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "celsius = (75 - 32) * 5/9",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l9-q5",
          "globalId": "exit-ticket-0395",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "prompt": "Why are packages useful in Python?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "PKG_OVERHEAD_MYTH",
            "PKG_REQUIREMENT_MYTH"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "They make code longer",
              "isCorrect": false,
              "misconceptionId": "PKG_OVERHEAD_MYTH",
              "feedback": {
                "short": "Not quite! Packages actually make your code SHORTER.",
                "detailed": "Packages save you from writing code yourself. Instead of 50 lines to implement sqrt(), you write `import math` and use `math.sqrt()`. One import line gives access to many pre-built functions, making your code shorter AND more reliable.",
                "socraticHint": "Would you rather write 1 line to import math, or 50 lines to implement sqrt yourself?"
              }
            },
            {
              "key": "B",
              "text": "They provide pre-written, tested functionality",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Packages are reusable, tested code libraries.",
                "detailed": "Packages are collections of pre-written, debugged, and optimized code. Benefits: (1) Don't reinvent the wheel, (2) Code tested by thousands of users, (3) Often faster than DIY implementations. Python's ecosystem has packages for almost everything!"
              }
            },
            {
              "key": "C",
              "text": "They are required for all programs",
              "isCorrect": false,
              "misconceptionId": "PKG_REQUIREMENT_MYTH",
              "feedback": {
                "short": "Not quite! Simple programs work fine without packages.",
                "detailed": "You CAN write programs without importing any packages—Python's built-in features (print, if, for, lists) are always available. Packages are OPTIONAL tools that add specialized functionality. Many simple scripts need no imports.",
                "socraticHint": "Could you write a 'Hello World' program without importing anything?"
              }
            },
            {
              "key": "D",
              "text": "They slow down execution",
              "isCorrect": false,
              "misconceptionId": "PKG_OVERHEAD_MYTH",
              "feedback": {
                "short": "Not quite! Many packages actually SPEED UP execution.",
                "detailed": "Packages like NumPy are written in optimized C code—they're often FASTER than pure Python. While there's a tiny import overhead at startup, the functions themselves are typically faster and better optimized than homegrown solutions.",
                "socraticHint": "Would your hand-written sqrt function be faster than math.sqrt()?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "They provide pre-written, tested functionality",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-10",
      "lessonNumber": 10,
      "lessonTitle": "Numpy\n\n### Q1: Vocabulary/Concepts\nWhy is NumPy faster than regular Python lists for mathematical operations?\nA) It uses more memory\nB) It uses optimized C code and operates on entire arrays at once ✓\nC) It has better graphics\nD) It's newer than lists\n\n### Q2: Code Understanding\nWhat does `arr * 3` do to the array `[2, 4, 6]`?\nA) Adds 3 to each element\nB) Multiplies each element by 3 ✓\nC) Repeats the array 3 times\nD) Divides each element by 3\n\n### Q3: Problem-Solving\nHow do you create a 2D NumPy array with 3 rows and 4 columns of random integers?\nA) `np.random.randint(1, 101, size=(3, 4))` ✓\nB) `np.array(3, 4)`\nC) `np.random(3, 4)`\nD) `np.create(3, 4)`\n\n### Q4: Application\nHow would you calculate the average of each class from a 2D array of test scores?\nA) `np.mean(scores, axis=0)`\nB) `np.mean(scores, axis=1)` ✓\nC) `np.average(scores)`\nD) `scores.mean()`\n\n### Q5: Reflection/Meta-learning\nWhat is \"vectorized operations\" in NumPy?\nA) Creating vector graphics\nB) Operating on entire arrays instead of individual elements ✓\nC) Using vectors for storage\nD) Converting lists to arrays\n\n---",
      "lessonSlug": "numpy-q1-vocabularyconcepts-why-is-numpy-faster-than-regular-python-lists-for-mathematical-operations-a-it-uses-more-memory-b-it-uses-optimized-c-code-and-operates-on-entire-arrays-at-once-c-it-has-better-graphics-d-its-newer-than-lists-q2-code-understanding-what-does-arr-3-do-to-the-array-2-4-6-a-adds-3-to-each-element-b-multiplies-each-element-by-3-c-repeats-the-array-3-times-d-divides-each-element-by-3-q3-problem-solving-how-do-you-create-a-2d-numpy-array-with-3-rows-and-4-columns-of-random-integers-a-nprandomrandint1-101-size3-4-b-nparray3-4-c-nprandom3-4-d-npcreate3-4-q4-application-how-would-you-calculate-the-average-of-each-class-from-a-2d-array-of-test-scores-a-npmeanscores-axis0-b-npmeanscores-axis1-c-npaveragescores-d-scoresmean-q5-reflectionmeta-learning-what-is-vectorized-operations-in-numpy-a-creating-vector-graphics-b-operating-on-entire-arrays-instead-of-individual-elements-c-using-vectors-for-storage-d-converting-lists-to-arrays",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l10-q1",
          "globalId": "exit-ticket-0396",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "prompt": "Why is NumPy faster than regular Python lists for mathematical operations?",
          "questionArchetype": "vocabulary",
          "misconceptionTargets": [
            "NUMPY_MEMORY_SPEED",
            "NUMPY_PURPOSE_CONFUSION",
            "NUMPY_AGE_SPEED"
          ],
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "options": [
            {
              "key": "A",
              "text": "It uses more memory",
              "isCorrect": false,
              "misconceptionId": "NUMPY_MEMORY_SPEED",
              "feedback": {
                "short": "Not quite! More memory doesn't equal faster execution.",
                "detailed": "NumPy is fast because of HOW it uses memory (contiguous blocks, typed arrays), not because it uses MORE. In fact, NumPy arrays are often more memory-efficient than Python lists for numeric data. Speed comes from optimization, not size.",
                "socraticHint": "Would doubling your RAM make your code run twice as fast?"
              }
            },
            {
              "key": "B",
              "text": "It uses optimized C code and operates on entire arrays at once",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! NumPy uses compiled C code + vectorized operations.",
                "detailed": "NumPy is fast for two reasons: (1) Core operations are written in optimized C, not interpreted Python. (2) Vectorized operations process entire arrays at once, avoiding slow Python loops. This 'all at once' approach is called SIMD (Single Instruction, Multiple Data)."
              }
            },
            {
              "key": "C",
              "text": "It has better graphics",
              "isCorrect": false,
              "misconceptionId": "NUMPY_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! NumPy is for numerical computing, not graphics.",
                "detailed": "NumPy handles numerical arrays and mathematical operations—no graphics involved. For graphics/plotting, you'd use Matplotlib (which builds ON NumPy). NumPy's speed comes from optimized math, not visual capabilities.",
                "socraticHint": "What does 'Num' in NumPy suggest about its purpose?"
              }
            },
            {
              "key": "D",
              "text": "It's newer than lists",
              "isCorrect": false,
              "misconceptionId": "NUMPY_AGE_SPEED",
              "feedback": {
                "short": "Not quite! Age doesn't determine speed.",
                "detailed": "Python lists existed before NumPy, but that's irrelevant to performance. NumPy is faster because of DESIGN choices (C implementation, typed arrays, vectorization), not because it's newer. Older code can be faster than newer code if designed well.",
                "socraticHint": "Is newer software always faster than older software?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "It uses optimized C code and operates on entire arrays at once",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "numpy",
              "data-science"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l10-q2",
          "globalId": "exit-ticket-0397",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What does `arr * 3` do to the array `[2, 4, 6]`?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "OP_OPERATOR_SYMBOL_CONFUSION",
            "NUMPY_LIST_BROADCAST"
          ],
          "options": [
            {
              "key": "A",
              "text": "Adds 3 to each element",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! The `*` operator means multiply, not add.",
                "detailed": "In NumPy (and Python), the `*` symbol always means multiplication. You're thinking of `+` which adds. `arr * 3` multiplies each element: [2*3, 4*3, 6*3] = [6, 12, 18].",
                "socraticHint": "What math operation does the asterisk (*) symbol represent?"
              }
            },
            {
              "key": "B",
              "text": "Multiplies each element by 3",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Repeats the array 3 times",
              "isCorrect": false,
              "misconceptionId": "NUMPY_LIST_BROADCAST",
              "feedback": {
                "short": "Not quite! That's what Python lists do, not NumPy arrays.",
                "detailed": "This is a key difference between NumPy and Python lists! With a Python list, `[2,4,6] * 3` would give `[2,4,6,2,4,6,2,4,6]` (repetition). But NumPy does element-wise math: `arr * 3` multiplies each element, giving [6, 12, 18].",
                "socraticHint": "How does NumPy's approach to math operations differ from Python lists?"
              }
            },
            {
              "key": "D",
              "text": "Divides each element by 3",
              "isCorrect": false,
              "misconceptionId": "OP_OPERATOR_SYMBOL_CONFUSION",
              "feedback": {
                "short": "Not quite! The `*` operator means multiply, not divide.",
                "detailed": "You've confused the operators: `*` means multiplication, `/` means division. `arr * 3` multiplies each element by 3: [2*3, 4*3, 6*3] = [6, 12, 18]. Division would use `arr / 3`.",
                "socraticHint": "Which symbol represents division in Python?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Multiplies each element by 3",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "numpy",
              "broadcasting"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l10-q3",
          "globalId": "exit-ticket-0398",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "vocabulary",
          "prompt": "How do you create a 2D NumPy array with 3 rows and 4 columns of random integers?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "NUMPY_ARRAY_CONSTRUCTOR",
            "MODULE_AS_FUNCTION",
            "API_HALLUCINATION"
          ],
          "options": [
            {
              "key": "A",
              "text": "`np.random.randint(1, 101, size=(3, 4))`",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "`np.array(3, 4)`",
              "isCorrect": false,
              "misconceptionId": "NUMPY_ARRAY_CONSTRUCTOR",
              "feedback": {
                "short": "Not quite! `np.array()` wraps existing data, it doesn't create a shape.",
                "detailed": "`np.array()` converts an existing list or sequence into an array—it doesn't accept dimensions as arguments. To create arrays with specific shapes, use `np.zeros((3,4))`, `np.ones((3,4))`, or `np.random.randint(low, high, size=(3,4))`.",
                "socraticHint": "What do you normally pass to `np.array()`—dimensions or actual data?"
              }
            },
            {
              "key": "C",
              "text": "`np.random(3, 4)`",
              "isCorrect": false,
              "misconceptionId": "MODULE_AS_FUNCTION",
              "feedback": {
                "short": "Not quite! `np.random` is a module, not a function you can call.",
                "detailed": "In Python, `np.random` is a module (a container of functions), not a callable function. You need to call a specific function inside it, like `np.random.randint()`, `np.random.rand()`, or `np.random.random()`. The pattern is `module.function()`, not `module()`.",
                "socraticHint": "What's the difference between a Python module and a function?"
              }
            },
            {
              "key": "D",
              "text": "`np.create(3, 4)`",
              "isCorrect": false,
              "misconceptionId": "API_HALLUCINATION",
              "feedback": {
                "short": "Not quite! `np.create()` doesn't exist in NumPy.",
                "detailed": "NumPy doesn't have a `create()` function. To create arrays, use real NumPy functions: `np.zeros()`, `np.ones()`, `np.empty()`, `np.arange()`, or `np.random.randint()`. When unsure, check the documentation or use `dir(np)` to see available functions.",
                "socraticHint": "How can you verify which functions actually exist in a Python library?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "`np.random.randint(1, 101, size=(3, 4))`",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "numpy",
              "array-creation"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l10-q4",
          "globalId": "exit-ticket-0399",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "blockmodel",
          "prompt": "How would you calculate the average of each class from a 2D array of test scores?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "NUMPY_AXIS_DIRECTION",
            "NUMPY_FLATTEN_DEFAULT"
          ],
          "options": [
            {
              "key": "A",
              "text": "`np.mean(scores, axis=0)`",
              "isCorrect": false,
              "misconceptionId": "NUMPY_AXIS_DIRECTION",
              "feedback": {
                "short": "Not quite! `axis=0` operates DOWN columns, giving per-student averages.",
                "detailed": "If each row is a class and each column is a student, `axis=0` averages DOWN each column—giving you one average per student (across all classes). For per-class averages, use `axis=1` which averages ACROSS each row.",
                "socraticHint": "If you have a grid, does axis=0 collapse rows or columns?"
              }
            },
            {
              "key": "B",
              "text": "`np.mean(scores, axis=1)`",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "`np.average(scores)`",
              "isCorrect": false,
              "misconceptionId": "NUMPY_FLATTEN_DEFAULT",
              "feedback": {
                "short": "Not quite! Without an axis, this gives ONE number for the entire array.",
                "detailed": "When you omit the axis parameter, NumPy flattens the entire 2D array into 1D and computes a single average of ALL scores. That's one number, not one per class. Use `axis=1` to get one average per row (per class).",
                "socraticHint": "What happens to a 2D array when you don't specify which dimension to aggregate?"
              }
            },
            {
              "key": "D",
              "text": "`scores.mean()`",
              "isCorrect": false,
              "misconceptionId": "NUMPY_FLATTEN_DEFAULT",
              "feedback": {
                "short": "Not quite! `.mean()` without axis gives ONE number for the entire array.",
                "detailed": "Like `np.average(scores)`, calling `.mean()` without an axis flattens all values and returns a single average. To get per-class averages, use `scores.mean(axis=1)` or `np.mean(scores, axis=1)`.",
                "socraticHint": "How do you tell NumPy to aggregate per-row instead of the whole array?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "`np.mean(scores, axis=1)`",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "numpy",
              "axis-parameter"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l10-q5",
          "globalId": "exit-ticket-0400",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "What is \"vectorized operations\" in NumPy?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "TERM_CROSS_DOMAIN"
          ],
          "options": [
            {
              "key": "A",
              "text": "Creating vector graphics",
              "isCorrect": false,
              "misconceptionId": "TERM_CROSS_DOMAIN",
              "feedback": {
                "short": "Not quite! This 'vector' has nothing to do with graphics.",
                "detailed": "The word 'vector' means different things in different fields. In graphics, vectors are shapes with direction. In NumPy, 'vectorized' means operating on entire arrays at once instead of looping through elements. It's about efficiency, not drawing!",
                "socraticHint": "What does 'vectorized' save you from doing when working with arrays?"
              }
            },
            {
              "key": "B",
              "text": "Operating on entire arrays instead of individual elements",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Using vectors for storage",
              "isCorrect": false,
              "misconceptionId": "TERM_CROSS_DOMAIN",
              "feedback": {
                "short": "Not quite! Vectorized operations are about computation, not storage.",
                "detailed": "You might be thinking of the math definition of 'vector' (a 1D array for storage). But 'vectorized operations' in NumPy refers to HOW operations are performed—on entire arrays at once, eliminating the need for Python loops. It's an efficiency technique.",
                "socraticHint": "What's the alternative to vectorized operations—what would you do instead?"
              }
            },
            {
              "key": "D",
              "text": "Converting lists to arrays",
              "isCorrect": false,
              "misconceptionId": "TERM_CROSS_DOMAIN",
              "feedback": {
                "short": "Not quite! That's array creation, not vectorization.",
                "detailed": "Converting a list to an array is done with `np.array()`. 'Vectorized operations' refers to something different: performing calculations on ALL array elements simultaneously, without writing explicit loops. For example, `arr * 2` multiplies every element at once.",
                "socraticHint": "After you have an array, how do you do math on every element without a loop?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Operating on entire arrays instead of individual elements",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "numpy",
              "vectorization"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-11",
      "lessonNumber": 11,
      "lessonTitle": "Descriptive Statistics\n\n### Q1: Vocabulary/Concepts\nWhat does standard deviation measure?\nA) The average value\nB) The middle value\nC) How spread out data is from the mean ✓\nD) The most common value\n\n### Q2: Code Understanding\nFor the data [10, 15, 15, 15, 20, 25, 30], what is the mode?\nA) 10\nB) 15 ✓\nC) 18.57\nD) 30\n\n### Q3: Problem-Solving\nHow do you identify outliers using standard deviation?\nA) Values more than 1 standard deviation from mean\nB) Values more than 2 standard deviations from mean ✓\nC) Values equal to the mean\nD) The highest and lowest values\n\n### Q4: Application\nWhat would be most useful for a sales manager analyzing monthly performance?\nA) Only the mean\nB) Mean, median, range, and standard deviation ✓\nC) Only the maximum value\nD) Only the minimum value\n\n### Q5: Reflection/Meta-learning\nWhy use median instead of mean for skewed data?\nA) Median is always larger\nB) Median is not affected by extreme values ✓\nC) Mean is too complicated\nD) Median is faster to calculate\n\n---",
      "lessonSlug": "descriptive-statistics-q1-vocabularyconcepts-what-does-standard-deviation-measure-a-the-average-value-b-the-middle-value-c-how-spread-out-data-is-from-the-mean-d-the-most-common-value-q2-code-understanding-for-the-data-10-15-15-15-20-25-30-what-is-the-mode-a-10-b-15-c-1857-d-30-q3-problem-solving-how-do-you-identify-outliers-using-standard-deviation-a-values-more-than-1-standard-deviation-from-mean-b-values-more-than-2-standard-deviations-from-mean-c-values-equal-to-the-mean-d-the-highest-and-lowest-values-q4-application-what-would-be-most-useful-for-a-sales-manager-analyzing-monthly-performance-a-only-the-mean-b-mean-median-range-and-standard-deviation-c-only-the-maximum-value-d-only-the-minimum-value-q5-reflectionmeta-learning-why-use-median-instead-of-mean-for-skewed-data-a-median-is-always-larger-b-median-is-not-affected-by-extreme-values-c-mean-is-too-complicated-d-median-is-faster-to-calculate",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l11-q1",
          "globalId": "exit-ticket-0401",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What does standard deviation measure?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "STATS_MEASURE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "The average value",
              "isCorrect": false,
              "misconceptionId": "STATS_MEASURE_CONFUSION",
              "feedback": {
                "short": "Not quite! That's the mean, not standard deviation.",
                "detailed": "You're thinking of the mean (average). Standard deviation measures something different—how SPREAD OUT the data is from that mean. A low std dev means data clusters near the mean; a high std dev means data is scattered.",
                "socraticHint": "If all values were exactly the same, what would the standard deviation be?"
              }
            },
            {
              "key": "B",
              "text": "The middle value",
              "isCorrect": false,
              "misconceptionId": "STATS_MEASURE_CONFUSION",
              "feedback": {
                "short": "Not quite! That's the median, not standard deviation.",
                "detailed": "The middle value when data is sorted is the median. Standard deviation measures spread—how far data points typically are from the mean. Think of it as measuring 'how much variation' exists in your data.",
                "socraticHint": "What does 'deviation' mean in everyday English?"
              }
            },
            {
              "key": "C",
              "text": "How spread out data is from the mean",
              "isCorrect": true
            },
            {
              "key": "D",
              "text": "The most common value",
              "isCorrect": false,
              "misconceptionId": "STATS_MODE_VS_MEAN",
              "feedback": {
                "short": "Not quite! That's the mode, not standard deviation.",
                "detailed": "The most frequently occurring value is the mode. Standard deviation measures SPREAD—how far values typically deviate from the average. Example: [5,5,5] has std dev = 0 (no spread), while [1,5,9] has higher std dev.",
                "socraticHint": "Can you have the same mode but different amounts of spread?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "How spread out data is from the mean",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "statistics",
              "standard-deviation"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l11-q2",
          "globalId": "exit-ticket-0402",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "For the data [10, 15, 15, 15, 20, 25, 30], what is the mode?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "STATS_MODE_VS_MEAN",
            "STATS_OUTLIER_DEFINITION"
          ],
          "options": [
            {
              "key": "A",
              "text": "10",
              "isCorrect": false,
              "misconceptionId": "STATS_OUTLIER_DEFINITION",
              "feedback": {
                "short": "Not quite! 10 is the minimum value, not the mode.",
                "detailed": "You picked the smallest value. The mode is the MOST FREQUENT value—the one that appears the most times. Count how often each number appears: 10 appears 1 time, 15 appears 3 times, 20 appears 1 time, etc.",
                "socraticHint": "Which number appears more than once in this dataset?"
              }
            },
            {
              "key": "B",
              "text": "15",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "18.57",
              "isCorrect": false,
              "misconceptionId": "STATS_MODE_VS_MEAN",
              "feedback": {
                "short": "Not quite! That's the mean (average), not the mode.",
                "detailed": "You calculated the mean: (10+15+15+15+20+25+30)/7 ≈ 18.57. But the mode is different—it's the value that appears MOST OFTEN. Look at the data: which number repeats? 15 appears three times, more than any other value.",
                "socraticHint": "What does 'mode' measure—frequency or average?"
              }
            },
            {
              "key": "D",
              "text": "30",
              "isCorrect": false,
              "misconceptionId": "STATS_OUTLIER_DEFINITION",
              "feedback": {
                "short": "Not quite! 30 is the maximum value, not the mode.",
                "detailed": "You picked the largest value. The mode isn't about size—it's about FREQUENCY. Which value appears most often? Count: 15 appears 3 times while 30 appears only once. The mode is the most common value.",
                "socraticHint": "How many times does 30 appear vs. how many times does 15 appear?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "15",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "statistics",
              "mode"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l11-q3",
          "globalId": "exit-ticket-0403",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "vocabulary",
          "prompt": "How do you identify outliers using standard deviation?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "STATS_OUTLIER_THRESHOLD",
            "STATS_OUTLIER_DEFINITION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Values more than 1 standard deviation from mean",
              "isCorrect": false,
              "misconceptionId": "STATS_OUTLIER_THRESHOLD",
              "feedback": {
                "short": "Not quite! 1 std dev is too strict—that would flag ~32% of normal data!",
                "detailed": "In a normal distribution, about 68% of data falls within 1 standard deviation. Using this threshold would label nearly a third of your data as outliers! The standard convention is 2+ standard deviations (only ~5% of normal data), or sometimes 3 for stricter filtering.",
                "socraticHint": "What percentage of data typically falls within 1 standard deviation?"
              }
            },
            {
              "key": "B",
              "text": "Values more than 2 standard deviations from mean",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Values equal to the mean",
              "isCorrect": false,
              "misconceptionId": "STATS_OUTLIER_DEFINITION",
              "feedback": {
                "short": "Not quite! Values AT the mean are the LEAST likely to be outliers.",
                "detailed": "Outliers are values that are UNUSUALLY FAR from the center, not at the center. A value equal to the mean is perfectly typical—it's the definition of 'average.' Outliers deviate significantly (2+ std dev) from this central point.",
                "socraticHint": "What does 'outlier' mean in everyday language—typical or unusual?"
              }
            },
            {
              "key": "D",
              "text": "The highest and lowest values",
              "isCorrect": false,
              "misconceptionId": "STATS_OUTLIER_DEFINITION",
              "feedback": {
                "short": "Not quite! Extreme values aren't automatically outliers.",
                "detailed": "Every dataset has a maximum and minimum, but they're not automatically outliers. Outliers are STATISTICALLY unusual—typically 2+ standard deviations from the mean. A dataset [1,2,3,4,5] has no outliers even though 1 and 5 are the extremes.",
                "socraticHint": "If I have test scores [85, 87, 88, 90, 92], are 85 and 92 outliers?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Values more than 2 standard deviations from mean",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "statistics",
              "outliers"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l11-q4",
          "globalId": "exit-ticket-0404",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "What would be most useful for a sales manager analyzing monthly performance?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "STATS_SINGLE_METRIC"
          ],
          "options": [
            {
              "key": "A",
              "text": "Only the mean",
              "isCorrect": false,
              "misconceptionId": "STATS_SINGLE_METRIC",
              "feedback": {
                "short": "Not quite! The mean alone hides important details.",
                "detailed": "Mean tells you the average, but not the full story. Two teams could have the same mean sales but very different patterns: one consistent, one volatile. You'd miss months with unusually high/low performance, the typical (median) performance, and how consistent the team is (standard deviation).",
                "socraticHint": "If one month was exceptionally bad, would the mean alone tell you that?"
              }
            },
            {
              "key": "B",
              "text": "Mean, median, range, and standard deviation",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Only the maximum value",
              "isCorrect": false,
              "misconceptionId": "STATS_SINGLE_METRIC",
              "feedback": {
                "short": "Not quite! Best performance doesn't tell you about consistency.",
                "detailed": "The max shows your best month, but says nothing about typical performance or consistency. A team that hit $1M once but averages $100K isn't as reliable as one that consistently hits $500K. You need multiple metrics for the complete picture.",
                "socraticHint": "Would you judge an employee only by their single best day?"
              }
            },
            {
              "key": "D",
              "text": "Only the minimum value",
              "isCorrect": false,
              "misconceptionId": "STATS_SINGLE_METRIC",
              "feedback": {
                "short": "Not quite! Worst performance doesn't tell the whole story.",
                "detailed": "The minimum shows your worst month, but ignores everything else. A team that had one bad month during a crisis but normally performs well is different from a team that's consistently underperforming. Multiple statistics reveal the true pattern.",
                "socraticHint": "Should a single bad month define a team's overall performance?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Mean, median, range, and standard deviation",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "statistics",
              "business-application"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l11-q5",
          "globalId": "exit-ticket-0405",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why use median instead of mean for skewed data?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_MEAN_VS_MEDIAN",
            "FEATURE_AVOIDANCE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Median is always larger",
              "isCorrect": false,
              "misconceptionId": "DATA_MEAN_VS_MEDIAN",
              "feedback": {
                "short": "Not quite! Median can be smaller, larger, or equal to the mean.",
                "detailed": "The relationship between median and mean depends on the data shape. In right-skewed data (like income), mean > median. In left-skewed data, mean < median. In symmetric data, they're equal. The reason to use median is its RESISTANCE to outliers, not its size.",
                "socraticHint": "What happens to the mean if one person in a room earns $1 billion?"
              }
            },
            {
              "key": "B",
              "text": "Median is not affected by extreme values",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Mean is too complicated",
              "isCorrect": false,
              "misconceptionId": "FEATURE_AVOIDANCE",
              "feedback": {
                "short": "Not quite! Mean is actually very simple (sum ÷ count).",
                "detailed": "The mean is straightforward: add all values, divide by count. Complexity isn't the issue. The problem is that extreme values PULL the mean toward them. If 9 people earn $50K and 1 earns $10M, the mean ($1.045M) misrepresents most people. Median ($50K) is more representative.",
                "socraticHint": "Which is easier: finding the middle or calculating an average?"
              }
            },
            {
              "key": "D",
              "text": "Median is faster to calculate",
              "isCorrect": false,
              "misconceptionId": "DATA_MEAN_VS_MEDIAN",
              "feedback": {
                "short": "Not quite! Mean is actually faster (just sum and divide).",
                "detailed": "For computers, mean is O(n) while median requires sorting first, which is O(n log n)—actually slower! We use median for ACCURACY with skewed data, not speed. The median resists being pulled by extreme outliers, giving a more representative 'center.'",
                "socraticHint": "Which requires more steps: adding numbers or sorting them?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Median is not affected by extreme values",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "statistics",
              "median-mean"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-12",
      "lessonNumber": 12,
      "lessonTitle": "PrettyTable\n\n### Q1: Vocabulary/Concepts\nWhat is the main advantage of PrettyTable over regular print statements?\nA) It's faster to execute\nB) It creates well-formatted, aligned tables ✓\nC) It uses less memory\nD) It can handle more data\n\n### Q2: Code Understanding\nWhat does this code create?\n```python\ntable = PrettyTable()\ntable.field_names = [\"Name\", \"Age\", \"Score\"]\ntable.add_row([\"Alice\", 20, 95])\n```\nA) A list of data\nB) A formatted table with headers and one row ✓\nC) A dictionary\nD) A database\n\n### Q3: Problem-Solving\nHow would you display student grades with calculated averages in a table?\nA) Use print statements only\nB) Create PrettyTable with columns for subjects and calculated average column ✓\nC) Use lists only\nD) Write to a file\n\n### Q4: Application\nWhen should you use PrettyTable instead of CSV files or graphs?\nA) For all data presentation\nB) For console reports and quick data reviews ✓\nC) For large datasets only\nD) Never, always use graphs\n\n### Q5: Reflection/Meta-learning\nHow does good data presentation affect communication?\nA) It doesn't matter how data looks\nB) Clear formatting makes data accessible and reduces misinterpretation ✓\nC) Pretty tables are just for decoration\nD) Only technical people need good formatting\n\n---",
      "lessonSlug": "prettytable-q1-vocabularyconcepts-what-is-the-main-advantage-of-prettytable-over-regular-print-statements-a-its-faster-to-execute-b-it-creates-well-formatted-aligned-tables-c-it-uses-less-memory-d-it-can-handle-more-data-q2-code-understanding-what-does-this-code-create-python-table-prettytable-tablefield_names-name-age-score-tableadd_rowalice-20-95-a-a-list-of-data-b-a-formatted-table-with-headers-and-one-row-c-a-dictionary-d-a-database-q3-problem-solving-how-would-you-display-student-grades-with-calculated-averages-in-a-table-a-use-print-statements-only-b-create-prettytable-with-columns-for-subjects-and-calculated-average-column-c-use-lists-only-d-write-to-a-file-q4-application-when-should-you-use-prettytable-instead-of-csv-files-or-graphs-a-for-all-data-presentation-b-for-console-reports-and-quick-data-reviews-c-for-large-datasets-only-d-never-always-use-graphs-q5-reflectionmeta-learning-how-does-good-data-presentation-affect-communication-a-it-doesnt-matter-how-data-looks-b-clear-formatting-makes-data-accessible-and-reduces-misinterpretation-c-pretty-tables-are-just-for-decoration-d-only-technical-people-need-good-formatting",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l12-q1",
          "globalId": "exit-ticket-0406",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the main advantage of PrettyTable over regular print statements?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PKG_PERFORMANCE_MYTH"
          ],
          "options": [
            {
              "key": "A",
              "text": "It's faster to execute",
              "isCorrect": false,
              "misconceptionId": "PKG_PERFORMANCE_MYTH",
              "feedback": {
                "short": "Not quite! Speed isn't PrettyTable's purpose.",
                "detailed": "PrettyTable actually adds processing overhead to create nice formatting. Its benefit is READABILITY, not speed. When you need to quickly understand tabular data in the console, aligned columns and borders make a huge difference—even if it takes a bit longer to render.",
                "socraticHint": "Would making output pretty usually be faster or slower than plain text?"
              }
            },
            {
              "key": "B",
              "text": "It creates well-formatted, aligned tables",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "It uses less memory",
              "isCorrect": false,
              "misconceptionId": "PKG_PERFORMANCE_MYTH",
              "feedback": {
                "short": "Not quite! PrettyTable actually uses MORE memory to store formatting.",
                "detailed": "PrettyTable creates additional data structures to track column widths, borders, and alignment. It uses more memory than raw print, not less. The tradeoff is worth it because the output is much easier to read and understand at a glance.",
                "socraticHint": "What extra information does PrettyTable need to store to align columns?"
              }
            },
            {
              "key": "D",
              "text": "It can handle more data",
              "isCorrect": false,
              "misconceptionId": "PKG_PERFORMANCE_MYTH",
              "feedback": {
                "short": "Not quite! Data capacity isn't PrettyTable's advantage.",
                "detailed": "Both print() and PrettyTable can handle the same amounts of data—they're limited by available memory, not the library choice. PrettyTable's strength is PRESENTATION: automatic column alignment, headers, borders, and consistent formatting across all rows.",
                "socraticHint": "What makes a table 'pretty' compared to printing raw data?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "It creates well-formatted, aligned tables",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "prettytable",
              "data-presentation"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l12-q2",
          "globalId": "exit-ticket-0407",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What does this code create?",
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "table = PrettyTable()\ntable.field_names = [\"Name\", \"Age\", \"Score\"]\ntable.add_row([\"Alice\", 20, 95])",
          "misconceptionTargets": [
            "DATA_STRUCTURE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "A list of data",
              "isCorrect": false,
              "misconceptionId": "DATA_STRUCTURE_CONFUSION",
              "feedback": {
                "short": "Not quite! PrettyTable creates a table object, not a list.",
                "detailed": "While PrettyTable uses lists internally (like [\"Alice\", 20, 95]), the result is a TABLE object with formatting, headers, and display capabilities. Lists are just raw data; PrettyTable adds structure with field_names (headers) and visual formatting.",
                "socraticHint": "What does `field_names` add that a plain list wouldn't have?"
              }
            },
            {
              "key": "B",
              "text": "A formatted table with headers and one row",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "A dictionary",
              "isCorrect": false,
              "misconceptionId": "DATA_STRUCTURE_CONFUSION",
              "feedback": {
                "short": "Not quite! Dictionaries use key-value pairs, not rows and columns.",
                "detailed": "A dictionary would look like {'Name': 'Alice', 'Age': 20}. PrettyTable creates a visual TABLE structure with headers (field_names) and rows (add_row). When printed, it displays with borders and alignment—something dictionaries can't do directly.",
                "socraticHint": "How would you display a dictionary with nice column alignment?"
              }
            },
            {
              "key": "D",
              "text": "A database",
              "isCorrect": false,
              "misconceptionId": "DATA_STRUCTURE_CONFUSION",
              "feedback": {
                "short": "Not quite! Databases persist data to disk; PrettyTable is just for display.",
                "detailed": "Databases (like SQLite) store data permanently on disk and support queries. PrettyTable is an in-memory display tool—when your program ends, the table disappears. It's for PRESENTING data nicely, not for storing it long-term.",
                "socraticHint": "Where does PrettyTable data go when your program ends?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "A formatted table with headers and one row",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "prettytable",
              "python"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l12-q3",
          "globalId": "exit-ticket-0408",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "bebras",
          "prompt": "How would you display student grades with calculated averages in a table?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "TOOL_PURPOSE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Use print statements only",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Print statements can't automatically align columns.",
                "detailed": "Raw print() requires manual spacing and doesn't adapt to different data lengths. If 'Mathematics' is longer than 'Art,' your columns will be misaligned. PrettyTable automatically calculates widths and aligns everything perfectly.",
                "socraticHint": "How would you make columns align if some student names are longer than others?"
              }
            },
            {
              "key": "B",
              "text": "Create PrettyTable with columns for subjects and calculated average column",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Use lists only",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Lists store data but don't format it for display.",
                "detailed": "Lists are great for storing grade data, but they print as [85, 90, 78]—not very readable! PrettyTable takes that list data and presents it with headers, alignment, and borders. Think: lists for STORAGE, PrettyTable for PRESENTATION.",
                "socraticHint": "What's the difference between storing data and displaying it nicely?"
              }
            },
            {
              "key": "D",
              "text": "Write to a file",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Files are for saving, not displaying.",
                "detailed": "Writing to a file saves data permanently but doesn't DISPLAY it. The question asks about displaying grades—showing them to users in a readable format. PrettyTable does this in the console. You could save PrettyTable output to a file, but that's a separate step.",
                "socraticHint": "If you write to a file, how would the user see the grades right now?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Create PrettyTable with columns for subjects and calculated average column",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "prettytable",
              "data-display"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l12-q4",
          "globalId": "exit-ticket-0409",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "When should you use PrettyTable instead of CSV files or graphs?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "TOOL_PURPOSE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "For all data presentation",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Each tool has its best use case.",
                "detailed": "Different tools serve different purposes: CSV files are for data exchange between programs; graphs show trends and comparisons visually; PrettyTable is for readable console output. Using the right tool for the job makes your work more effective.",
                "socraticHint": "Would a text table in the terminal be the best way to share data with Excel?"
              }
            },
            {
              "key": "B",
              "text": "For console reports and quick data reviews",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "For large datasets only",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Large datasets are actually harder to read in tables.",
                "detailed": "PrettyTable works best for small-to-medium datasets you can scan quickly. For large datasets (thousands of rows), tables become overwhelming—you'd want summary statistics, filtering, or visualizations. PrettyTable shines for quick, readable snapshots.",
                "socraticHint": "Would you want to scroll through 10,000 rows in a console table?"
              }
            },
            {
              "key": "D",
              "text": "Never, always use graphs",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Tables and graphs serve different purposes.",
                "detailed": "Graphs show trends and patterns visually, but tables show exact values. If you need to see 'Student A got 87 in Math,' a table is clearer than reading a bar chart. Each tool has its place—PrettyTable is perfect for detailed, readable data in the console.",
                "socraticHint": "How would you read an exact score of 87.5 from a bar chart?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "For console reports and quick data reviews",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "prettytable",
              "tool-selection"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l12-q5",
          "globalId": "exit-ticket-0410",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "How does good data presentation affect communication?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_PRESENTATION_DISMISSAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "It doesn't matter how data looks",
              "isCorrect": false,
              "misconceptionId": "DATA_PRESENTATION_DISMISSAL",
              "feedback": {
                "short": "Not quite! Presentation directly affects understanding.",
                "detailed": "Raw data like '87,92,78,85,90' is harder to parse than a labeled table. Studies show formatted data reduces reading errors and speeds comprehension. In data science, communication is half the job—if stakeholders can't understand your findings, they can't act on them.",
                "socraticHint": "Would you rather read a wall of numbers or a clearly labeled table?"
              }
            },
            {
              "key": "B",
              "text": "Clear formatting makes data accessible and reduces misinterpretation",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Pretty tables are just for decoration",
              "isCorrect": false,
              "misconceptionId": "DATA_PRESENTATION_DISMISSAL",
              "feedback": {
                "short": "Not quite! Good formatting serves a functional purpose.",
                "detailed": "Aligned columns, headers, and borders aren't decorative—they're functional. They help readers quickly find specific values, compare across rows, and understand relationships. A misread number in a financial report could mean a million-dollar mistake!",
                "socraticHint": "What could happen if someone misreads a number because the columns weren't aligned?"
              }
            },
            {
              "key": "D",
              "text": "Only technical people need good formatting",
              "isCorrect": false,
              "misconceptionId": "DATA_PRESENTATION_DISMISSAL",
              "feedback": {
                "short": "Not quite! Good formatting helps EVERYONE understand data.",
                "detailed": "Non-technical stakeholders (managers, clients, patients) often need to understand data findings. Clear presentation bridges the gap between data analysis and decision-making. In fact, less technical audiences benefit MOST from good formatting since they can't easily parse raw data.",
                "socraticHint": "Who makes business decisions based on data—only programmers?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Clear formatting makes data accessible and reduces misinterpretation",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "data-presentation",
              "communication"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-13",
      "lessonNumber": 13,
      "lessonTitle": "Data Visualization using Matplotlib\n\n### Q1: Vocabulary/Concepts\nWhat is data visualization and why is it important?\nA) Making data look pretty\nB) Turning data into visual representations for easier understanding ✓\nC) Creating decorative charts\nD) Replacing numbers with pictures\n\n### Q2: Code Understanding\nWhat type of graph does this code create?\n```python\nplt.plot(months, sales, \"r-o\")\nplt.title(\"Monthly Sales\")\n```\nA) Bar chart\nB) Pie chart\nC) Line graph with red line and circle markers ✓\nD) Scatter plot\n\n### Q3: Problem-Solving\nWhich graph type is best for showing trends over time?\nA) Pie chart\nB) Bar chart\nC) Line graph ✓\nD) Histogram\n\n### Q4: Application\nHow would you compare two advertising campaigns on one graph?\nA) Use two separate graphs\nB) Plot both campaigns with different colors and add a legend ✓\nC) Use only one campaign's data\nD) Create a pie chart\n\n### Q5: Reflection/Meta-learning\nWhat makes a visualization effective?\nA) Lots of colors and effects\nB) Clear labels, appropriate scale, and focus on key message ✓\nC) As much data as possible\nD) Complex design elements\n\n---",
      "lessonSlug": "data-visualization-using-matplotlib-q1-vocabularyconcepts-what-is-data-visualization-and-why-is-it-important-a-making-data-look-pretty-b-turning-data-into-visual-representations-for-easier-understanding-c-creating-decorative-charts-d-replacing-numbers-with-pictures-q2-code-understanding-what-type-of-graph-does-this-code-create-python-pltplotmonths-sales-r-o-plttitlemonthly-sales-a-bar-chart-b-pie-chart-c-line-graph-with-red-line-and-circle-markers-d-scatter-plot-q3-problem-solving-which-graph-type-is-best-for-showing-trends-over-time-a-pie-chart-b-bar-chart-c-line-graph-d-histogram-q4-application-how-would-you-compare-two-advertising-campaigns-on-one-graph-a-use-two-separate-graphs-b-plot-both-campaigns-with-different-colors-and-add-a-legend-c-use-only-one-campaigns-data-d-create-a-pie-chart-q5-reflectionmeta-learning-what-makes-a-visualization-effective-a-lots-of-colors-and-effects-b-clear-labels-appropriate-scale-and-focus-on-key-message-c-as-much-data-as-possible-d-complex-design-elements",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l13-q1",
          "globalId": "exit-ticket-0411",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is data visualization and why is it important?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_PRESENTATION_DISMISSAL",
            "VIZ_CHART_TYPE_PURPOSE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Making data look pretty",
              "isCorrect": false,
              "misconceptionId": "DATA_PRESENTATION_DISMISSAL",
              "feedback": {
                "short": "Not quite! Visualization is about understanding, not aesthetics.",
                "detailed": "While good visualizations are often attractive, 'pretty' isn't the goal. The purpose is to reveal patterns, trends, and insights that would be hard to see in raw numbers. A simple, clear chart beats a colorful confusing one every time.",
                "socraticHint": "Would you prefer a beautiful chart you can't understand or a plain one that tells you exactly what you need?"
              }
            },
            {
              "key": "B",
              "text": "Turning data into visual representations for easier understanding",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Creating decorative charts",
              "isCorrect": false,
              "misconceptionId": "DATA_PRESENTATION_DISMISSAL",
              "feedback": {
                "short": "Not quite! Charts are tools for insight, not decoration.",
                "detailed": "Data visualization transforms numbers into visual patterns our brains can quickly process. We can spot trends in a line graph in seconds that would take minutes to find in a table. It's a powerful analytical tool, not decoration.",
                "socraticHint": "Why do weather forecasts use maps instead of tables of numbers?"
              }
            },
            {
              "key": "D",
              "text": "Replacing numbers with pictures",
              "isCorrect": false,
              "misconceptionId": "VIZ_CHART_TYPE_PURPOSE",
              "feedback": {
                "short": "Not quite! Visualization doesn't replace data—it represents it.",
                "detailed": "Visualization doesn't throw away numbers; it presents them in a form that reveals relationships. The exact values are still there (often in tooltips or labels), but the visual form helps you see patterns like trends, clusters, and outliers that numbers alone can't show clearly.",
                "socraticHint": "Does a bar chart hide the values or show them in a different way?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Turning data into visual representations for easier understanding",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "visualization",
              "matplotlib"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l13-q2",
          "globalId": "exit-ticket-0412",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What type of graph does this code create?",
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "plt.plot(months, sales, \"r-o\")\nplt.title(\"Monthly Sales\")",
          "misconceptionTargets": [
            "VIZ_CHART_TYPE_PURPOSE",
            "PLT_FORMAT_STRING"
          ],
          "options": [
            {
              "key": "A",
              "text": "Bar chart",
              "isCorrect": false,
              "misconceptionId": "VIZ_CHART_TYPE_PURPOSE",
              "feedback": {
                "short": "Not quite! Bar charts use plt.bar(), not plt.plot().",
                "detailed": "In Matplotlib, `plt.plot()` creates line graphs. For bar charts, you'd use `plt.bar()`. The function name tells you the chart type. The format string 'r-o' specifies appearance (red, line, circle markers), not chart type.",
                "socraticHint": "What function would you use for bars: plt.plot() or plt.bar()?"
              }
            },
            {
              "key": "B",
              "text": "Pie chart",
              "isCorrect": false,
              "misconceptionId": "VIZ_CHART_TYPE_PURPOSE",
              "feedback": {
                "short": "Not quite! Pie charts use plt.pie(), not plt.plot().",
                "detailed": "Pie charts are created with `plt.pie()`. The `plt.plot()` function creates line graphs by connecting data points. Each chart type has its own dedicated function in Matplotlib.",
                "socraticHint": "Looking at the function name, what does 'plot' suggest?"
              }
            },
            {
              "key": "C",
              "text": "Line graph with red line and circle markers",
              "isCorrect": true
            },
            {
              "key": "D",
              "text": "Scatter plot",
              "isCorrect": false,
              "misconceptionId": "PLT_FORMAT_STRING",
              "feedback": {
                "short": "Not quite! The '-' in 'r-o' means connect the points with lines.",
                "detailed": "The format string 'r-o' means: r=red, -=solid line connecting points, o=circle markers. A scatter plot would use 'ro' (no dash) or `plt.scatter()`. The dash makes it a LINE graph with markers, not a scatter of unconnected points.",
                "socraticHint": "What does the '-' in 'r-o' tell Matplotlib to do?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "Line graph with red line and circle markers",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "matplotlib",
              "format-strings"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l13-q3",
          "globalId": "exit-ticket-0413",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "vocabulary",
          "prompt": "Which graph type is best for showing trends over time?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "VIZ_CHART_TYPE_PURPOSE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Pie chart",
              "isCorrect": false,
              "misconceptionId": "VIZ_CHART_TYPE_PURPOSE",
              "feedback": {
                "short": "Not quite! Pie charts show parts of a whole at ONE moment.",
                "detailed": "Pie charts show proportions—how a total breaks into categories (like market share by company). They can't show change over time because there's no time axis. For monthly sales trends, you need a chart that connects sequential time points.",
                "socraticHint": "Where would you put 'January' and 'February' on a pie chart?"
              }
            },
            {
              "key": "B",
              "text": "Bar chart",
              "isCorrect": false,
              "misconceptionId": "VIZ_CHART_TYPE_PURPOSE",
              "feedback": {
                "short": "Not quite! Bar charts compare categories but don't emphasize trends.",
                "detailed": "Bar charts CAN show data over time, but they emphasize individual comparisons, not the flow of change. Line graphs connect points to show direction—are sales rising, falling, or staying flat? The connected line makes trends visually obvious.",
                "socraticHint": "What visual element in a line graph shows 'going up' or 'going down'?"
              }
            },
            {
              "key": "C",
              "text": "Line graph",
              "isCorrect": true
            },
            {
              "key": "D",
              "text": "Histogram",
              "isCorrect": false,
              "misconceptionId": "VIZ_CHART_TYPE_PURPOSE",
              "feedback": {
                "short": "Not quite! Histograms show data distribution, not time trends.",
                "detailed": "Histograms display how data is distributed across ranges (like 'how many students scored 80-90?'). They have no time dimension. For trends over time—like monthly sales—you need a chart with a time axis, which line graphs provide naturally.",
                "socraticHint": "What does the x-axis of a histogram typically show?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "Line graph",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "visualization",
              "chart-selection"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l13-q4",
          "globalId": "exit-ticket-0414",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "How would you compare two advertising campaigns on one graph?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "VIZ_COMPARISON_TECHNIQUE",
            "VIZ_CHART_TYPE_PURPOSE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Use two separate graphs",
              "isCorrect": false,
              "misconceptionId": "VIZ_COMPARISON_TECHNIQUE",
              "feedback": {
                "short": "Not quite! Separate graphs make direct comparison harder.",
                "detailed": "When comparing campaigns, you want to see them side-by-side on the SAME axes. Two separate graphs mean your eye must jump back and forth, and the scales might differ. Overlaying lines with different colors on one graph makes comparison instant.",
                "socraticHint": "Is it easier to compare heights when people stand together or in different rooms?"
              }
            },
            {
              "key": "B",
              "text": "Plot both campaigns with different colors and add a legend",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Use only one campaign's data",
              "isCorrect": false,
              "misconceptionId": "VIZ_COMPARISON_TECHNIQUE",
              "feedback": {
                "short": "Not quite! You can't compare without showing both.",
                "detailed": "To compare means to evaluate BOTH options. Showing only one campaign's data doesn't enable comparison at all. A good comparison visualization puts both datasets on the same graph so viewers can directly see which performs better at each time point.",
                "socraticHint": "How can you say 'Campaign A is better' if you never show Campaign B?"
              }
            },
            {
              "key": "D",
              "text": "Create a pie chart",
              "isCorrect": false,
              "misconceptionId": "VIZ_CHART_TYPE_PURPOSE",
              "feedback": {
                "short": "Not quite! Pie charts can't show how two campaigns change over time.",
                "detailed": "Pie charts show proportions of a whole at one moment. To compare two campaigns over time, you need a chart with a time axis showing both trends—typically a line graph with two lines in different colors, plus a legend to identify each.",
                "socraticHint": "What visual element shows 'Campaign A is growing faster than Campaign B'?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Plot both campaigns with different colors and add a legend",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "matplotlib",
              "comparison"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l13-q5",
          "globalId": "exit-ticket-0415",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "What makes a visualization effective?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "VIZ_DESIGN_PRINCIPLES"
          ],
          "options": [
            {
              "key": "A",
              "text": "Lots of colors and effects",
              "isCorrect": false,
              "misconceptionId": "VIZ_DESIGN_PRINCIPLES",
              "feedback": {
                "short": "Not quite! Too many colors can distract from the message.",
                "detailed": "Extra colors and effects often create 'chart junk'—visual noise that distracts from the data. Effective visualizations use color purposefully (e.g., different lines for different campaigns) rather than decoratively. Less is usually more.",
                "socraticHint": "Would a rainbow-colored chart be easier or harder to read?"
              }
            },
            {
              "key": "B",
              "text": "Clear labels, appropriate scale, and focus on key message",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "As much data as possible",
              "isCorrect": false,
              "misconceptionId": "VIZ_DESIGN_PRINCIPLES",
              "feedback": {
                "short": "Not quite! Too much data overwhelms viewers.",
                "detailed": "Cramming too much data into one chart creates confusion. Effective visualizations show what's needed to answer the question—no more. If you're showing monthly sales trends, you don't need hourly data. Focus communicates; clutter confuses.",
                "socraticHint": "Is a map more useful with every road or just the main ones you need?"
              }
            },
            {
              "key": "D",
              "text": "Complex design elements",
              "isCorrect": false,
              "misconceptionId": "VIZ_DESIGN_PRINCIPLES",
              "feedback": {
                "short": "Not quite! Complexity usually hurts understanding.",
                "detailed": "Complex design elements (3D effects, fancy fonts, decorative borders) typically make charts HARDER to read. The best visualizations are simple: clear axes, readable labels, and data that speaks for itself. Complexity should be in your insights, not your design.",
                "socraticHint": "Would you trust medical data presented with lots of fancy graphics or a clean, simple chart?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Clear labels, appropriate scale, and focus on key message",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "visualization",
              "design-principles"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-14",
      "lessonNumber": 14,
      "lessonTitle": "Introduction to Data Analysis\n\n### Q1: Vocabulary/Concepts\nWhat is the difference between raw data and processed data?\nA) No difference\nB) Raw data is original/unprocessed, processed data is cleaned and organized ✓\nC) Raw data is better than processed data\nD) Processed data is always wrong\n\n### Q2: Code Understanding\nWhat does `df.describe()` show you?\nA) The first few rows\nB) Statistical summary of numeric columns ✓\nC) Missing values\nD) Data types\n\n### Q3: Problem-Solving\nWhat's the first step in analyzing a new dataset?\nA) Create visualizations immediately\nB) Explore the data structure and check for quality issues ✓\nC) Start building models\nD) Delete missing values\n\n### Q4: Application\nWhat questions should a retail company ask when analyzing sales data?\nA) Only total sales amount\nB) Sales trends, best-performing products, seasonal patterns, customer segments ✓\nC) Only which products sold\nD) Only when sales occurred\n\n### Q5: Reflection/Meta-learning\nWhy is data analysis an iterative process?\nA) To make it take longer\nB) Because you often discover new questions and need to revisit earlier steps ✓\nC) To confuse people\nD) Because computers are slow\n\n---",
      "lessonSlug": "introduction-to-data-analysis-q1-vocabularyconcepts-what-is-the-difference-between-raw-data-and-processed-data-a-no-difference-b-raw-data-is-originalunprocessed-processed-data-is-cleaned-and-organized-c-raw-data-is-better-than-processed-data-d-processed-data-is-always-wrong-q2-code-understanding-what-does-dfdescribe-show-you-a-the-first-few-rows-b-statistical-summary-of-numeric-columns-c-missing-values-d-data-types-q3-problem-solving-whats-the-first-step-in-analyzing-a-new-dataset-a-create-visualizations-immediately-b-explore-the-data-structure-and-check-for-quality-issues-c-start-building-models-d-delete-missing-values-q4-application-what-questions-should-a-retail-company-ask-when-analyzing-sales-data-a-only-total-sales-amount-b-sales-trends-best-performing-products-seasonal-patterns-customer-segments-c-only-which-products-sold-d-only-when-sales-occurred-q5-reflectionmeta-learning-why-is-data-analysis-an-iterative-process-a-to-make-it-take-longer-b-because-you-often-discover-new-questions-and-need-to-revisit-earlier-steps-c-to-confuse-people-d-because-computers-are-slow",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l14-q1",
          "globalId": "exit-ticket-0416",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the difference between raw data and processed data?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_QUALITY_MISCONCEPTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "No difference",
              "isCorrect": false,
              "misconceptionId": "DATA_QUALITY_MISCONCEPTION",
              "feedback": {
                "short": "Not quite! Raw and processed data are very different.",
                "detailed": "Raw data is untouched—it may have errors, duplicates, missing values, and inconsistent formats. Processed data has been cleaned, validated, and transformed to be ready for analysis. This difference is fundamental to data quality.",
                "socraticHint": "Would a survey with typos and blank responses be ready for analysis?"
              }
            },
            {
              "key": "B",
              "text": "Raw data is original/unprocessed, processed data is cleaned and organized",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Raw data is better than processed data",
              "isCorrect": false,
              "misconceptionId": "DATA_QUALITY_MISCONCEPTION",
              "feedback": {
                "short": "Not quite! Raw data often contains errors that need fixing.",
                "detailed": "While raw data is 'original,' it's not necessarily better. Raw data often has problems: typos, missing values, duplicates, inconsistent formats. Processing fixes these issues to enable accurate analysis. Think of it like cooking: raw ingredients need preparation.",
                "socraticHint": "Would you trust calculations from a spreadsheet full of typos?"
              }
            },
            {
              "key": "D",
              "text": "Processed data is always wrong",
              "isCorrect": false,
              "misconceptionId": "DATA_QUALITY_MISCONCEPTION",
              "feedback": {
                "short": "Not quite! Good processing improves data quality.",
                "detailed": "Proper processing makes data MORE reliable, not less. It removes errors, standardizes formats, and handles missing values systematically. Of course, bad processing could introduce problems—which is why data professionals document every step.",
                "socraticHint": "Is spell-checking a document likely to make it better or worse?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Raw data is original/unprocessed, processed data is cleaned and organized",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "data-analysis",
              "data-quality"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l14-q2",
          "globalId": "exit-ticket-0417",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "vocabulary",
          "prompt": "What does `df.describe()` show you?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PANDAS_METHOD_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "The first few rows",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! That's what `df.head()` does.",
                "detailed": "You're thinking of `df.head()` which shows the first 5 rows (or `df.head(10)` for 10 rows). `df.describe()` shows statistical summaries: count, mean, std, min, 25%, 50%, 75%, max for each numeric column.",
                "socraticHint": "What would you use if you wanted to see the actual data rows?"
              }
            },
            {
              "key": "B",
              "text": "Statistical summary of numeric columns",
              "isCorrect": true
            },
            {
              "key": "C",
              "text": "Missing values",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! Use `df.isnull().sum()` for missing values.",
                "detailed": "`df.describe()` shows statistics (mean, std, min, max, etc.), not missing value counts. To find missing values, use `df.isnull().sum()` or `df.info()`. The 'count' row in describe() can hint at missing values indirectly, but it's not the primary purpose.",
                "socraticHint": "What statistic in describe() might hint at missing values?"
              }
            },
            {
              "key": "D",
              "text": "Data types",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! Use `df.dtypes` or `df.info()` for data types.",
                "detailed": "`df.describe()` focuses on statistical summaries, not data types. For column types, use `df.dtypes` (just types) or `df.info()` (types plus memory usage and non-null counts). Each pandas method has a specific purpose.",
                "socraticHint": "Which method name sounds like it would tell you about types?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Statistical summary of numeric columns",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "pandas",
              "exploratory-analysis"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l14-q3",
          "globalId": "exit-ticket-0418",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "vocabulary",
          "prompt": "What's the first step in analyzing a new dataset?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_WORKFLOW_SKIP",
            "DATA_QUALITY_MISCONCEPTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Create visualizations immediately",
              "isCorrect": false,
              "misconceptionId": "DATA_WORKFLOW_SKIP",
              "feedback": {
                "short": "Not quite! Visualizations are valuable, but you need to understand your data first.",
                "detailed": "Creating visualizations before exploring the data structure is like decorating a house before checking the foundation. You might create misleading charts if you don't understand what columns exist, what types they are, or if there are quality issues.",
                "socraticHint": "What could go wrong if you chart data without knowing if it has missing values or incorrect types?"
              }
            },
            {
              "key": "B",
              "text": "Explore the data structure and check for quality issues",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! EDA (Exploratory Data Analysis) always comes first.",
                "detailed": "Understanding your data's structure (columns, types, shape) and quality (missing values, duplicates, outliers) is essential before any analysis. This prevents wasted effort and incorrect conclusions."
              }
            },
            {
              "key": "C",
              "text": "Start building models",
              "isCorrect": false,
              "misconceptionId": "DATA_WORKFLOW_SKIP",
              "feedback": {
                "short": "Not quite! Models require clean, understood data to be effective.",
                "detailed": "Building models without exploring data first is like cooking without checking your ingredients. Models trained on misunderstood or dirty data produce unreliable results. EDA ensures you know what you're working with.",
                "socraticHint": "What happens to a model if it's trained on data with lots of missing values or wrong data types?"
              }
            },
            {
              "key": "D",
              "text": "Delete missing values",
              "isCorrect": false,
              "misconceptionId": "DATA_QUALITY_MISCONCEPTION",
              "feedback": {
                "short": "Not quite! Deleting data without understanding it first can harm your analysis.",
                "detailed": "Automatically deleting missing values is premature. First, you need to understand WHY values are missing, HOW MANY are missing, and WHETHER deletion or imputation is appropriate. Missing data might have meaning!",
                "socraticHint": "What if the missing values follow a pattern that's actually informative for your analysis?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Explore the data structure and check for quality issues",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l14-q4",
          "globalId": "exit-ticket-0419",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "What questions should a retail company ask when analyzing sales data?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_SINGLE_DIMENSION",
            "STATS_SINGLE_METRIC"
          ],
          "options": [
            {
              "key": "A",
              "text": "Only total sales amount",
              "isCorrect": false,
              "misconceptionId": "STATS_SINGLE_METRIC",
              "feedback": {
                "short": "Not quite! Total sales is just one number—it misses the story behind the data.",
                "detailed": "A single total tells you almost nothing useful. $1M in sales could mean 100 big purchases or 1M small ones, could be declining or growing, could be from one product or many. Comprehensive analysis requires multiple perspectives.",
                "socraticHint": "If your only metric is total sales, how would you know if business is improving or declining?"
              }
            },
            {
              "key": "B",
              "text": "Sales trends, best-performing products, seasonal patterns, customer segments",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Comprehensive analysis examines multiple dimensions of the data.",
                "detailed": "Effective data analysis asks questions across time (trends), products (performance), patterns (seasonality), and people (segments). This multi-dimensional approach reveals actionable insights, not just numbers."
              }
            },
            {
              "key": "C",
              "text": "Only which products sold",
              "isCorrect": false,
              "misconceptionId": "DATA_SINGLE_DIMENSION",
              "feedback": {
                "short": "Not quite! Knowing WHAT sold is only part of the picture.",
                "detailed": "Product lists without context miss crucial insights. You need to know HOW MUCH each sold, WHEN they sold (trends), WHO bought them (segments), and HOW they compare (performance). Data analysis connects multiple dimensions.",
                "socraticHint": "If Product A sold 100 units, is that good or bad? What other information would help you decide?"
              }
            },
            {
              "key": "D",
              "text": "Only when sales occurred",
              "isCorrect": false,
              "misconceptionId": "DATA_SINGLE_DIMENSION",
              "feedback": {
                "short": "Not quite! Timing alone doesn't tell the full story.",
                "detailed": "Knowing when sales happened is useful for trends and seasonality, but without connecting to WHAT was sold, to WHOM, and for HOW MUCH, you can't make informed business decisions. Analysis integrates multiple data dimensions.",
                "socraticHint": "If you see a spike in sales on December 25th, what other questions would you need to answer?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Sales trends, best-performing products, seasonal patterns, customer segments",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l14-q5",
          "globalId": "exit-ticket-0420",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why is data analysis an iterative process?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_WORKFLOW_LINEAR",
            "PROCESS_DISMISSAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "To make it take longer",
              "isCorrect": false,
              "misconceptionId": "PROCESS_DISMISSAL",
              "feedback": {
                "short": "Not quite! Iteration isn't about wasting time—it's about discovery.",
                "detailed": "Iteration in data analysis isn't inefficiency. Each pass through the data reveals new patterns, questions, or issues. What looks like 'going back' is actually progress—each cycle deepens understanding.",
                "socraticHint": "When you learn something new about your data, why might you need to revisit earlier decisions?"
              }
            },
            {
              "key": "B",
              "text": "Because you often discover new questions and need to revisit earlier steps",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Data analysis is a journey of discovery, not a linear path.",
                "detailed": "Analysis reveals unexpected patterns, raises new questions, and uncovers data issues you didn't anticipate. Each iteration builds on what you learned, making your analysis stronger and more insightful."
              }
            },
            {
              "key": "C",
              "text": "To confuse people",
              "isCorrect": false,
              "misconceptionId": "PROCESS_DISMISSAL",
              "feedback": {
                "short": "Not quite! Iteration is a feature, not a flaw.",
                "detailed": "The iterative nature of data analysis reflects how real discovery works. You can't predict everything you'll find. Being open to revisiting and refining is what separates good analysis from superficial analysis.",
                "socraticHint": "What would happen if analysts ignored new discoveries just to avoid revisiting earlier work?"
              }
            },
            {
              "key": "D",
              "text": "Because computers are slow",
              "isCorrect": false,
              "misconceptionId": "DATA_WORKFLOW_LINEAR",
              "feedback": {
                "short": "Not quite! Iteration is about human insight, not computer speed.",
                "detailed": "Modern computers process data incredibly fast. The iteration happens because HUMANS need time to interpret results, form hypotheses, and decide next steps. It's a cognitive process, not a computational one.",
                "socraticHint": "Even with the fastest computer, why would you still need multiple passes to fully understand a dataset?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Because you often discover new questions and need to revisit earlier steps",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-15",
      "lessonNumber": 15,
      "lessonTitle": "Pandas\n\n### Q1: Vocabulary/Concepts\nWhat is the difference between a Pandas Series and DataFrame?\nA) No difference\nB) Series is 1-dimensional, DataFrame is 2-dimensional (like a table) ✓\nC) Series is faster than DataFrame\nD) DataFrame is older than Series\n\n### Q2: Code Understanding\nWhat does `df[\"Salary\"].mean()` calculate?\nA) The first salary value\nB) The average salary ✓\nC) The highest salary\nD) The total of all salaries\n\n### Q3: Problem-Solving\nHow do you select rows where salary is greater than 50000?\nA) `df[df[\"Salary\"] > 50000]` ✓\nB) `df.select(Salary > 50000)`\nC) `df.where(Salary > 50000)`\nD) `df.filter(Salary > 50000)`\n\n### Q4: Application\nHow would you find employees earning above the company average?\nA) Sort by salary and pick the top half\nB) Calculate average, then filter for salaries above that average ✓\nC) Pick employees with highest salaries\nD) Use the median instead\n\n### Q5: Reflection/Meta-learning\nWhat advantage does Pandas have over Excel for data analysis?\nA) Better graphics\nB) Programmatic control, reproducible analysis, handles larger datasets ✓\nC) Easier to use\nD) Cheaper software\n\n---",
      "lessonSlug": "pandas-q1-vocabularyconcepts-what-is-the-difference-between-a-pandas-series-and-dataframe-a-no-difference-b-series-is-1-dimensional-dataframe-is-2-dimensional-like-a-table-c-series-is-faster-than-dataframe-d-dataframe-is-older-than-series-q2-code-understanding-what-does-dfsalarymean-calculate-a-the-first-salary-value-b-the-average-salary-c-the-highest-salary-d-the-total-of-all-salaries-q3-problem-solving-how-do-you-select-rows-where-salary-is-greater-than-50000-a-dfdfsalary-50000-b-dfselectsalary-50000-c-dfwheresalary-50000-d-dffiltersalary-50000-q4-application-how-would-you-find-employees-earning-above-the-company-average-a-sort-by-salary-and-pick-the-top-half-b-calculate-average-then-filter-for-salaries-above-that-average-c-pick-employees-with-highest-salaries-d-use-the-median-instead-q5-reflectionmeta-learning-what-advantage-does-pandas-have-over-excel-for-data-analysis-a-better-graphics-b-programmatic-control-reproducible-analysis-handles-larger-datasets-c-easier-to-use-d-cheaper-software",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l15-q1",
          "globalId": "exit-ticket-0421",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the difference between a Pandas Series and DataFrame?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PANDAS_STRUCTURE_CONFUSION",
            "TERM_IRRELEVANT_DISTINCTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "No difference",
              "isCorrect": false,
              "misconceptionId": "PANDAS_STRUCTURE_CONFUSION",
              "feedback": {
                "short": "Not quite! Series and DataFrame are fundamentally different structures.",
                "detailed": "A Series is like a single column of data (1D), while a DataFrame is like a table with multiple columns (2D). Think of a DataFrame as a collection of Series sharing the same index. This distinction matters for how you select and manipulate data.",
                "socraticHint": "When you select a single column from a DataFrame with df['name'], what type do you get back?"
              }
            },
            {
              "key": "B",
              "text": "Series is 1-dimensional, DataFrame is 2-dimensional (like a table)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Dimensionality is the key difference.",
                "detailed": "A Series is 1D (like a list with labels), while a DataFrame is 2D (like a spreadsheet with rows and columns). Understanding this helps you know what operations are available and what to expect when selecting data."
              }
            },
            {
              "key": "C",
              "text": "Series is faster than DataFrame",
              "isCorrect": false,
              "misconceptionId": "TERM_IRRELEVANT_DISTINCTION",
              "feedback": {
                "short": "Not quite! Performance isn't the key difference between these structures.",
                "detailed": "Both Series and DataFrame are optimized and fast. The real difference is dimensionality: Series is 1D (single column), DataFrame is 2D (table). You choose based on your data structure needs, not speed.",
                "socraticHint": "If you have data about students with name, age, and grade, would a single column (Series) be enough?"
              }
            },
            {
              "key": "D",
              "text": "DataFrame is older than Series",
              "isCorrect": false,
              "misconceptionId": "TERM_IRRELEVANT_DISTINCTION",
              "feedback": {
                "short": "Not quite! Age/history isn't what distinguishes these data structures.",
                "detailed": "Both were introduced together as complementary structures. The real difference is dimensionality: Series = 1D (single column), DataFrame = 2D (table). This structural difference determines how you work with your data.",
                "socraticHint": "What shape would you need to store a table of data with 5 columns—1D or 2D?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Series is 1-dimensional, DataFrame is 2-dimensional (like a table)",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "pandas",
              "data-analysis"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l15-q2",
          "globalId": "exit-ticket-0422",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What does `df[\"Salary\"].mean()` calculate?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PANDAS_METHOD_CONFUSION",
            "STATS_MEASURE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "The first salary value",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! `.mean()` doesn't select a specific row.",
                "detailed": "You're thinking of `.head(1)` or `.iloc[0]` which would get the first value. The `.mean()` method is an aggregation—it computes a single value from ALL values in the column by calculating the average.",
                "socraticHint": "What Pandas method would you use to get just the first few rows?"
              }
            },
            {
              "key": "B",
              "text": "The average salary",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! `.mean()` calculates the arithmetic average.",
                "detailed": "The `.mean()` method sums all values in the Salary column and divides by the count. It's one of Pandas' built-in aggregation methods—others include `.sum()`, `.median()`, `.max()`, and `.min()`."
              }
            },
            {
              "key": "C",
              "text": "The highest salary",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! That would be `.max()`, not `.mean()`.",
                "detailed": "`.mean()` = average (sum ÷ count), `.max()` = highest value. These are different aggregation methods. 'Mean' is the statistical term for average, which considers ALL values, not just the extreme.",
                "socraticHint": "If salaries are [50000, 60000, 70000], what's the mean vs the max?"
              }
            },
            {
              "key": "D",
              "text": "The total of all salaries",
              "isCorrect": false,
              "misconceptionId": "STATS_MEASURE_CONFUSION",
              "feedback": {
                "short": "Not quite! That would be `.sum()`, not `.mean()`.",
                "detailed": "`.sum()` adds all values together. `.mean()` adds them AND divides by the count. Mean (average) gives you a 'typical' value, while sum gives you the total. Different questions, different methods.",
                "socraticHint": "If salaries are [50K, 60K, 70K], the sum is 180K. What's the mean?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "The average salary",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l15-q3",
          "globalId": "exit-ticket-0423",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "blockmodel",
          "prompt": "How do you select rows where salary is greater than 50000?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PANDAS_SYNTAX_CONFUSION",
            "API_HALLUCINATION"
          ],
          "options": [
            {
              "key": "A",
              "text": "`df[df[\"Salary\"] > 50000]`",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is boolean indexing—the core Pandas filtering pattern.",
                "detailed": "The inner `df['Salary'] > 50000` creates a boolean mask (True/False for each row), and the outer `df[...]` uses that mask to select only rows where the condition is True. This pattern works with any comparison."
              }
            },
            {
              "key": "B",
              "text": "`df.select(Salary > 50000)`",
              "isCorrect": false,
              "misconceptionId": "API_HALLUCINATION",
              "feedback": {
                "short": "Not quite! Pandas doesn't have a `.select()` method like this.",
                "detailed": "You might be thinking of SQL syntax or other languages. In Pandas, filtering uses boolean indexing: `df[condition]`. The condition goes inside square brackets, not a method call.",
                "socraticHint": "What notation does Pandas use for both column selection AND row filtering?"
              }
            },
            {
              "key": "C",
              "text": "`df.where(Salary > 50000)`",
              "isCorrect": false,
              "misconceptionId": "PANDAS_SYNTAX_CONFUSION",
              "feedback": {
                "short": "Not quite! `.where()` does something different in Pandas.",
                "detailed": "Pandas does have `.where()`, but it replaces values that DON'T meet the condition with NaN rather than filtering them out. For filtering rows, use boolean indexing: `df[df['Salary'] > 50000]`.",
                "socraticHint": "What would you expect `.where()` to return—fewer rows or the same rows with some values changed?"
              }
            },
            {
              "key": "D",
              "text": "`df.filter(Salary > 50000)`",
              "isCorrect": false,
              "misconceptionId": "PANDAS_SYNTAX_CONFUSION",
              "feedback": {
                "short": "Not quite! Pandas `.filter()` is for selecting columns by name, not rows by condition.",
                "detailed": "`.filter()` in Pandas filters COLUMNS based on label patterns, not rows based on values. For row filtering by condition, use boolean indexing: `df[df['Salary'] > 50000]`.",
                "socraticHint": "If `.filter()` works on column labels, what would `df.filter(items=['Name', 'Salary'])` return?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "`df[df[\"Salary\"] > 50000]`",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l15-q4",
          "globalId": "exit-ticket-0424",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "How would you find employees earning above the company average?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "STATS_MEASURE_CONFUSION",
            "DATA_MEAN_VS_MEDIAN"
          ],
          "options": [
            {
              "key": "A",
              "text": "Sort by salary and pick the top half",
              "isCorrect": false,
              "misconceptionId": "DATA_MEAN_VS_MEDIAN",
              "feedback": {
                "short": "Not quite! The top half is the median split, not the average split.",
                "detailed": "Sorting and taking the top half gives you employees above the MEDIAN (50th percentile). But 'above average' means above the MEAN. With skewed salary distributions, these can be very different—a few high earners can pull the mean above the median.",
                "socraticHint": "If salaries are [30K, 40K, 50K, 60K, 200K], what's the median? What's the mean?"
              }
            },
            {
              "key": "B",
              "text": "Calculate average, then filter for salaries above that average",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! First compute the mean, then use it as a filter threshold.",
                "detailed": "This is a two-step approach: `avg = df['Salary'].mean()` then `df[df['Salary'] > avg]`. This correctly identifies employees earning more than the arithmetic mean of all salaries."
              }
            },
            {
              "key": "C",
              "text": "Pick employees with highest salaries",
              "isCorrect": false,
              "misconceptionId": "STATS_MEASURE_CONFUSION",
              "feedback": {
                "short": "Not quite! 'Highest' and 'above average' are different criteria.",
                "detailed": "'Highest salaries' is vague—how many? The top 5? 10? 'Above average' has a precise definition: anyone earning more than the mean. In a company of 100 employees, that could be 30 or 70 people depending on the distribution.",
                "socraticHint": "If the average salary is 60K, could someone earning 65K be 'above average' but not among the 'highest'?"
              }
            },
            {
              "key": "D",
              "text": "Use the median instead",
              "isCorrect": false,
              "misconceptionId": "DATA_MEAN_VS_MEDIAN",
              "feedback": {
                "short": "Not quite! The question specifically asks about the average (mean), not median.",
                "detailed": "Mean and median are different measures. 'Average' typically refers to the mean (sum ÷ count). While median is useful for skewed data, it doesn't answer the question asked. Always match your analysis to the question.",
                "socraticHint": "When someone asks 'what's the average?', are they asking for the mean or median?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Calculate average, then filter for salaries above that average",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "pandas",
              "data-analysis"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l15-q5",
          "globalId": "exit-ticket-0425",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "What advantage does Pandas have over Excel for data analysis?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "TOOL_PURPOSE_CONFUSION",
            "TERM_IRRELEVANT_DISTINCTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Better graphics",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Excel's charting is actually quite powerful for quick visualizations.",
                "detailed": "Pandas itself doesn't have graphics—it uses Matplotlib for plotting. Excel has excellent built-in charting. The real Pandas advantage is in data manipulation, automation, and scale, not visualization.",
                "socraticHint": "If you needed to make a quick pie chart for a presentation, which would be faster?"
              }
            },
            {
              "key": "B",
              "text": "Programmatic control, reproducible analysis, handles larger datasets",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Code-based analysis is repeatable, scalable, and automatable.",
                "detailed": "Pandas scripts can be version-controlled, shared, automated, and run on datasets too large for Excel (millions of rows). Every step is documented in code, making analysis reproducible and auditable."
              }
            },
            {
              "key": "C",
              "text": "Easier to use",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Excel is often easier for beginners and quick tasks.",
                "detailed": "Excel's GUI makes simple tasks intuitive—no coding required. Pandas has a steeper learning curve. The advantage isn't ease of use; it's power, reproducibility, and scalability once you know the syntax.",
                "socraticHint": "Which would be faster for a non-programmer: summing a column in Excel or writing Pandas code?"
              }
            },
            {
              "key": "D",
              "text": "Cheaper software",
              "isCorrect": false,
              "misconceptionId": "TERM_IRRELEVANT_DISTINCTION",
              "feedback": {
                "short": "Not quite! While Pandas is free, cost isn't its main advantage.",
                "detailed": "Yes, Pandas is free and open-source, but many organizations already have Excel licenses. The real advantages are technical: automation, version control, handling larger datasets, and reproducible analysis pipelines.",
                "socraticHint": "If both tools were free, what would still make Pandas better for large-scale analysis?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Programmatic control, reproducible analysis, handles larger datasets",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "pandas",
              "data-analysis"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-16",
      "lessonNumber": 16,
      "lessonTitle": "Read and Export CSV File with Pandas\n\n### Q1: Vocabulary/Concepts\nWhat is a CSV file?\nA) A type of image file\nB) Comma-Separated Values, a plain text format for tabular data ✓\nC) A database file\nD) A Python script\n\n### Q2: Code Understanding\nWhat does `pd.read_csv(\"data.csv\", index_col=0)` do?\nA) Reads CSV and uses first column as row labels ✓\nB) Reads only the first column\nC) Skips the first column\nD) Creates a new CSV file\n\n### Q3: Problem-Solving\nHow would you add a calculated column to a DataFrame and save it?\nA) df[\"new_col\"] = calculation; df.to_csv(\"new_file.csv\") ✓\nB) df.add_column(calculation)\nC) df.insert(calculation)\nD) Create a new DataFrame\n\n### Q4: Application\nHow would you combine multiple monthly sales CSV files?\nA) Open each file separately\nB) Read each CSV, add month column, concatenate DataFrames, export combined data ✓\nC) Copy and paste manually\nD) Use only the largest file\n\n### Q5: Reflection/Meta-learning\nWhat challenges might you face when reading CSV files from different sources?\nA) Different delimiters, encoding issues, varying date formats ✓\nB) CSV files are always perfect\nC) No challenges exist\nD) Only file size matters\n\n---",
      "lessonSlug": "read-and-export-csv-file-with-pandas-q1-vocabularyconcepts-what-is-a-csv-file-a-a-type-of-image-file-b-comma-separated-values-a-plain-text-format-for-tabular-data-c-a-database-file-d-a-python-script-q2-code-understanding-what-does-pdread_csvdatacsv-index_col0-do-a-reads-csv-and-uses-first-column-as-row-labels-b-reads-only-the-first-column-c-skips-the-first-column-d-creates-a-new-csv-file-q3-problem-solving-how-would-you-add-a-calculated-column-to-a-dataframe-and-save-it-a-dfnew_col-calculation-dfto_csvnew_filecsv-b-dfadd_columncalculation-c-dfinsertcalculation-d-create-a-new-dataframe-q4-application-how-would-you-combine-multiple-monthly-sales-csv-files-a-open-each-file-separately-b-read-each-csv-add-month-column-concatenate-dataframes-export-combined-data-c-copy-and-paste-manually-d-use-only-the-largest-file-q5-reflectionmeta-learning-what-challenges-might-you-face-when-reading-csv-files-from-different-sources-a-different-delimiters-encoding-issues-varying-date-formats-b-csv-files-are-always-perfect-c-no-challenges-exist-d-only-file-size-matters",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l16-q1",
          "globalId": "exit-ticket-0426",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is a CSV file?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "CSV_FORMAT_CONFUSION",
            "PY_TOOL_CATEGORY_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "A type of image file",
              "isCorrect": false,
              "misconceptionId": "CSV_FORMAT_CONFUSION",
              "feedback": {
                "short": "Not quite! CSV files contain text data, not images.",
                "detailed": "Image files (like PNG, JPEG) store pixel data in binary format. CSV files are plain text—you can open them in Notepad and read the content. They store tabular data with commas separating values.",
                "socraticHint": "What would you see if you opened a CSV file in a simple text editor?"
              }
            },
            {
              "key": "B",
              "text": "Comma-Separated Values, a plain text format for tabular data",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! CSV is a simple, universal format for storing tabular data.",
                "detailed": "CSV files use commas to separate columns and newlines to separate rows. They're plain text, readable by any program, and are the most common format for exchanging data between different tools and systems."
              }
            },
            {
              "key": "C",
              "text": "A database file",
              "isCorrect": false,
              "misconceptionId": "CSV_FORMAT_CONFUSION",
              "feedback": {
                "short": "Not quite! CSV is simpler than a database—it's just structured text.",
                "detailed": "Databases (like SQLite, MySQL) have complex binary formats, support queries, indexes, and relationships. CSV is just plain text with commas and newlines—no special software needed to read it. It's a data exchange format, not a database.",
                "socraticHint": "Can you run SQL queries on a CSV file without loading it into a database first?"
              }
            },
            {
              "key": "D",
              "text": "A Python script",
              "isCorrect": false,
              "misconceptionId": "PY_TOOL_CATEGORY_CONFUSION",
              "feedback": {
                "short": "Not quite! CSV is a data format, not executable code.",
                "detailed": "Python scripts (.py files) contain code that computers execute. CSV files (.csv) contain data that programs read. Python can READ CSV files using Pandas, but CSV files themselves aren't programs.",
                "socraticHint": "What happens when you 'run' a CSV file versus 'read' it?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Comma-Separated Values, a plain text format for tabular data",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l16-q2",
          "globalId": "exit-ticket-0427",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What does `pd.read_csv(\"data.csv\", index_col=0)` do?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PANDAS_PARAM_CONFUSION",
            "PANDAS_READ_WRITE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Reads CSV and uses first column as row labels",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! `index_col=0` designates the first column as the DataFrame's index.",
                "detailed": "The `index_col` parameter tells Pandas which column to use as row labels (the index). Using `0` means the first column becomes the index rather than a regular data column. This is common when the first column contains unique identifiers like IDs or dates."
              }
            },
            {
              "key": "B",
              "text": "Reads only the first column",
              "isCorrect": false,
              "misconceptionId": "PANDAS_PARAM_CONFUSION",
              "feedback": {
                "short": "Not quite! `index_col` sets the index, it doesn't limit which columns are read.",
                "detailed": "All columns are still read. The `index_col` parameter just designates which column becomes the row index (labels). To select specific columns, you'd use `usecols=['col1', 'col2']`.",
                "socraticHint": "What parameter would you use if you only wanted to load certain columns?"
              }
            },
            {
              "key": "C",
              "text": "Skips the first column",
              "isCorrect": false,
              "misconceptionId": "PANDAS_PARAM_CONFUSION",
              "feedback": {
                "short": "Not quite! The column isn't skipped—it becomes the row index.",
                "detailed": "With `index_col=0`, the first column still exists in your DataFrame—it just moves from being a data column to being the index (row labels). The data is preserved, just in a different role.",
                "socraticHint": "After using index_col=0, where would you see the first column's values in the DataFrame?"
              }
            },
            {
              "key": "D",
              "text": "Creates a new CSV file",
              "isCorrect": false,
              "misconceptionId": "PANDAS_READ_WRITE_CONFUSION",
              "feedback": {
                "short": "Not quite! `read_csv` READS files; `to_csv` WRITES files.",
                "detailed": "The function name tells you the direction: `pd.read_csv()` reads data FROM a file into a DataFrame. To create/write a CSV, you'd use `df.to_csv()`. The parameter `index_col` only affects how the data is read.",
                "socraticHint": "What method would you call on a DataFrame to save it as a new CSV file?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Reads CSV and uses first column as row labels",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l16-q3",
          "globalId": "exit-ticket-0428",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "blockmodel",
          "prompt": "How would you add a calculated column to a DataFrame and save it?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "API_HALLUCINATION",
            "PANDAS_SYNTAX_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "df[\"new_col\"] = calculation; df.to_csv(\"new_file.csv\")",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Square bracket assignment adds columns, then to_csv() saves.",
                "detailed": "Pandas uses dictionary-style syntax for adding columns: `df['new_col'] = values`. This modifies the DataFrame in place. Then `df.to_csv()` writes the entire DataFrame (including the new column) to a file."
              }
            },
            {
              "key": "B",
              "text": "df.add_column(calculation)",
              "isCorrect": false,
              "misconceptionId": "API_HALLUCINATION",
              "feedback": {
                "short": "Not quite! Pandas doesn't have an `add_column()` method.",
                "detailed": "While `add_column` sounds intuitive, Pandas uses dictionary-style assignment: `df['new_col'] = values`. This pattern is consistent with how Python dictionaries work. Also, this doesn't include saving—you'd still need `to_csv()`.",
                "socraticHint": "How do you add a new key-value pair to a Python dictionary? Pandas uses the same pattern."
              }
            },
            {
              "key": "C",
              "text": "df.insert(calculation)",
              "isCorrect": false,
              "misconceptionId": "PANDAS_SYNTAX_CONFUSION",
              "feedback": {
                "short": "Not quite! `insert()` exists but requires more parameters and doesn't save.",
                "detailed": "Pandas does have `.insert()`, but it requires position, column name, AND values: `df.insert(0, 'new_col', values)`. The simpler `df['new_col'] = values` adds at the end. Either way, you'd still need `to_csv()` to save.",
                "socraticHint": "If you wanted to add a column at a specific position (not at the end), which method would you need?"
              }
            },
            {
              "key": "D",
              "text": "Create a new DataFrame",
              "isCorrect": false,
              "misconceptionId": "PANDAS_SYNTAX_CONFUSION",
              "feedback": {
                "short": "Not quite! You can modify existing DataFrames—no need to recreate.",
                "detailed": "DataFrames are mutable—you can add columns directly. Creating a new DataFrame just to add one column would be inefficient and lose any modifications you've made. Use `df['new_col'] = values` to add in place.",
                "socraticHint": "Would you create a whole new list just to add one item, or would you use append()?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "df[\"new_col\"] = calculation; df.to_csv(\"new_file.csv\")",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l16-q4",
          "globalId": "exit-ticket-0429",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "How would you combine multiple monthly sales CSV files?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_WORKFLOW_MANUAL",
            "DATA_INCOMPLETE_SOLUTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Open each file separately",
              "isCorrect": false,
              "misconceptionId": "DATA_INCOMPLETE_SOLUTION",
              "feedback": {
                "short": "Not quite! Opening separately doesn't combine them.",
                "detailed": "Opening files separately keeps them as independent datasets. To analyze trends across months, you need to COMBINE them into one DataFrame. Pandas can read each file and concatenate them programmatically.",
                "socraticHint": "If you have 12 separate DataFrames (one per month), how would you analyze year-long trends?"
              }
            },
            {
              "key": "B",
              "text": "Read each CSV, add month column, concatenate DataFrames, export combined data",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the standard programmatic workflow for combining files.",
                "detailed": "Read each file with `pd.read_csv()`, add a column to identify which month each row came from, use `pd.concat()` to stack them vertically, then export with `to_csv()`. This approach is reproducible and handles any number of files."
              }
            },
            {
              "key": "C",
              "text": "Copy and paste manually",
              "isCorrect": false,
              "misconceptionId": "DATA_WORKFLOW_MANUAL",
              "feedback": {
                "short": "Not quite! Manual processes don't scale and are error-prone.",
                "detailed": "Copy-pasting works for small tasks but fails for data science: it's slow, error-prone, not reproducible, and impossible to automate. Pandas provides `pd.concat()` to programmatically combine DataFrames in seconds.",
                "socraticHint": "What if you needed to do this every month with 12 files? Would copy-paste be sustainable?"
              }
            },
            {
              "key": "D",
              "text": "Use only the largest file",
              "isCorrect": false,
              "misconceptionId": "DATA_INCOMPLETE_SOLUTION",
              "feedback": {
                "short": "Not quite! You'd lose data from other months.",
                "detailed": "Using only one file discards all the other data. If you want to analyze yearly trends or compare months, you need ALL the data combined. Each month's file contains unique records that shouldn't be ignored.",
                "socraticHint": "How would you identify seasonal patterns if you only analyzed one month's data?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Read each CSV, add month column, concatenate DataFrames, export combined data",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l16-q5",
          "globalId": "exit-ticket-0430",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "What challenges might you face when reading CSV files from different sources?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_QUALITY_MISCONCEPTION",
            "TERM_IRRELEVANT_DISTINCTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Different delimiters, encoding issues, varying date formats",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Real-world CSV files are messy and inconsistent.",
                "detailed": "CSV files from different sources may use semicolons instead of commas, have different text encodings (UTF-8 vs Latin-1), or format dates differently (MM/DD/YYYY vs YYYY-MM-DD). Pandas has parameters to handle these: `sep`, `encoding`, `parse_dates`."
              }
            },
            {
              "key": "B",
              "text": "CSV files are always perfect",
              "isCorrect": false,
              "misconceptionId": "DATA_QUALITY_MISCONCEPTION",
              "feedback": {
                "short": "Not quite! Real-world data is rarely perfect.",
                "detailed": "CSV files often have issues: inconsistent formatting, missing values, wrong data types, encoding problems, and messy text. That's why data cleaning is such a large part of data science work. Always inspect your data before trusting it.",
                "socraticHint": "What would you do if a European CSV uses semicolons instead of commas?"
              }
            },
            {
              "key": "C",
              "text": "No challenges exist",
              "isCorrect": false,
              "misconceptionId": "DATA_QUALITY_MISCONCEPTION",
              "feedback": {
                "short": "Not quite! Data integration is full of challenges.",
                "detailed": "Every data source has its quirks. Dates might be 'Jan 5, 2024' in one file and '2024-01-05' in another. Some files use UTF-8, others use Windows encoding. Numbers might have commas (1,000.00) or periods (1.000,00). These inconsistencies require careful handling.",
                "socraticHint": "What happens if you try to combine two datasets where one formats dates as 'DD/MM/YYYY' and the other as 'MM/DD/YYYY'?"
              }
            },
            {
              "key": "D",
              "text": "Only file size matters",
              "isCorrect": false,
              "misconceptionId": "TERM_IRRELEVANT_DISTINCTION",
              "feedback": {
                "short": "Not quite! File size is just one of many concerns.",
                "detailed": "While large files can be challenging, format issues are often more problematic. A 10KB file with wrong encoding or mixed delimiters is harder to work with than a properly formatted 100MB file. Content structure matters more than size.",
                "socraticHint": "Would you rather work with a huge clean file or a small file where dates are formatted 5 different ways?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Different delimiters, encoding issues, varying date formats",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-17",
      "lessonNumber": 17,
      "lessonTitle": "Data Cleaning with Pandas\n\n### Q1: Vocabulary/Concepts\nWhat are the four main types of data quality issues?\nA) Missing values, duplicates, incorrect formatting, outliers ✓\nB) Too much data, too little data, wrong data, right data\nC) Numbers, text, dates, booleans\nD) Old data, new data, medium data, clean data\n\n### Q2: Code Understanding\nWhat does `df.dropna()` do?\nA) Creates missing values\nB) Removes rows with any missing values ✓\nC) Fills missing values\nD) Counts missing values\n\n### Q3: Problem-Solving\nHow should you handle missing salary data in an employee dataset?\nA) Delete all employee records\nB) Fill with median salary or use domain knowledge for imputation ✓\nC) Fill with zero\nD) Ignore the missing values\n\n### Q4: Application\nWhat would happen if an e-commerce model is trained on data with bot traffic and duplicates?\nA) Better performance\nB) Skewed behavior patterns and biased predictions ✓\nC) Faster training\nD) No effect\n\n### Q5: Reflection/Meta-learning\nWhy does data preparation take 80% of a data scientist's time?\nA) Data scientists are slow\nB) Real data is messy and requires domain knowledge and multiple iterations ✓\nC) Tools are bad\nD) It's unnecessary work\n\n---",
      "lessonSlug": "data-cleaning-with-pandas-q1-vocabularyconcepts-what-are-the-four-main-types-of-data-quality-issues-a-missing-values-duplicates-incorrect-formatting-outliers-b-too-much-data-too-little-data-wrong-data-right-data-c-numbers-text-dates-booleans-d-old-data-new-data-medium-data-clean-data-q2-code-understanding-what-does-dfdropna-do-a-creates-missing-values-b-removes-rows-with-any-missing-values-c-fills-missing-values-d-counts-missing-values-q3-problem-solving-how-should-you-handle-missing-salary-data-in-an-employee-dataset-a-delete-all-employee-records-b-fill-with-median-salary-or-use-domain-knowledge-for-imputation-c-fill-with-zero-d-ignore-the-missing-values-q4-application-what-would-happen-if-an-e-commerce-model-is-trained-on-data-with-bot-traffic-and-duplicates-a-better-performance-b-skewed-behavior-patterns-and-biased-predictions-c-faster-training-d-no-effect-q5-reflectionmeta-learning-why-does-data-preparation-take-80-of-a-data-scientists-time-a-data-scientists-are-slow-b-real-data-is-messy-and-requires-domain-knowledge-and-multiple-iterations-c-tools-are-bad-d-its-unnecessary-work",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l17-q1",
          "globalId": "exit-ticket-0431",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What are the four main types of data quality issues?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_QUALITY_MISCONCEPTION",
            "TERM_CROSS_DOMAIN"
          ],
          "options": [
            {
              "key": "A",
              "text": "Missing values, duplicates, incorrect formatting, outliers",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! These are the four pillars of data quality issues.",
                "detailed": "Data quality problems fall into four categories: 1) Missing values (gaps in data), 2) Duplicates (repeated records), 3) Incorrect formatting (wrong types, inconsistent values), 4) Outliers (unusual values that may be errors or meaningful)."
              }
            },
            {
              "key": "B",
              "text": "Too much data, too little data, wrong data, right data",
              "isCorrect": false,
              "misconceptionId": "DATA_QUALITY_MISCONCEPTION",
              "feedback": {
                "short": "Not quite! These describe data quantity and correctness, not quality issues.",
                "detailed": "Data quality is about specific problems: missing values, duplicates, formatting issues, and outliers. 'Too much' or 'too little' data are quantity concerns, not quality issues that need cleaning.",
                "socraticHint": "What kinds of problems would you actually fix during data cleaning?"
              }
            },
            {
              "key": "C",
              "text": "Numbers, text, dates, booleans",
              "isCorrect": false,
              "misconceptionId": "TERM_CROSS_DOMAIN",
              "feedback": {
                "short": "Not quite! These are data TYPES, not quality ISSUES.",
                "detailed": "Numbers, text, dates, and booleans are data types—categories of what data IS. Quality issues are PROBLEMS in data: missing values, duplicates, wrong formats, outliers. Every data type can have quality issues.",
                "socraticHint": "A column of numbers can have missing values—is that a type or a quality issue?"
              }
            },
            {
              "key": "D",
              "text": "Old data, new data, medium data, clean data",
              "isCorrect": false,
              "misconceptionId": "DATA_QUALITY_MISCONCEPTION",
              "feedback": {
                "short": "Not quite! Data age isn't a quality issue category.",
                "detailed": "These describe data freshness or state, not quality problems. A dataset can be old but perfectly clean, or new but full of errors. Quality issues are: missing values, duplicates, incorrect formatting, outliers.",
                "socraticHint": "Could a brand new dataset still have missing values or duplicates?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Missing values, duplicates, incorrect formatting, outliers",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l17-q2",
          "globalId": "exit-ticket-0432",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What does `df.dropna()` do?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PANDAS_METHOD_CONFUSION",
            "PANDAS_CLEANING_DIRECTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Creates missing values",
              "isCorrect": false,
              "misconceptionId": "PANDAS_CLEANING_DIRECTION",
              "feedback": {
                "short": "Not quite! The 'drop' in dropna() means REMOVE, not create.",
                "detailed": "Function names tell you what they do: 'drop' = remove, 'na' = missing values (NaN). So `dropna()` removes rows containing NaN values. No Pandas function intentionally creates missing values.",
                "socraticHint": "What does the word 'drop' typically mean when working with data?"
              }
            },
            {
              "key": "B",
              "text": "Removes rows with any missing values",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! dropna() drops (removes) rows containing NaN values.",
                "detailed": "By default, `df.dropna()` removes any row that has at least one missing value. You can customize with `how='all'` (only if ALL values missing) or `subset=['col']` (only check specific columns)."
              }
            },
            {
              "key": "C",
              "text": "Fills missing values",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! That's what `fillna()` does, not `dropna()`.",
                "detailed": "`dropna()` = DROP rows with missing values (delete them). `fillna()` = FILL missing values with something else. These are opposite strategies: drop removes data, fill preserves it.",
                "socraticHint": "If you wanted to replace missing values with the median, which method would you use?"
              }
            },
            {
              "key": "D",
              "text": "Counts missing values",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! Use `isna().sum()` to count missing values.",
                "detailed": "`dropna()` removes rows—it doesn't count. To count missing values, use `df.isna().sum()` which gives you a count per column. Always check counts BEFORE dropping to understand data loss.",
                "socraticHint": "Why might you want to count missing values before deciding to drop them?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Removes rows with any missing values",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l17-q3",
          "globalId": "exit-ticket-0433",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "bebras",
          "prompt": "How should you handle missing salary data in an employee dataset?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "CLEANING_NAIVE_IMPUTATION",
            "CLEANING_DATA_LOSS"
          ],
          "options": [
            {
              "key": "A",
              "text": "Delete all employee records",
              "isCorrect": false,
              "misconceptionId": "CLEANING_DATA_LOSS",
              "feedback": {
                "short": "Not quite! That's too extreme—you'd lose all your data!",
                "detailed": "Deleting ALL records because SOME have missing salary is drastic data loss. You'd lose valuable information about employees that DO have complete data. Target only the affected records, and consider imputation first.",
                "socraticHint": "What percentage of records would you lose? Is that acceptable?"
              }
            },
            {
              "key": "B",
              "text": "Fill with median salary or use domain knowledge for imputation",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Thoughtful imputation preserves data while addressing gaps.",
                "detailed": "Median salary is robust to outliers (unlike mean). Domain knowledge helps too—e.g., impute based on department, role, or experience level. The key is making informed choices, not arbitrary ones."
              }
            },
            {
              "key": "C",
              "text": "Fill with zero",
              "isCorrect": false,
              "misconceptionId": "CLEANING_NAIVE_IMPUTATION",
              "feedback": {
                "short": "Not quite! Zero would distort your salary analysis significantly.",
                "detailed": "Filling salary with zero introduces false data—no employee earns $0. This would drag down averages and create outliers. Use meaningful values: median, mean, or role-based estimates.",
                "socraticHint": "What would happen to your 'average salary by department' analysis with zeros mixed in?"
              }
            },
            {
              "key": "D",
              "text": "Ignore the missing values",
              "isCorrect": false,
              "misconceptionId": "CLEANING_DATA_LOSS",
              "feedback": {
                "short": "Not quite! Ignoring missing values can cause analysis errors.",
                "detailed": "Many operations fail or give wrong results with missing values. `mean()` automatically excludes them (which may be fine), but comparisons and models often break. Always make an explicit decision: drop, fill, or flag.",
                "socraticHint": "What happens when you calculate salary averages if some values are missing?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Fill with median salary or use domain knowledge for imputation",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l17-q4",
          "globalId": "exit-ticket-0434",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "What would happen if an e-commerce model is trained on data with bot traffic and duplicates?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "ML_DATA_QUALITY_IMPACT",
            "PROCESS_DISMISSAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "Better performance",
              "isCorrect": false,
              "misconceptionId": "ML_DATA_QUALITY_IMPACT",
              "feedback": {
                "short": "Not quite! Garbage in, garbage out—dirty data hurts models.",
                "detailed": "Bot traffic and duplicates are noise, not signal. More data isn't always better. The model would learn bot behavior patterns (like rapid page views) as if they were human, making predictions useless for real customers.",
                "socraticHint": "Would a model trained on bot clicks accurately predict what humans want to buy?"
              }
            },
            {
              "key": "B",
              "text": "Skewed behavior patterns and biased predictions",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Dirty data leads to misleading models.",
                "detailed": "Bot traffic creates fake patterns (artificial spikes, non-human behavior). Duplicates over-weight certain records. The model learns these distortions as 'normal', leading to recommendations and predictions that don't match real customer behavior."
              }
            },
            {
              "key": "C",
              "text": "Faster training",
              "isCorrect": false,
              "misconceptionId": "PROCESS_DISMISSAL",
              "feedback": {
                "short": "Not quite! More rows (including junk) actually SLOW training.",
                "detailed": "Duplicates and bot traffic ADD rows to process, making training slower. And the extra computation is wasted on learning noise. Clean data trains faster AND produces better models.",
                "socraticHint": "Would processing 10 million bot visits help or hurt training time?"
              }
            },
            {
              "key": "D",
              "text": "No effect",
              "isCorrect": false,
              "misconceptionId": "ML_DATA_QUALITY_IMPACT",
              "feedback": {
                "short": "Not quite! Data quality has MAJOR effects on model quality.",
                "detailed": "Models learn from their training data. If 30% of your data is bot traffic, the model learns 30% bot behavior. Duplicates make certain patterns seem more common than they are. Data quality directly determines model quality.",
                "socraticHint": "If a recommendation system learned from bot clicks, what would it recommend?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Skewed behavior patterns and biased predictions",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l17-q5",
          "globalId": "exit-ticket-0435",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why does data preparation take 80% of a data scientist's time?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PROCESS_DISMISSAL",
            "TOOL_PURPOSE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Data scientists are slow",
              "isCorrect": false,
              "misconceptionId": "PROCESS_DISMISSAL",
              "feedback": {
                "short": "Not quite! The time reflects the complexity of real-world data, not skill level.",
                "detailed": "Expert data scientists also spend 80% on preparation. Real data has inconsistencies, missing values, formatting issues, and requires understanding context. Speed isn't the issue—thoroughness is essential for quality analysis.",
                "socraticHint": "Would rushing through data preparation make the final analysis better or worse?"
              }
            },
            {
              "key": "B",
              "text": "Real data is messy and requires domain knowledge and multiple iterations",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! The 80/20 rule reflects the reality of working with imperfect data.",
                "detailed": "Real-world data has quality issues, inconsistent formats, missing context, and requires understanding the business domain. Each discovery leads to new questions. This iterative, knowledge-intensive process simply takes time—but it's essential for reliable analysis."
              }
            },
            {
              "key": "C",
              "text": "Tools are bad",
              "isCorrect": false,
              "misconceptionId": "TOOL_PURPOSE_CONFUSION",
              "feedback": {
                "short": "Not quite! Tools like Pandas are excellent—the data itself is the challenge.",
                "detailed": "Modern tools (Pandas, Python) are powerful and well-designed. The challenge is understanding messy data, making judgment calls about cleaning, and knowing what 'clean' means for your specific analysis. No tool can automatically know your domain.",
                "socraticHint": "Even with perfect tools, would you still need to decide HOW to handle missing values?"
              }
            },
            {
              "key": "D",
              "text": "It's unnecessary work",
              "isCorrect": false,
              "misconceptionId": "PROCESS_DISMISSAL",
              "feedback": {
                "short": "Not quite! Skipping data preparation leads to garbage results.",
                "detailed": "The 80% spent on preparation ENABLES meaningful analysis. Analyzing dirty data produces misleading conclusions. Models trained on messy data make wrong predictions. Every minute of preparation saves hours of debugging wrong results later.",
                "socraticHint": "What happens to your analysis conclusions if your data has 20% duplicates you didn't remove?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Real data is messy and requires domain knowledge and multiple iterations",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-18",
      "lessonNumber": 18,
      "lessonTitle": "Data Manipulation with Pandas\n\n### Q1: Vocabulary/Concepts\nWhat does \"grouping\" mean in data analysis?\nA) Putting data in folders\nB) Organizing data by categories for analysis ✓\nC) Sorting data alphabetically\nD) Deleting unwanted data\n\n### Q2: Code Understanding\nWhat does this code calculate?\n```python\ndf.groupby(\"Department\")[\"Salary\"].mean().sort_values(ascending=False)\n```\nA) Average salary by department, sorted highest to lowest ✓\nB) Total salary by department\nC) Number of employees per department\nD) Highest salary in each department\n\n### Q3: Problem-Solving\nHow would you find students who scored above 85 in any subject?\nA) `df[df.max() > 85]`\nB) `df[df[[\"Math\", \"Science\", \"English\"]] > 85].any(axis=1)]` ✓\nC) `df.filter(score > 85)`\nD) `df.where(score > 85)`\n\n### Q4: Application\nWhat analysis would help an e-commerce company understand their sales performance?\nA) Only total sales\nB) Sales by category, top regions, high-performing products, trends over time ✓\nC) Only customer count\nD) Only product names\n\n### Q5: Reflection/Meta-learning\nHow do you approach complex data manipulation tasks?\nA) Try random operations until something works\nB) Break into smaller steps, test each step, understand business requirements ✓\nC) Use only simple operations\nD) Ask someone else to do it\n\n---",
      "lessonSlug": "data-manipulation-with-pandas-q1-vocabularyconcepts-what-does-grouping-mean-in-data-analysis-a-putting-data-in-folders-b-organizing-data-by-categories-for-analysis-c-sorting-data-alphabetically-d-deleting-unwanted-data-q2-code-understanding-what-does-this-code-calculate-python-dfgroupbydepartmentsalarymeansort_valuesascendingfalse-a-average-salary-by-department-sorted-highest-to-lowest-b-total-salary-by-department-c-number-of-employees-per-department-d-highest-salary-in-each-department-q3-problem-solving-how-would-you-find-students-who-scored-above-85-in-any-subject-a-dfdfmax-85-b-dfdfmath-science-english-85anyaxis1-c-dffilterscore-85-d-dfwherescore-85-q4-application-what-analysis-would-help-an-e-commerce-company-understand-their-sales-performance-a-only-total-sales-b-sales-by-category-top-regions-high-performing-products-trends-over-time-c-only-customer-count-d-only-product-names-q5-reflectionmeta-learning-how-do-you-approach-complex-data-manipulation-tasks-a-try-random-operations-until-something-works-b-break-into-smaller-steps-test-each-step-understand-business-requirements-c-use-only-simple-operations-d-ask-someone-else-to-do-it",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l18-q1",
          "globalId": "exit-ticket-0436",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What does \"grouping\" mean in data analysis?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "TERM_CROSS_DOMAIN",
            "PANDAS_GROUPBY_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Putting data in folders",
              "isCorrect": false,
              "misconceptionId": "TERM_CROSS_DOMAIN",
              "feedback": {
                "short": "Not quite! Grouping in data analysis is about categorizing within a dataset.",
                "detailed": "File system folders are a different concept. Data grouping means organizing ROWS by a category column (like 'Department') so you can calculate aggregates (mean, sum, count) for each category. The data stays in one DataFrame.",
                "socraticHint": "How would you calculate average salary per department without moving data to separate files?"
              }
            },
            {
              "key": "B",
              "text": "Organizing data by categories for analysis",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Grouping partitions data by category for aggregate calculations.",
                "detailed": "Grouping splits your data into subsets based on unique values in a column (like Department). You can then apply aggregations (mean, sum, count) to each group. This is the 'split-apply-combine' pattern—essential for comparative analysis."
              }
            },
            {
              "key": "C",
              "text": "Sorting data alphabetically",
              "isCorrect": false,
              "misconceptionId": "PANDAS_GROUPBY_CONFUSION",
              "feedback": {
                "short": "Not quite! Sorting orders data; grouping categorizes it.",
                "detailed": "Sorting arranges rows in order (A-Z, 1-100). Grouping PARTITIONS data into subsets by category for separate calculations. You might sort AFTER grouping, but they're different operations: `df.sort_values()` vs `df.groupby()`.",
                "socraticHint": "Sorted data is still one continuous list. Grouped data is split into categories—what's the difference?"
              }
            },
            {
              "key": "D",
              "text": "Deleting unwanted data",
              "isCorrect": false,
              "misconceptionId": "PANDAS_GROUPBY_CONFUSION",
              "feedback": {
                "short": "Not quite! Grouping preserves all data—it just organizes it.",
                "detailed": "Grouping doesn't remove any data. It creates logical partitions for analysis. `df.groupby('Dept')` keeps all rows but lets you analyze each department separately. Deleting is a different operation (`drop()` or boolean filtering).",
                "socraticHint": "After grouping by department, does the Sales department data disappear or become accessible separately?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Organizing data by categories for analysis",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l18-q2",
          "globalId": "exit-ticket-0437",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What does this code calculate?",
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "df.groupby(\"Department\")[\"Salary\"].mean().sort_values(ascending=False)",
          "misconceptionTargets": [
            "PANDAS_METHOD_CONFUSION",
            "PANDAS_GROUPBY_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Average salary by department, sorted highest to lowest",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! The chain is: group → select column → average → sort descending.",
                "detailed": "Reading left to right: `groupby('Department')` partitions by department, `['Salary']` selects salary column, `.mean()` calculates average per group, `.sort_values(ascending=False)` sorts highest first."
              }
            },
            {
              "key": "B",
              "text": "Total salary by department",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! `.mean()` calculates average, not total.",
                "detailed": "For total, you'd use `.sum()`. The code uses `.mean()` which divides the sum by count. mean() = average per department; sum() = total per department. Different aggregations answer different questions.",
                "socraticHint": "If Engineering has 10 employees totaling $1M in salary, what's the mean vs sum?"
              }
            },
            {
              "key": "C",
              "text": "Number of employees per department",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! Use `.count()` or `.size()` for counting.",
                "detailed": "`.mean()` calculates average value. To count rows per group, use `.count()` (counts non-null values) or `.size()` (counts all rows). The code specifically calculates SALARY average, not employee count.",
                "socraticHint": "What method would you use if you wanted to know how many employees are in each department?"
              }
            },
            {
              "key": "D",
              "text": "Highest salary in each department",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! Use `.max()` for highest values.",
                "detailed": "`.mean()` = average (sum ÷ count). `.max()` = highest single value. The code calculates what the typical salary IS in each department, not who earns the most.",
                "socraticHint": "If a department has salaries [50K, 60K, 70K, 80K], what's the mean vs max?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Average salary by department, sorted highest to lowest",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "python"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l18-q3",
          "globalId": "exit-ticket-0438",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "blockmodel",
          "prompt": "How would you find students who scored above 85 in any subject?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PANDAS_SYNTAX_CONFUSION",
            "API_HALLUCINATION"
          ],
          "options": [
            {
              "key": "A",
              "text": "`df[df.max() > 85]`",
              "isCorrect": false,
              "misconceptionId": "PANDAS_SYNTAX_CONFUSION",
              "feedback": {
                "short": "Not quite! `.max()` without axis returns a Series of column max values, not row-wise filtering.",
                "detailed": "This code compares column maximums to 85, not individual student scores. To check 'any subject per student,' you need row-wise logic: `(df > 85).any(axis=1)` returns True for each ROW where at least one column exceeds 85.",
                "socraticHint": "What does axis=1 do differently than no axis parameter?"
              }
            },
            {
              "key": "B",
              "text": "`df[df[[\"Math\", \"Science\", \"English\"]] > 85].any(axis=1)]`",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This checks multiple columns and keeps rows where ANY subject exceeds 85.",
                "detailed": "Breaking it down: `df[['Math','Science','English']] > 85` creates a boolean DataFrame. `.any(axis=1)` collapses each row to True if ANY column is True. The outer `df[...]` filters to only those students."
              }
            },
            {
              "key": "C",
              "text": "`df.filter(score > 85)`",
              "isCorrect": false,
              "misconceptionId": "API_HALLUCINATION",
              "feedback": {
                "short": "Not quite! `.filter()` selects columns by name pattern, not by value condition.",
                "detailed": "Pandas' `.filter()` is for selecting columns (like grep for column names), not for filtering rows by values. For value-based filtering, use boolean indexing: `df[condition]`. Also, 'score' is undefined here.",
                "socraticHint": "What pandas method would you use to keep only rows matching a value condition?"
              }
            },
            {
              "key": "D",
              "text": "`df.where(score > 85)`",
              "isCorrect": false,
              "misconceptionId": "API_HALLUCINATION",
              "feedback": {
                "short": "Not quite! `.where()` keeps shape and replaces non-matching values with NaN—it doesn't filter rows.",
                "detailed": "`.where(condition)` is like Excel's IF function: keep value if True, else NaN. It preserves all rows/columns. For actually REMOVING rows, use boolean indexing `df[condition]`. Also, 'score' is undefined—you need column references.",
                "socraticHint": "What's the difference between replacing values with NaN versus removing rows entirely?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "`df[df[[\"Math\", \"Science\", \"English\"]] > 85].any(axis=1)]`",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l18-q4",
          "globalId": "exit-ticket-0439",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "What analysis would help an e-commerce company understand their sales performance?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_SINGLE_DIMENSION",
            "STATS_SINGLE_METRIC"
          ],
          "options": [
            {
              "key": "A",
              "text": "Only total sales",
              "isCorrect": false,
              "misconceptionId": "STATS_SINGLE_METRIC",
              "feedback": {
                "short": "Not quite! Total sales is just ONE number—it hides crucial patterns.",
                "detailed": "$1M total could be 10 products selling evenly OR 1 product dominating. Without breakdown by category, region, and time, you can't identify WHAT's working, WHERE, or whether you're growing or declining.",
                "socraticHint": "If sales doubled this quarter, would that one number tell you which products drove the growth?"
              }
            },
            {
              "key": "B",
              "text": "Sales by category, top regions, high-performing products, trends over time",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Multi-dimensional analysis reveals actionable patterns.",
                "detailed": "This covers the '5 W's of data': WHAT (categories), WHERE (regions), WHO (products), WHEN (trends). Each dimension answers different business questions: 'Where should we expand?' 'Which products need marketing?' 'Are we growing?'"
              }
            },
            {
              "key": "C",
              "text": "Only customer count",
              "isCorrect": false,
              "misconceptionId": "STATS_SINGLE_METRIC",
              "feedback": {
                "short": "Not quite! Customer count alone doesn't reveal revenue or profitability.",
                "detailed": "1000 customers spending $10 each = $10K. 100 customers spending $1000 each = $100K. Customer count matters, but without revenue per customer, purchase frequency, and retention rates, you can't assess actual PERFORMANCE.",
                "socraticHint": "Would you rather have many low-spending customers or fewer high-spending ones?"
              }
            },
            {
              "key": "D",
              "text": "Only product names",
              "isCorrect": false,
              "misconceptionId": "DATA_SINGLE_DIMENSION",
              "feedback": {
                "short": "Not quite! A list of product names contains zero performance information.",
                "detailed": "Knowing 'we sell shoes, hats, shirts' tells you nothing about WHICH are profitable, how many sold, or growth trends. Performance analysis requires METRICS (sales, revenue, growth) attached to dimensions (products, regions, time).",
                "socraticHint": "What numerical data would you need to determine which products are your 'winners'?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Sales by category, top regions, high-performing products, trends over time",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l18-q5",
          "globalId": "exit-ticket-0440",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "How do you approach complex data manipulation tasks?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PROCESS_DISMISSAL",
            "DATA_WORKFLOW_SKIP"
          ],
          "options": [
            {
              "key": "A",
              "text": "Try random operations until something works",
              "isCorrect": false,
              "misconceptionId": "PROCESS_DISMISSAL",
              "feedback": {
                "short": "Not quite! Trial-and-error wastes time and risks introducing bugs.",
                "detailed": "Random attempts might eventually work, but you won't understand WHY, making debugging nearly impossible. Professional data work requires methodical problem decomposition: understand the goal → plan the steps → execute → validate.",
                "socraticHint": "If random code 'works' but gives wrong results, how would you even know something's wrong?"
              }
            },
            {
              "key": "B",
              "text": "Break into smaller steps, test each step, understand business requirements",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Decomposition + validation is the professional approach.",
                "detailed": "This mirrors software engineering best practices: 1) Understand requirements (what's the business question?), 2) Decompose into steps (filter → group → aggregate → sort), 3) Test each step's output before proceeding. Errors caught early are 10x easier to fix."
              }
            },
            {
              "key": "C",
              "text": "Use only simple operations",
              "isCorrect": false,
              "misconceptionId": "DATA_WORKFLOW_SKIP",
              "feedback": {
                "short": "Not quite! Complex problems require appropriate tools—avoiding complexity isn't a strategy.",
                "detailed": "Simple operations like counting can't solve grouping, joining, or pivoting problems. The goal isn't to avoid complexity but to MANAGE it through decomposition. A complex chain like `df.groupby().agg().sort_values()` is fine when each step is understood.",
                "socraticHint": "If you needed average salary BY department, could a simple sum() or count() alone answer that?"
              }
            },
            {
              "key": "D",
              "text": "Ask someone else to do it",
              "isCorrect": false,
              "misconceptionId": "PROCESS_DISMISSAL",
              "feedback": {
                "short": "Not quite! Delegation without learning prevents skill development.",
                "detailed": "Asking for help is appropriate when stuck, but 'always delegate' means you'll never develop the skills. The professional approach: try decomposition first, identify the specific blocking step, THEN ask targeted questions about that step.",
                "socraticHint": "How would you phrase a good question about a specific step you're stuck on?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Break into smaller steps, test each step, understand business requirements",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-19",
      "lessonNumber": 19,
      "lessonTitle": "Data Grouping and Data Joining with Pandas\n\n### Q1: Vocabulary/Concepts\nWhat is the difference between inner join and left join?\nA) No difference\nB) Inner join keeps only matching rows, left join keeps all rows from left dataset ✓\nC) Left join is faster than inner join\nD) Inner join is for numbers, left join is for text\n\n### Q2: Code Understanding\nWhat will this result contain?\n```python\nresult = products.merge(total_sales, on=\"Product_ID\", how=\"left\")\n```\nA) Only products with sales data\nB) All products, with sales data where available (NaN where missing) ✓\nC) Only sales data\nD) Products and sales combined randomly\n\n### Q3: Problem-Solving\nHow would you calculate each student's average score and combine it with their basic information?\nA) Use groupby to calculate averages, then merge with student info ✓\nB) Calculate averages manually for each student\nC) Use only the highest score per student\nD) Don't combine the data\n\n### Q4: Application\nWhat's the best approach for analyzing employee compensation across departments?\nA) Look at base salaries only\nB) Merge employee, salary, and bonus data; then group by department ✓\nC) Use only bonus data\nD) Analyze each dataset separately\n\n### Q5: Reflection/Meta-learning\nHow do you ensure data integrity when joining datasets?\nA) Always use inner joins\nB) Check data quality, understand business logic, validate results ✓\nC) Never check the results\nD) Use only left joins\n\n---",
      "lessonSlug": "data-grouping-and-data-joining-with-pandas-q1-vocabularyconcepts-what-is-the-difference-between-inner-join-and-left-join-a-no-difference-b-inner-join-keeps-only-matching-rows-left-join-keeps-all-rows-from-left-dataset-c-left-join-is-faster-than-inner-join-d-inner-join-is-for-numbers-left-join-is-for-text-q2-code-understanding-what-will-this-result-contain-python-result-productsmergetotal_sales-onproduct_id-howleft-a-only-products-with-sales-data-b-all-products-with-sales-data-where-available-nan-where-missing-c-only-sales-data-d-products-and-sales-combined-randomly-q3-problem-solving-how-would-you-calculate-each-students-average-score-and-combine-it-with-their-basic-information-a-use-groupby-to-calculate-averages-then-merge-with-student-info-b-calculate-averages-manually-for-each-student-c-use-only-the-highest-score-per-student-d-dont-combine-the-data-q4-application-whats-the-best-approach-for-analyzing-employee-compensation-across-departments-a-look-at-base-salaries-only-b-merge-employee-salary-and-bonus-data-then-group-by-department-c-use-only-bonus-data-d-analyze-each-dataset-separately-q5-reflectionmeta-learning-how-do-you-ensure-data-integrity-when-joining-datasets-a-always-use-inner-joins-b-check-data-quality-understand-business-logic-validate-results-c-never-check-the-results-d-use-only-left-joins",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l19-q1",
          "globalId": "exit-ticket-0441",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the difference between inner join and left join?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "JOIN_TYPE_CONFUSION",
            "TERM_IRRELEVANT_DISTINCTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "No difference",
              "isCorrect": false,
              "misconceptionId": "JOIN_TYPE_CONFUSION",
              "feedback": {
                "short": "Not quite! Inner and left joins produce very different results.",
                "detailed": "Inner join: keeps ONLY rows that exist in BOTH datasets (intersection). Left join: keeps ALL rows from the left table, filling NaN where right table has no match. Result sizes can differ dramatically!",
                "socraticHint": "If left table has 100 products but right table only has sales for 60, how many rows would each join type return?"
              }
            },
            {
              "key": "B",
              "text": "Inner join keeps only matching rows, left join keeps all rows from left dataset",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the fundamental distinction between join types.",
                "detailed": "Think of inner as 'intersection' (both must match) and left as 'preserve primary + add related'. Left join is common when you want to keep all records from your main dataset even if related data is missing."
              }
            },
            {
              "key": "C",
              "text": "Left join is faster than inner join",
              "isCorrect": false,
              "misconceptionId": "TERM_IRRELEVANT_DISTINCTION",
              "feedback": {
                "short": "Not quite! Join type choice is about DATA INCLUSION, not speed.",
                "detailed": "Performance depends on data size, indexes, and database optimization—not the join type itself. You choose inner vs left based on whether you want to KEEP or EXCLUDE rows with no match. Speed is secondary to correctness.",
                "socraticHint": "If a left join is slower but gives you the answer you need, would you switch to inner just for speed?"
              }
            },
            {
              "key": "D",
              "text": "Inner join is for numbers, left join is for text",
              "isCorrect": false,
              "misconceptionId": "TYPE_FUNCTION_RESTRICTION",
              "feedback": {
                "short": "Not quite! Join type has nothing to do with data types.",
                "detailed": "Both join types work with ANY matching columns—strings, numbers, dates. The choice is about which ROWS to keep: inner = only matches, left = all from primary table. The join KEY can be any comparable type.",
                "socraticHint": "Could you join customer names to order names? Would that be inner or left?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Inner join keeps only matching rows, left join keeps all rows from left dataset",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l19-q2",
          "globalId": "exit-ticket-0442",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What will this result contain?",
          "hasCodeBlock": true,
          "codeLanguage": "python",
          "codeContent": "result = products.merge(total_sales, on=\"Product_ID\", how=\"left\")",
          "misconceptionTargets": [
            "JOIN_TYPE_CONFUSION",
            "PANDAS_MERGE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Only products with sales data",
              "isCorrect": false,
              "misconceptionId": "JOIN_TYPE_CONFUSION",
              "feedback": {
                "short": "Not quite! That describes an INNER join, not a LEFT join.",
                "detailed": "`how='left'` means: keep ALL rows from the LEFT table (products), regardless of matches. `how='inner'` would filter to only products with matching sales. The 'left' preserves your complete product catalog.",
                "socraticHint": "If you have 100 products but only 60 have sales, which join type loses 40 products?"
              }
            },
            {
              "key": "B",
              "text": "All products, with sales data where available (NaN where missing)",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Left join preserves all left-side rows, filling NaN for non-matches.",
                "detailed": "The 'left' DataFrame (products) drives the result. Every product appears regardless of sales. Products without matching sales get NaN in sales columns. This is useful for reports like 'all products including those with no sales yet.'"
              }
            },
            {
              "key": "C",
              "text": "Only sales data",
              "isCorrect": false,
              "misconceptionId": "PANDAS_MERGE_CONFUSION",
              "feedback": {
                "short": "Not quite! That would describe a RIGHT join, not left.",
                "detailed": "Left join keeps all rows from the LEFT table (products). To keep only the right table's rows, you'd use `how='right'`. The direction word tells you which table is preserved completely.",
                "socraticHint": "In `A.merge(B, how='left')`, which DataFrame's rows are guaranteed to appear?"
              }
            },
            {
              "key": "D",
              "text": "Products and sales combined randomly",
              "isCorrect": false,
              "misconceptionId": "PANDAS_MERGE_CONFUSION",
              "feedback": {
                "short": "Not quite! Joins are deterministic—they match on specified keys.",
                "detailed": "The `on='Product_ID'` parameter ensures rows are matched by Product_ID, not randomly. Each product row joins to sales rows with the SAME Product_ID. No randomness involved—it's precise key matching.",
                "socraticHint": "What happens if two rows have the same Product_ID in both tables?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "All products, with sales data where available (NaN where missing)",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "python"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l19-q3",
          "globalId": "exit-ticket-0443",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "bebras",
          "prompt": "How would you calculate each student's average score and combine it with their basic information?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_WORKFLOW_MANUAL",
            "DATA_INCOMPLETE_SOLUTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Use groupby to calculate averages, then merge with student info",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This is the split-apply-combine + join pattern.",
                "detailed": "Step 1: `scores.groupby('student_id')['score'].mean()` aggregates per student. Step 2: `students.merge(avg_scores, on='student_id')` combines with student info. This pattern scales to millions of records—manual calculation would not."
              }
            },
            {
              "key": "B",
              "text": "Calculate averages manually for each student",
              "isCorrect": false,
              "misconceptionId": "DATA_WORKFLOW_MANUAL",
              "feedback": {
                "short": "Not quite! Manual calculation doesn't scale and is error-prone.",
                "detailed": "With 1000 students, manual calculation means 1000 separate operations. One typo corrupts results. `groupby().mean()` handles this in ONE line, automatically. Programming is about automating repetitive work!",
                "socraticHint": "If you had 10,000 students, how long would manual calculation take vs one groupby() call?"
              }
            },
            {
              "key": "C",
              "text": "Use only the highest score per student",
              "isCorrect": false,
              "misconceptionId": "DATA_INCOMPLETE_SOLUTION",
              "feedback": {
                "short": "Not quite! Highest score ≠ average score—different metrics.",
                "detailed": "The question asks for AVERAGE, not MAX. Highest ignores all other scores. A student with [100, 50, 50, 50] has max=100 but avg=62.5. Using max would misrepresent performance.",
                "socraticHint": "For a student with scores [90, 80, 70], what's the average? What's the max?"
              }
            },
            {
              "key": "D",
              "text": "Don't combine the data",
              "isCorrect": false,
              "misconceptionId": "DATA_INCOMPLETE_SOLUTION",
              "feedback": {
                "short": "Not quite! The question explicitly asks to COMBINE with basic info.",
                "detailed": "A complete student performance view requires both: aggregated metrics (average) AND context (name, grade level). Separate datasets require mental joins—error-prone and inconvenient. Merging creates a single source of truth.",
                "socraticHint": "If you had a list of averages without names, how would you know which student is which?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Use groupby to calculate averages, then merge with student info",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "rag",
              "retrieval"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l19-q4",
          "globalId": "exit-ticket-0444",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "What's the best approach for analyzing employee compensation across departments?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_SINGLE_DIMENSION",
            "DATA_INCOMPLETE_SOLUTION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Look at base salaries only",
              "isCorrect": false,
              "misconceptionId": "DATA_SINGLE_DIMENSION",
              "feedback": {
                "short": "Not quite! Base salary alone misses bonuses, commissions, and benefits.",
                "detailed": "Total compensation = salary + bonus + benefits + equity. An employee with $80K salary + $40K bonus earns more than one with $100K salary alone. Partial data leads to incorrect rankings and decisions.",
                "socraticHint": "If Engineering has lower salaries but higher bonuses, would salary-only analysis fairly compare departments?"
              }
            },
            {
              "key": "B",
              "text": "Merge employee, salary, and bonus data; then group by department",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This combines all compensation components and enables departmental comparison.",
                "detailed": "The workflow: 1) Merge datasets to get complete compensation per employee, 2) Group by department for aggregates (avg, median, total). This gives a holistic view: 'Engineering avg total comp is $150K; Sales is $120K.'"
              }
            },
            {
              "key": "C",
              "text": "Use only bonus data",
              "isCorrect": false,
              "misconceptionId": "DATA_SINGLE_DIMENSION",
              "feedback": {
                "short": "Not quite! Bonus alone ignores base salary—the largest component.",
                "detailed": "Bonuses are typically 10-30% of total comp. Ignoring the 70-90% (salary) gives a distorted picture. Some departments might have low bonuses but high salaries, appearing underpaid when they're actually well-compensated.",
                "socraticHint": "Would you rather have a $10K bonus with $50K salary, or $5K bonus with $100K salary?"
              }
            },
            {
              "key": "D",
              "text": "Analyze each dataset separately",
              "isCorrect": false,
              "misconceptionId": "DATA_INCOMPLETE_SOLUTION",
              "feedback": {
                "short": "Not quite! Separate analysis can't answer cross-dataset questions.",
                "detailed": "Knowing 'avg salary is $80K' and 'avg bonus is $15K' separately doesn't tell you total compensation BY DEPARTMENT. You need to JOIN the data first to calculate per-employee totals, THEN group by department.",
                "socraticHint": "If employee #123 has $90K salary (from one dataset) and $20K bonus (from another), where do you calculate their $110K total?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Merge employee, salary, and bonus data; then group by department",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l19-q5",
          "globalId": "exit-ticket-0445",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "How do you ensure data integrity when joining datasets?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "JOIN_TYPE_CONFUSION",
            "PROCESS_DISMISSAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "Always use inner joins",
              "isCorrect": false,
              "misconceptionId": "JOIN_TYPE_CONFUSION",
              "feedback": {
                "short": "Not quite! Join type choice depends on the business question, not a blanket rule.",
                "detailed": "Inner joins silently DROP unmatched rows. If a customer has no orders, inner join removes them entirely. Sometimes that's correct; sometimes you NEED to see customers with zero orders. The right join type depends on what question you're answering.",
                "socraticHint": "If you want to find 'products with no sales,' would inner join help or hurt?"
              }
            },
            {
              "key": "B",
              "text": "Check data quality, understand business logic, validate results",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Data integrity requires systematic validation at each step.",
                "detailed": "Professional workflow: 1) Check source data quality (duplicates, nulls, types), 2) Understand business rules (should all keys match? one-to-one or one-to-many?), 3) Validate results (row counts, spot-check samples, check for unexpected nulls). Trust but verify!"
              }
            },
            {
              "key": "C",
              "text": "Never check the results",
              "isCorrect": false,
              "misconceptionId": "PROCESS_DISMISSAL",
              "feedback": {
                "short": "Not quite! Unchecked results are unreliable results.",
                "detailed": "Joins can silently produce wrong results: unexpected nulls, duplicate rows (many-to-many), dropped records. Without validation, you might make decisions on corrupted data. Always check: row counts before/after, null distribution, sample verification.",
                "socraticHint": "If a join doubled your row count, how would you know without checking?"
              }
            },
            {
              "key": "D",
              "text": "Use only left joins",
              "isCorrect": false,
              "misconceptionId": "JOIN_TYPE_CONFUSION",
              "feedback": {
                "short": "Not quite! Left join isn't universally correct—it depends on requirements.",
                "detailed": "Left join keeps all left-side rows, but sometimes you WANT to exclude non-matches. 'Active customers with recent purchases' might need inner join to exclude dormant accounts. Choose join type based on what the analysis REQUIRES, not a default rule.",
                "socraticHint": "For a report of 'employees currently in a department,' would you want former employees with NULL department?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Check data quality, understand business logic, validate results",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "ai-1-lesson-20",
      "lessonNumber": 20,
      "lessonTitle": "Data Interpretation and Report Making\n\n### Q1: Vocabulary/Concepts\nWhat is the difference between data analysis and data interpretation?\nA) No difference\nB) Analysis examines data, interpretation explains what patterns mean ✓\nC) Analysis is harder than interpretation\nD) Interpretation comes before analysis\n\n### Q2: Code Understanding\nWhat insight does this provide: `df['Revenue'].sum()`?\nA) Average order value\nB) Total business performance/revenue ✓\nC) Number of orders\nD) Revenue per customer\n\n### Q3: Problem-Solving\nWhat should a student performance report include?\nA) Only test scores\nB) Summary statistics, trends, at-risk students, recommendations ✓\nC) Only averages\nD) Only the highest scores\n\n### Q4: Application\nHow should a marketing team present campaign performance to executives?\nA) Show only raw data\nB) Executive summary, key metrics, performance ranking, actionable recommendations ✓\nC) Technical details only\nD) Just the total cost\n\n### Q5: Reflection/Meta-learning\nHow do you make data reports accessible to non-technical stakeholders?\nA) Use more technical terms\nB) Clear language, focus on insights, include visualizations, provide context ✓\nC) Show only numbers\nD) Make reports as long as possible",
      "lessonSlug": "data-interpretation-and-report-making-q1-vocabularyconcepts-what-is-the-difference-between-data-analysis-and-data-interpretation-a-no-difference-b-analysis-examines-data-interpretation-explains-what-patterns-mean-c-analysis-is-harder-than-interpretation-d-interpretation-comes-before-analysis-q2-code-understanding-what-insight-does-this-provide-dfrevenuesum-a-average-order-value-b-total-business-performancerevenue-c-number-of-orders-d-revenue-per-customer-q3-problem-solving-what-should-a-student-performance-report-include-a-only-test-scores-b-summary-statistics-trends-at-risk-students-recommendations-c-only-averages-d-only-the-highest-scores-q4-application-how-should-a-marketing-team-present-campaign-performance-to-executives-a-show-only-raw-data-b-executive-summary-key-metrics-performance-ranking-actionable-recommendations-c-technical-details-only-d-just-the-total-cost-q5-reflectionmeta-learning-how-do-you-make-data-reports-accessible-to-non-technical-stakeholders-a-use-more-technical-terms-b-clear-language-focus-on-insights-include-visualizations-provide-context-c-show-only-numbers-d-make-reports-as-long-as-possible",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "ai-1-l20-q1",
          "globalId": "exit-ticket-0446",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the difference between data analysis and data interpretation?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "TERM_CROSS_DOMAIN",
            "DATA_WORKFLOW_ORDER"
          ],
          "options": [
            {
              "key": "A",
              "text": "No difference",
              "isCorrect": false,
              "misconceptionId": "TERM_CROSS_DOMAIN",
              "feedback": {
                "short": "Not quite! They're distinct phases of the data workflow.",
                "detailed": "Analysis = WHAT (calculate averages, find correlations, identify outliers). Interpretation = SO WHAT (explain why patterns exist, what actions to take). Analysis produces numbers; interpretation produces insights and recommendations.",
                "socraticHint": "If analysis shows '20% sales drop,' what interpretation would explain WHY?"
              }
            },
            {
              "key": "B",
              "text": "Analysis examines data, interpretation explains what patterns mean",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Analysis finds patterns; interpretation gives them meaning.",
                "detailed": "Think of analysis as the 'lab work' (computing metrics, spotting trends) and interpretation as the 'diagnosis' (what the numbers MEAN for the business). Both are essential: analysis without interpretation is just numbers; interpretation without analysis is just opinion."
              }
            },
            {
              "key": "C",
              "text": "Analysis is harder than interpretation",
              "isCorrect": false,
              "misconceptionId": "TERM_IRRELEVANT_DISTINCTION",
              "feedback": {
                "short": "Not quite! Difficulty isn't what distinguishes them—purpose is.",
                "detailed": "Both require skill: analysis needs technical expertise (statistics, coding); interpretation needs domain knowledge (understanding the business context). The distinction is about WHAT you're doing, not how hard it is.",
                "socraticHint": "Would a sports statistician or a coach be better at interpreting player performance data?"
              }
            },
            {
              "key": "D",
              "text": "Interpretation comes before analysis",
              "isCorrect": false,
              "misconceptionId": "DATA_WORKFLOW_ORDER",
              "feedback": {
                "short": "Not quite! You need data patterns BEFORE you can interpret them.",
                "detailed": "The sequence is: Collect → Clean → Analyze → Interpret → Report. Interpretation requires analysis output. You can't explain what patterns mean until you've FOUND the patterns. (Though you might form hypotheses beforehand.)",
                "socraticHint": "Can you explain what a 20% drop means before you've calculated that there IS a 20% drop?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Analysis examines data, interpretation explains what patterns mean",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l20-q2",
          "globalId": "exit-ticket-0447",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "trace",
          "prompt": "What insight does this provide: `df['Revenue'].sum()`?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "PANDAS_METHOD_CONFUSION",
            "STATS_MEASURE_CONFUSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Average order value",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! `.sum()` adds all values; `.mean()` calculates average.",
                "detailed": "sum() = total (add everything). mean() = average (sum ÷ count). If 10 orders total $1000, sum=$1000, mean=$100. They answer different questions: 'How much total?' vs 'How much per order?'",
                "socraticHint": "What method would you use to find the average revenue per order?"
              }
            },
            {
              "key": "B",
              "text": "Total business performance/revenue",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! `.sum()` on Revenue gives total revenue—a key business metric.",
                "detailed": "This is a top-line business metric: 'How much money did we make?' It's the foundation for many analyses: comparing periods, calculating growth rates, or understanding scale. Often the first number executives want to see."
              }
            },
            {
              "key": "C",
              "text": "Number of orders",
              "isCorrect": false,
              "misconceptionId": "PANDAS_METHOD_CONFUSION",
              "feedback": {
                "short": "Not quite! Use `.count()` or `len()` for counting rows.",
                "detailed": "`.sum()` on Revenue adds REVENUE values, not counts rows. To count orders, use `df['Revenue'].count()` (counts non-null) or `len(df)`. sum(Revenue) = dollar total, count() = number of transactions.",
                "socraticHint": "If you have 5 orders of $20, $30, $40, $50, $60—what's sum() vs count()?"
              }
            },
            {
              "key": "D",
              "text": "Revenue per customer",
              "isCorrect": false,
              "misconceptionId": "STATS_MEASURE_CONFUSION",
              "feedback": {
                "short": "Not quite! Revenue per customer requires grouping by customer first.",
                "detailed": "`.sum()` on the whole column gives ONE number (total). For per-customer breakdown, you'd need: `df.groupby('Customer')['Revenue'].sum()`. Without groupby, there's no 'per' calculation—just a grand total.",
                "socraticHint": "What pandas method creates separate groups so you can calculate 'per' values?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Total business performance/revenue",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 60,
            "bloomsTaxonomy": "understand",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l20-q3",
          "globalId": "exit-ticket-0448",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem-Solving",
          "questionArchetype": "bebras",
          "prompt": "What should a student performance report include?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "DATA_SINGLE_DIMENSION",
            "REPORT_INCOMPLETE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Only test scores",
              "isCorrect": false,
              "misconceptionId": "DATA_SINGLE_DIMENSION",
              "feedback": {
                "short": "Not quite! Raw scores without context aren't actionable.",
                "detailed": "Scores alone don't tell teachers: Is this improving or declining? How does it compare to class average? Which students need intervention? A report needs CONTEXT (trends, comparisons) and ACTION ITEMS (who needs help, what to do).",
                "socraticHint": "If a student scored 75, is that good or bad? How would you know without context?"
              }
            },
            {
              "key": "B",
              "text": "Summary statistics, trends, at-risk students, recommendations",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Comprehensive reports combine metrics, insights, and actions.",
                "detailed": "This follows the insight → action pattern: Stats (class average, distribution) → Trends (improving/declining) → Flagging (who needs help) → Recommendations (intervention strategies). Each element serves a purpose: understanding, monitoring, prioritizing, and acting."
              }
            },
            {
              "key": "C",
              "text": "Only averages",
              "isCorrect": false,
              "misconceptionId": "STATS_SINGLE_METRIC",
              "feedback": {
                "short": "Not quite! Averages hide individual variation and trends.",
                "detailed": "A class average of 75% could mean everyone scored 75%, OR half scored 90% and half scored 60%. Averages mask the struggling students who need help. You need distribution (who's where) AND trends (who's improving/declining).",
                "socraticHint": "If the class average stayed at 75%, but Student A dropped from 90% to 60%, would the average alone catch that?"
              }
            },
            {
              "key": "D",
              "text": "Only the highest scores",
              "isCorrect": false,
              "misconceptionId": "REPORT_INCOMPLETE",
              "feedback": {
                "short": "Not quite! Highlighting top performers ignores those who need support.",
                "detailed": "Education reports should identify at-risk students—those most likely to benefit from intervention. Showing only high scores is like a doctor only reporting healthy patients. The struggling students are the ones who need attention!",
                "socraticHint": "If a teacher's goal is to help all students succeed, whose scores matter more to track?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Summary statistics, trends, at-risk students, recommendations",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 90,
            "bloomsTaxonomy": "apply",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l20-q4",
          "globalId": "exit-ticket-0449",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "How should a marketing team present campaign performance to executives?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "REPORT_AUDIENCE_MISMATCH",
            "DATA_SINGLE_DIMENSION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Show only raw data",
              "isCorrect": false,
              "misconceptionId": "REPORT_AUDIENCE_MISMATCH",
              "feedback": {
                "short": "Not quite! Executives need insights, not spreadsheets.",
                "detailed": "Raw data requires analysis skills to interpret. Executives have limited time and need the 'so what' distilled: What worked? What didn't? What should we do next? Transform data into decisions, not homework.",
                "socraticHint": "If you're a CEO with 15 minutes, would you rather see 500 rows of data or a 3-bullet summary?"
              }
            },
            {
              "key": "B",
              "text": "Executive summary, key metrics, performance ranking, actionable recommendations",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! This structure serves busy decision-makers.",
                "detailed": "Executive-ready format: 1) TL;DR summary (campaign succeeded/failed, why), 2) Key metrics (ROI, conversion, cost), 3) Rankings (best/worst performers), 4) Actions (continue X, stop Y, test Z). Enable decisions, don't dump data."
              }
            },
            {
              "key": "C",
              "text": "Technical details only",
              "isCorrect": false,
              "misconceptionId": "REPORT_AUDIENCE_MISMATCH",
              "feedback": {
                "short": "Not quite! Technical jargon alienates non-technical stakeholders.",
                "detailed": "Executives care about BUSINESS outcomes: revenue, customers, market share. 'CTR improved 0.3% via A/B test with p<0.05' matters less than 'Email campaign brought 500 new customers at $10 each.' Translate technical wins into business impact.",
                "socraticHint": "Would a CFO care more about 'conversion rate' or 'dollars generated per dollar spent'?"
              }
            },
            {
              "key": "D",
              "text": "Just the total cost",
              "isCorrect": false,
              "misconceptionId": "DATA_SINGLE_DIMENSION",
              "feedback": {
                "short": "Not quite! Cost without return is meaningless.",
                "detailed": "Spending $100K isn't bad if it generated $500K revenue. Cost alone can't assess success—you need ROI (return on investment). A comprehensive view includes: What we spent, what we got, whether it was worth it, and what to do differently.",
                "socraticHint": "Would you stop a campaign costing $100K if it was generating $1M in sales?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Executive summary, key metrics, performance ranking, actionable recommendations",
          "metadata": {
            "difficulty": "hard",
            "estimatedTime": 90,
            "bloomsTaxonomy": "analyze",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "ai-1-l20-q5",
          "globalId": "exit-ticket-0450",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "How do you make data reports accessible to non-technical stakeholders?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "REPORT_AUDIENCE_MISMATCH",
            "REPORT_INCOMPLETE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Use more technical terms",
              "isCorrect": false,
              "misconceptionId": "REPORT_AUDIENCE_MISMATCH",
              "feedback": {
                "short": "Not quite! Technical jargon creates barriers, not clarity.",
                "detailed": "Non-technical stakeholders need business language, not data science terminology. Instead of 'p-value < 0.05,' say 'statistically significant result we can trust.' The goal is UNDERSTANDING, not impressing with vocabulary.",
                "socraticHint": "If your audience doesn't know what 'correlation coefficient' means, will using it help them understand your findings?"
              }
            },
            {
              "key": "B",
              "text": "Clear language, focus on insights, include visualizations, provide context",
              "isCorrect": true,
              "feedback": {
                "short": "Correct! Accessibility means meeting your audience where they are.",
                "detailed": "The 4 pillars of accessible reporting: 1) Plain language (avoid jargon), 2) Lead with insights (what matters, not how you got there), 3) Visualize (charts > tables), 4) Context (why it matters, what to do). Your job is to translate data into decisions."
              }
            },
            {
              "key": "C",
              "text": "Show only numbers",
              "isCorrect": false,
              "misconceptionId": "REPORT_INCOMPLETE",
              "feedback": {
                "short": "Not quite! Numbers without narrative are just noise.",
                "detailed": "'Revenue: $1.2M' means nothing without context. Is that good? Bad? Growing? Declining? Numbers need interpretation: '$1.2M revenue, up 15% YoY, beating target by 10%—driven by new product launch.' Context transforms data into story.",
                "socraticHint": "If I tell you 'NPS score: 42,' can you tell if that's cause for celebration or concern?"
              }
            },
            {
              "key": "D",
              "text": "Make reports as long as possible",
              "isCorrect": false,
              "misconceptionId": "REPORT_AUDIENCE_MISMATCH",
              "feedback": {
                "short": "Not quite! Length ≠ value. Busy stakeholders need conciseness.",
                "detailed": "Long reports often go unread. Executives have minutes, not hours. Best practice: Executive summary first (key findings + recommendations), then details for those who want to dig deeper. Respect your audience's time.",
                "socraticHint": "Would a 50-page report or a 2-page summary be more likely to influence a decision?"
              }
            }
          ],
          "correctAnswer": "B",
          "correctAnswerText": "Clear language, focus on insights, include visualizations, provide context",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 60,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "artificial-intelligence",
              "ai"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2024-08-13",
            "lastModified": "2025-12-23"
          }
        }
      ]
    }
  ],
  "staticVersion": "1.0.0",
  "generatedAt": "2025-12-24T00:53:48.474Z"
}