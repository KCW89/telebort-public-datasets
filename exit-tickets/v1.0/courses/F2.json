{
  "courseId": "f2-mobile-cs-principles",
  "courseName": "F2-Mobile Computer Science Principles",
  "courseCode": "F2",
  "domain": "mobile_development",
  "tier": "intermediate",
  "difficulty": 2,
  "totalLessons": 11,
  "totalQuestions": 55,
  "sourceFile": "F2-Mobile-CS-Principles-Concepts",
  "lessons": [
    {
      "lessonId": "f2-mobile-cs-principles-lesson-1",
      "lessonNumber": 1,
      "lessonTitle": "Introduction to Program B + Explore MIT App Inventor",
      "lessonSlug": "introduction-to-program-b-explore-mit",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l1-q1",
          "globalId": "exit-ticket-f2-001",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is MIT App Inventor and what makes it special for young developers?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_GENERAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "A block-based programming tool that lets you build real mobile apps without typing code",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "A text-based programming language only for professional developers",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! MIT App Inventor uses blocks, not typed code.",
                "detailed": "MIT App Inventor was created by MIT to help anyone, especially young learners, build mobile apps by dragging and dropping colorful blocks instead of typing complicated code. It's designed to make app development accessible to everyone!",
                "socraticHint": "Think about how you learned - did the lesson show typing code or connecting blocks like puzzle pieces?"
              }
            },
            {
              "key": "C",
              "text": "A smartphone operating system like Android or iOS",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! MIT App Inventor is a development tool, not an operating system.",
                "detailed": "MIT App Inventor is a tool you use to CREATE apps that run on Android and iOS devices. It's not the operating system itself - it's like the difference between a paintbrush (tool) and a canvas (where the art appears).",
                "socraticHint": "What do you use MIT App Inventor to make? And where do those apps run?"
              }
            },
            {
              "key": "D",
              "text": "An app store where you download games and apps",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! MIT App Inventor helps you build apps, not download them.",
                "detailed": "MIT App Inventor is a tool for CREATING apps, not downloading them. Think of it like a workshop where you build toys, not a toy store where you buy them! The apps you create can later be shared and installed on phones.",
                "socraticHint": "Are you making apps or getting apps that others made?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "A block-based programming tool that lets you build real mobile apps without typing code",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "mit-app-inventor",
              "block-programming",
              "mobile-development"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l1-q2",
          "globalId": "exit-ticket-f2-002",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "You created a button in your app and want to test it. Which testing method requires WiFi to work?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_GENERAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "USB cable connection to your phone",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! USB connection works without WiFi.",
                "detailed": "USB cable connection is great when you don't have WiFi! Your phone connects directly to the computer through the cable, just like charging. The lesson showed this as Option 3 for testing when WiFi isn't available.",
                "socraticHint": "What does the cable physically connect? Can data travel through a wire without WiFi?"
              }
            },
            {
              "key": "B",
              "text": "Using an emulator on your computer",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! Emulators run on your computer without needing WiFi.",
                "detailed": "Emulators are like pretend phones that live inside your computer. Since everything is on the same computer, no WiFi is needed! It's perfect for testing when you don't have a phone or WiFi connection.",
                "socraticHint": "Where does the emulator run? Is it on your computer or a separate device?"
              }
            },
            {
              "key": "C",
              "text": "AI Companion app with QR code scanning",
              "isCorrect": true
            },
            {
              "key": "D",
              "text": "None of the above - no testing method needs WiFi",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! Some testing methods do need WiFi.",
                "detailed": "The AI Companion app needs WiFi because your computer and phone need to 'talk' to each other wirelessly. They both connect to the same WiFi network, like being in the same room to have a conversation. However, USB and emulator methods work without WiFi!",
                "socraticHint": "How does your computer send app updates to your phone when there's no cable?"
              }
            }
          ],
          "correctAnswer": "C",
          "correctAnswerText": "AI Companion app with QR code scanning",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "testing",
              "ai-companion",
              "connectivity"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l1-q3",
          "globalId": "exit-ticket-f2-003",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "Your friend wants to install the app you built on their Android phone, but they live far away. What's the best way to share your app with them?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_GENERAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "Email them the .apk file so they can download and install it",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Use the AI Companion app to connect over WiFi",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! AI Companion requires both people to be nearby on the same WiFi.",
                "detailed": "AI Companion is great for testing while building your app, but it only works when your computer and phone are on the SAME WiFi network. For sharing with friends far away, you need to build the .apk file and send it!",
                "socraticHint": "Can WiFi reach someone in another city? What happens when they're not near your computer?"
              }
            },
            {
              "key": "C",
              "text": "Connect their phone with a USB cable to your computer",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! USB requires the phone to be physically connected to your computer.",
                "detailed": "USB cables only work when the phone is plugged directly into your computer. Since your friend lives far away, you can't physically connect their phone! The .apk file can be emailed or shared online instead.",
                "socraticHint": "How long is a USB cable? Can it reach your friend's house?"
              }
            },
            {
              "key": "D",
              "text": "Have them download MIT App Inventor on their phone",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! MIT App Inventor is for building apps, not running finished apps.",
                "detailed": "MIT App Inventor is the tool YOU use to CREATE apps. Your friend just needs to install the finished app (.apk file), not the whole development tool! It's like how you don't need a kitchen to eat a cake someone baked for you.",
                "socraticHint": "Does your friend need to build the app or just use the app you already built?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Email them the .apk file so they can download and install it",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "app-distribution",
              "apk",
              "sharing"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l1-q4",
          "globalId": "exit-ticket-f2-004",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "Before installing your custom app on an Android phone, what security setting must you enable?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_GENERAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "Allow unknown sources or install unknown apps",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Enable developer mode and USB debugging",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! Developer mode is for advanced features, not installing custom apps.",
                "detailed": "Developer mode and USB debugging are for advanced testing and development. To simply install YOUR custom app, you only need to allow 'unknown sources' - this tells Android it's okay to install apps that didn't come from the official app store.",
                "socraticHint": "What does your phone need permission to do: install apps from outside the Play Store, or connect to development tools?"
              }
            },
            {
              "key": "C",
              "text": "Turn on WiFi and Bluetooth",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! WiFi and Bluetooth are for connectivity, not app installation.",
                "detailed": "WiFi and Bluetooth help your phone connect to other devices and the internet. Installing an .apk file doesn't need either one - you just need permission to install apps from sources other than the Play Store (unknown sources).",
                "socraticHint": "Can you install an app from a file already on your phone without any internet connection?"
              }
            },
            {
              "key": "D",
              "text": "Connect to the Google Play Store",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! Custom apps don't come from the Play Store.",
                "detailed": "The Google Play Store is for apps published by developers through Google's system. Your custom MIT App Inventor app isn't in the Play Store - it's a file you created! You need to allow 'unknown sources' to install apps that didn't come from the official store.",
                "socraticHint": "Where did your app come from - Google's store or your own computer?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Allow unknown sources or install unknown apps",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "apply",
            "tags": [
              "security",
              "android",
              "installation"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l1-q5",
          "globalId": "exit-ticket-f2-005",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why is MIT App Inventor considered a good starting point for learning mobile development?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_GENERAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "It uses visual blocks instead of complex text code, making programming concepts accessible to beginners",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "It's the only tool professional developers use for mobile apps",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! Professionals typically use text-based languages.",
                "detailed": "Professional developers usually use text-based languages like Java, Kotlin, Swift, or JavaScript frameworks. MIT App Inventor is designed as a LEARNING tool that makes programming accessible through visual blocks. It helps you understand concepts before moving to professional tools!",
                "socraticHint": "What makes MIT App Inventor easier for beginners compared to professional tools?"
              }
            },
            {
              "key": "C",
              "text": "It automatically creates apps without you needing to learn anything",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! You still need to learn programming concepts with MIT App Inventor.",
                "detailed": "MIT App Inventor doesn't create apps automatically - YOU still design the screens, choose components, and build the logic using blocks. It makes learning easier by using visual blocks instead of typed code, but you're still learning real programming concepts like events, conditions, and variables!",
                "socraticHint": "Did the lesson show apps building themselves, or did you need to connect blocks and make decisions?"
              }
            },
            {
              "key": "D",
              "text": "It only works for simple apps and can't do anything complex",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! MIT App Inventor can create quite complex apps!",
                "detailed": "While MIT App Inventor uses blocks for accessibility, it's actually very powerful! You can create apps with databases, sensors, AI features, and complex interactions. Many students have built real apps that help their communities. The blocks make it EASIER to learn, not less powerful!",
                "socraticHint": "Look ahead in the course - does it cover only simple features, or also databases, sensors, and AI?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "It uses visual blocks instead of complex text code, making programming concepts accessible to beginners",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "learning",
              "visual-programming",
              "pedagogy"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-2",
      "lessonNumber": 2,
      "lessonTitle": "UI-UX",
      "lessonSlug": "ui-ux",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l2-q1",
          "globalId": "exit-ticket-f2-006",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the difference between UI (User Interface) and UX (User Experience)?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_UI_LAYOUT"
          ],
          "options": [
            {
              "key": "A",
              "text": "UI is how the app looks (colors, buttons, layout), UX is how the app feels to use (easy, fun, accessible)",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "UI and UX are the same thing - they both mean design",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! UI and UX are related but different concepts.",
                "detailed": "Think of it this way: UI is like choosing a cool outfit (how things LOOK) and UX is like how comfy those shoes are (how things FEEL to use). UI focuses on visual design - colors, fonts, button placement. UX focuses on the overall experience - is it easy to find things? Is it fun? Does it solve a problem?",
                "socraticHint": "Can something look beautiful (good UI) but be frustrating to use (bad UX)? What does that tell you?"
              }
            },
            {
              "key": "C",
              "text": "UI is for phones only, UX is for computers only",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! Both UI and UX apply to all types of devices.",
                "detailed": "UI and UX concepts apply to ALL digital products - phones, tablets, computers, smartwatches, even video games! Any app or website has both a User Interface (what you see) and a User Experience (how it feels to use).",
                "socraticHint": "Do computer programs have buttons and colors (UI)? Do they also need to be easy to use (UX)?"
              }
            },
            {
              "key": "D",
              "text": "UI is back-end code, UX is front-end design",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! UI is actually part of front-end, not back-end.",
                "detailed": "UI is definitely FRONT-END - it's what users see and interact with (buttons, colors, screens). UX is broader - it includes the entire experience of using the app, including navigation, accessibility, and how things feel. Back-end is the hidden server code that stores data and does calculations.",
                "socraticHint": "Can you see and touch the UI? What does that tell you about where it belongs?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "UI is how the app looks (colors, buttons, layout), UX is how the app feels to use (easy, fun, accessible)",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "ui-ux",
              "design",
              "user-experience"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l2-q2",
          "globalId": "exit-ticket-f2-007",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "In MIT App Inventor, which tab would you use to change a button's color and size?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_UI_LAYOUT"
          ],
          "options": [
            {
              "key": "A",
              "text": "Designer tab - where you set visual properties and arrange components",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Blocks tab - where you program behavior",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! The Blocks tab is for behavior, not appearance.",
                "detailed": "The Blocks tab is where you make your app DO things - like what happens when you tap a button. To change how a button LOOKS (color, size, position), you use the Designer tab. Think of it this way: Designer = Art Studio (how it looks), Blocks = Brain (how it thinks and acts).",
                "socraticHint": "When you want to make something move or respond, you use blocks. What do you use to make it look pretty?"
              }
            },
            {
              "key": "C",
              "text": "Media tab - where you upload images",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! The Media tab stores files, not component properties.",
                "detailed": "The Media tab is like a storage box for images, sounds, and other files you'll use in your app. To actually change a button's color and size, you use the Designer tab's Properties panel. The Designer tab is where all visual design happens!",
                "socraticHint": "Does the Media tab show your button's properties, or just the files you've uploaded?"
              }
            },
            {
              "key": "D",
              "text": "Properties tab - this is a separate main tab",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! Properties is a PANEL within the Designer tab.",
                "detailed": "There isn't a separate 'Properties tab' - Properties is a panel on the right side of the Designer tab! The two main tabs are Designer (for visual design) and Blocks (for programming logic). When you select a component in Designer, its properties appear in the Properties panel.",
                "socraticHint": "How many main tabs did the lesson mention? Which one contains the Properties panel?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Designer tab - where you set visual properties and arrange components",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "understand",
            "tags": [
              "mit-app-inventor",
              "designer",
              "ui-components"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l2-q3",
          "globalId": "exit-ticket-f2-008",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You're building a quiz app for younger kids (ages 7-9). Which UX consideration is MOST important?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_UI_LAYOUT"
          ],
          "options": [
            {
              "key": "A",
              "text": "Large, colorful buttons with simple words that are easy to tap and read",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Small text and buttons to fit more content on screen",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! Young kids need larger, easier-to-tap elements.",
                "detailed": "Younger kids (7-9) have smaller fingers and developing reading skills. Small buttons are hard for them to tap accurately, and small text is difficult to read. Good UX for young users means BIG, colorful, friendly buttons with simple words they can understand and tap easily!",
                "socraticHint": "Think about a 7-year-old's hands and reading level. What would make the app easier for them?"
              }
            },
            {
              "key": "C",
              "text": "Complex animations and many ads to make it exciting",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! Too much complexity and ads hurt UX for young kids.",
                "detailed": "While kids like fun visuals, TOO many animations can be distracting and confusing. Ads are also problematic - they might accidentally click them or be exposed to inappropriate content. Good UX for kids means simple, clear, and safe - not overwhelming or distracting!",
                "socraticHint": "What helps kids focus and learn better - lots of distractions or clear, simple screens?"
              }
            },
            {
              "key": "D",
              "text": "Professional business design with technical terms",
              "isCorrect": false,
              "misconceptionId": "F2_UI_LAYOUT",
              "feedback": {
                "short": "Not quite! Kids need age-appropriate language and design.",
                "detailed": "A professional business design with technical terms would confuse 7-9 year olds! Good UX means designing for YOUR specific users. Kids need friendly, colorful designs with simple words they understand. Using big words like 'initiate protocol' instead of 'start game' makes for bad UX!",
                "socraticHint": "Would a 7-year-old understand words like 'configuration' or 'parameters'? What words would they understand?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Large, colorful buttons with simple words that are easy to tap and read",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "ux-design",
              "accessibility",
              "age-appropriate"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l2-q4",
          "globalId": "exit-ticket-f2-009",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "vocabulary",
          "prompt": "What is the difference between front-end and back-end development?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_GENERAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "Front-end is what users see and interact with; back-end is the hidden logic and data storage",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Front-end is for apps, back-end is for websites",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! Both apps and websites have front-end and back-end.",
                "detailed": "Both mobile apps AND websites have front-end (what you see) and back-end (hidden logic). For example, Instagram's app has a front-end (the pretty interface you see) and back-end (servers that store your photos and handle your login). Same with websites!",
                "socraticHint": "Does Instagram's app store your photos? Where are they stored - on your phone or on Instagram's servers?"
              }
            },
            {
              "key": "C",
              "text": "Front-end is easier to learn than back-end",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! This is about what they do, not difficulty level.",
                "detailed": "While some people find one easier than the other, the DEFINITION isn't about difficulty. Front-end means the visible parts users interact with (screens, buttons). Back-end means the hidden server logic (databases, calculations). Both can be easy or challenging depending on what you're building!",
                "socraticHint": "Think about the actual work each does, not how hard it is to learn. What's the real difference?"
              }
            },
            {
              "key": "D",
              "text": "Front-end is at the start of the app, back-end is at the end",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! Front and back don't refer to order or position.",
                "detailed": "The terms 'front-end' and 'back-end' don't mean beginning and ending! 'Front' means what's in FRONT of the user (visible interface) and 'back' means what's in the BACKGROUND (hidden servers and data). They work together at the same time, not one before the other!",
                "socraticHint": "When you open an app, do you see the front-end immediately? Is the back-end working at the same time?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Front-end is what users see and interact with; back-end is the hidden logic and data storage",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "front-end",
              "back-end",
              "architecture"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l2-q5",
          "globalId": "exit-ticket-f2-010",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why is it important to get feedback from users when designing your app's UX?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_GENERAL"
          ],
          "options": [
            {
              "key": "A",
              "text": "Because what makes sense to you might be confusing to others - users help you see problems you didn't notice",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Because users will do all the testing work for you for free",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! User feedback is about improving design, not avoiding work.",
                "detailed": "While users do help test, the real reason to get feedback is to make your app BETTER! You know your app so well that things seem obvious to you, but new users spot confusing parts you missed. Their fresh perspective helps you create a better experience for everyone!",
                "socraticHint": "When you know something really well, can you always tell what's confusing for beginners?"
              }
            },
            {
              "key": "C",
              "text": "Because you should always make exactly what users ask for",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! Feedback helps you improve, but you still make design decisions.",
                "detailed": "Getting feedback doesn't mean blindly doing everything users suggest! It means LISTENING to their problems and confusion, then using your creativity to solve those issues. Sometimes users say 'I want X' but what they really need is Y. Good designers understand the problem behind the request!",
                "socraticHint": "If 10 users give 10 different suggestions, can you follow all of them? What should you learn from their feedback instead?"
              }
            },
            {
              "key": "D",
              "text": "Because apps without user feedback always fail completely",
              "isCorrect": false,
              "misconceptionId": "F2_GENERAL",
              "feedback": {
                "short": "Not quite! While feedback is very helpful, apps can succeed without it.",
                "detailed": "User feedback is VERY helpful and makes apps better, but saying apps 'always fail' without it is too extreme. Some brilliant designers create great apps with minimal testing. However, getting feedback is a SMART practice that greatly increases your chances of success and helps you avoid obvious mistakes!",
                "socraticHint": "Can something be helpful and important without being absolutely required for success?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Because what makes sense to you might be confusing to others - users help you see problems you didn't notice",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "user-testing",
              "feedback",
              "design-process"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-3",
      "lessonNumber": 3,
      "lessonTitle": "Visible & Non-visible Component",
      "lessonSlug": "visible-non-visible-component",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l3-q1",
          "globalId": "exit-ticket-f2-011",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the difference between visible and non-visible components in MIT App Inventor?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COMPONENT_VISIBLE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Visible components appear on screen (buttons, labels); non-visible components work behind the scenes (sensors, sounds)",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Visible components are important, non-visible components are optional extras",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Both types of components are equally important.",
                "detailed": "Non-visible components aren't optional extras - they're essential! Try making a talking app without TextToSpeech, or a music app without Sound components. Both visible AND non-visible components work together to create complete apps. Visible = what users see; non-visible = special powers your app has!",
                "socraticHint": "Can you make an app that talks without the TextToSpeech component? What does that tell you about importance?"
              }
            },
            {
              "key": "C",
              "text": "Visible components work on phones, non-visible components only work on tablets",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Both component types work on all devices.",
                "detailed": "Both visible and non-visible components work on phones, tablets, and any device running your app! The difference is about visibility: visible components (like buttons) appear on screen, while non-visible components (like sensors) do their work invisibly in the background.",
                "socraticHint": "Do phones have sensors? Can phones play sounds? Do these work even though you can't see them?"
              }
            },
            {
              "key": "D",
              "text": "Visible components are in the Designer tab only, non-visible components are in the Blocks tab only",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Both types appear in BOTH tabs.",
                "detailed": "ALL components - visible and non-visible - appear in both the Designer tab (where you add them) AND the Blocks tab (where you program them). The difference is that visible components show up on your app's screen, while non-visible components work behind the scenes!",
                "socraticHint": "When you add a Camera component in Designer, can you use it in Blocks too? Where does it appear on the phone screen?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Visible components appear on screen (buttons, labels); non-visible components work behind the scenes (sensors, sounds)",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "components",
              "visible",
              "non-visible"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l3-q2",
          "globalId": "exit-ticket-f2-012",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "Which of these is a non-visible component?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COMPONENT_VISIBLE"
          ],
          "options": [
            {
              "key": "A",
              "text": "TextToSpeech - makes your app talk",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Button - users can tap it",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Buttons are visible components you can see and tap.",
                "detailed": "A Button is a classic visible component! You can see it on screen, change its color and size, and users tap it to trigger actions. Non-visible components like TextToSpeech, Sound, or Camera work behind the scenes without appearing as visible elements on your app's screen.",
                "socraticHint": "When you open an app, can you see and touch the buttons? What does that tell you?"
              }
            },
            {
              "key": "C",
              "text": "Label - displays text on screen",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Labels are visible components that show text.",
                "detailed": "Labels are visible components that display text on your screen. You can see the text, change its color, size, and position. Non-visible components don't appear on screen - they work invisibly, like TextToSpeech that speaks words or Camera that takes photos.",
                "socraticHint": "Can you see the text in a label when your app runs? Is it on the screen?"
              }
            },
            {
              "key": "D",
              "text": "Image - shows a picture",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Images are visible components that display pictures.",
                "detailed": "An Image component is definitely visible - you can see the picture it displays on screen! Non-visible components work behind the scenes without showing up as screen elements. Think of TextToSpeech, Sound, or sensors - they do their job invisibly!",
                "socraticHint": "When you look at your app, can you see the picture? That makes it visible or non-visible?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "TextToSpeech - makes your app talk",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "understand",
            "tags": [
              "components",
              "texttospeech",
              "identification"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l3-q3",
          "globalId": "exit-ticket-f2-013",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You want to build a music player app. Which combination of components would you need?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COMPONENT_VISIBLE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Visible: Buttons for play/pause, Labels for song names; Non-visible: Sound component to play music",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Only visible components like buttons and text - that's all you need",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! You need the Sound component to actually play music.",
                "detailed": "Buttons and text can control the app and display info, but they can't PLAY music! You need the Sound component (non-visible) to actually make the music play. Think of it like a car - buttons are like the steering wheel (control), but you need an engine (Sound component) to make it actually go!",
                "socraticHint": "Can a button play music by itself? What component actually produces sound?"
              }
            },
            {
              "key": "C",
              "text": "Only non-visible components - visible components aren't important for music",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Users need visible buttons to control the music!",
                "detailed": "While the Sound component is essential for playing music, users need visible controls! Without buttons to play, pause, or skip songs, and labels to show song names, users can't interact with your music player. Good apps need BOTH visible (for control and info) and non-visible (for functionality) components!",
                "socraticHint": "If the music plays but there are no buttons on screen, how would users control it?"
              }
            },
            {
              "key": "D",
              "text": "Only the Camera component since it can record sounds",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Camera takes pictures/video, Sound plays audio files.",
                "detailed": "While Camera can record videos with sound, it's not designed to be a music PLAYER! To play existing music files (like MP3s), you need the Sound component. Plus, you need visible controls like buttons for play/pause. The Camera component is for taking pictures and videos!",
                "socraticHint": "When you listen to Spotify or Apple Music, are they using your camera? What are they using instead?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Visible: Buttons for play/pause, Labels for song names; Non-visible: Sound component to play music",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "app-design",
              "components",
              "sound"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l3-q4",
          "globalId": "exit-ticket-f2-014",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "Why do non-visible components not appear on the phone screen when your app runs?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COMPONENT_VISIBLE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Because they provide functionality (like sensors or sounds) that doesn't need a visual representation",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Because they're broken or not working properly",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Non-visible components work perfectly - they just work invisibly!",
                "detailed": "Non-visible components are working exactly as designed! They don't appear on screen because their job doesn't require a visual element. When TextToSpeech speaks or when an Accelerometer detects shaking, you don't need to SEE them - you just need them to WORK! It's a design choice, not a bug.",
                "socraticHint": "When your phone's speaker plays sound, do you need to see a speaker icon for it to work?"
              }
            },
            {
              "key": "C",
              "text": "Because users forgot to make them visible in the properties",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Non-visible components don't have a 'visible' property to change.",
                "detailed": "You can't make non-visible components visible because they're designed to work without appearing on screen! They don't have a 'Visible' property like buttons do. They're meant to be invisible helpers - like how your phone's GPS works behind the scenes to show your location in maps.",
                "socraticHint": "Can you find a 'Visible' property for the TextToSpeech component? Why not?"
              }
            },
            {
              "key": "D",
              "text": "Because they only work in the Designer tab, not when the app runs",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Non-visible components definitely work when the app runs!",
                "detailed": "Non-visible components absolutely work when your app runs - that's their whole purpose! When your app speaks using TextToSpeech or plays a sound, the component is working. You just can't see it because it doesn't need a visual representation on screen to do its job.",
                "socraticHint": "If you hear your app speak, is TextToSpeech working? Can you see it while it's working?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Because they provide functionality (like sensors or sounds) that doesn't need a visual representation",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "components",
              "design-rationale",
              "functionality"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l3-q5",
          "globalId": "exit-ticket-f2-015",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "In real mobile apps you use (like games or social media), can you think of examples of non-visible components working behind the scenes?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COMPONENT_VISIBLE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Yes - GPS for location, accelerometer for screen rotation, notifications, and background data sync",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "No - all apps only use visible components like buttons and images",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Apps use many non-visible components you don't see!",
                "detailed": "Think about it: When Google Maps knows your location, that's GPS (non-visible). When your phone screen rotates, that's the accelerometer (non-visible). When music plays in Spotify, that's the Sound component (non-visible). When you get notifications, that's a notification system (non-visible). Apps use TONS of non-visible components!",
                "socraticHint": "How does your phone know when you tilt it to rotate the screen? Do you see that component?"
              }
            },
            {
              "key": "C",
              "text": "Non-visible components only exist in MIT App Inventor, not in real apps",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! Real apps use non-visible features just like MIT App Inventor!",
                "detailed": "MIT App Inventor is teaching you concepts used in REAL apps! Professional apps use sensors (accelerometer, GPS), audio playback, cameras, databases, and network connections - all 'non-visible' features. MIT App Inventor just makes these easier to learn with blocks instead of code!",
                "socraticHint": "Does Instagram use your phone's camera? Do you see the camera component on screen, or just the picture it takes?"
              }
            },
            {
              "key": "D",
              "text": "Only game apps use non-visible components, not other types of apps",
              "isCorrect": false,
              "misconceptionId": "F2_COMPONENT_VISIBLE",
              "feedback": {
                "short": "Not quite! ALL types of apps use non-visible components!",
                "detailed": "Every type of app uses non-visible components: Social media apps use GPS and notifications. Shopping apps use databases and payment processing. Music apps use Sound components. Fitness apps use accelerometers and timers. Camera apps use the camera component. Health apps use sensors. They ALL use invisible features!",
                "socraticHint": "Does your favorite non-game app know your location, play sounds, or send notifications? What makes those work?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Yes - GPS for location, accelerometer for screen rotation, notifications, and background data sync",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "real-world",
              "sensors",
              "mobile-features"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-4",
      "lessonNumber": 4,
      "lessonTitle": "TTS Technology & Speech Recognizer",
      "lessonSlug": "tts-technology-speech-recognizer",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l4-q1",
          "globalId": "exit-ticket-f2-016",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What does TTS stand for, and what does it do?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_TTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "Text-To-Speech - it converts written text into spoken words",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Talk-To-Screen - it displays what you say as text on screen",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! That's backwards - TTS makes the phone speak OUT LOUD.",
                "detailed": "TTS means Text-To-Speech, not Talk-To-Screen! It takes TEXT (written words) and turns it INTO SPEECH (spoken words). Think of it like reading a book out loud - the book has text, and you speak it. The reverse (speaking and seeing text) would be speech recognition!",
                "socraticHint": "What direction does the conversion go - from text to speech, or from speech to text?"
              }
            },
            {
              "key": "C",
              "text": "Type-To-Send - it sends messages when you type them",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! TTS is about converting text to spoken words, not sending messages.",
                "detailed": "TTS stands for Text-To-Speech and has nothing to do with sending messages! It makes your phone READ text out loud using its speaker. Think of it like an audiobook - someone reading text to you. Sending messages would be a different feature entirely!",
                "socraticHint": "Does TTS involve your phone's speaker making sounds? What is it speaking?"
              }
            },
            {
              "key": "D",
              "text": "Tap-To-Start - it starts the app when you tap the screen",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! TTS is about speech technology, not touch interactions.",
                "detailed": "TTS stands for Text-To-Speech - it's all about making your phone talk! When you give it text (written words), it uses the TextToSpeech component to speak those words out loud. It has nothing to do with tapping to start things - that's just regular button functionality!",
                "socraticHint": "The lesson is about speech and audio. What does the 'S' in TTS probably stand for?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Text-To-Speech - it converts written text into spoken words",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "tts",
              "texttospeech",
              "vocabulary"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l4-q2",
          "globalId": "exit-ticket-f2-017",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "What is the difference between TextToSpeech and SpeechRecognizer components?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_TTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "TextToSpeech makes the phone speak; SpeechRecognizer listens to your voice and converts it to text",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "They're the same thing, just different names for the same component",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! They do opposite jobs - one speaks, one listens.",
                "detailed": "TextToSpeech and SpeechRecognizer are opposite! TextToSpeech is like your phone TALKING (text  speech). SpeechRecognizer is like your phone LISTENING (speech  text). Think of a conversation: one person speaks (TTS) and another listens and writes down what they heard (SpeechRecognizer)!",
                "socraticHint": "If they were the same, why would MIT App Inventor have two separate components? What different jobs do they do?"
              }
            },
            {
              "key": "C",
              "text": "TextToSpeech displays text on screen; SpeechRecognizer recognizes when you tap the screen",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! Both are about SPEECH (audio), not screen display or tapping.",
                "detailed": "Neither component is about screen display or tapping - they're both about VOICE! TextToSpeech makes your phone SPEAK words out loud (using the speaker). SpeechRecognizer LISTENS to you talk (using the microphone) and converts your speech to text. Both are audio-based!",
                "socraticHint": "What do 'Speech' and 'Recognizer' tell you about what these components do? What senses are involved?"
              }
            },
            {
              "key": "D",
              "text": "TextToSpeech is for English only; SpeechRecognizer works with any language",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! Both can work with multiple languages - that's not the main difference.",
                "detailed": "The main difference isn't about languages! TextToSpeech makes your phone SPEAK text out loud (output), while SpeechRecognizer LISTENS to your voice and converts it to text (input). Both can actually work with multiple languages, but that's not what makes them different from each other!",
                "socraticHint": "Think about input vs output. Which component takes input (listens) and which produces output (speaks)?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "TextToSpeech makes the phone speak; SpeechRecognizer listens to your voice and converts it to text",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "tts",
              "speech-recognition",
              "comparison"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l4-q3",
          "globalId": "exit-ticket-f2-018",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You're building a voice assistant app that listens to questions and speaks answers. Which components would you need?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_TTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "Both SpeechRecognizer (to listen to questions) and TextToSpeech (to speak answers)",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Only TextToSpeech - it can both listen and speak",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! TextToSpeech can only speak OUT, not listen IN.",
                "detailed": "TextToSpeech is a one-way component - it only converts text to speech (output). It can't LISTEN to you! To create a voice assistant, you need BOTH components: SpeechRecognizer to listen to questions, and TextToSpeech to speak answers. It's like having ears (SpeechRecognizer) AND a mouth (TextToSpeech)!",
                "socraticHint": "Does Siri or Alexa need to both listen AND speak? Can one component do both jobs?"
              }
            },
            {
              "key": "C",
              "text": "Only SpeechRecognizer - it handles all voice interactions",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! SpeechRecognizer can only listen IN, not speak OUT.",
                "detailed": "SpeechRecognizer is for INPUT - it listens and converts speech to text. But it can't make your phone SPEAK the answer! You need TextToSpeech to speak the response out loud. Think of real voice assistants like Siri - they LISTEN with speech recognition, then ANSWER with text-to-speech!",
                "socraticHint": "If the assistant needs to SPEAK answers out loud, which component makes sound come out of the speaker?"
              }
            },
            {
              "key": "D",
              "text": "Neither - you need the Microphone and Speaker components instead",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! Microphone and Speaker alone can't understand or speak words.",
                "detailed": "While your phone uses its microphone and speaker hardware, you need the SMART components that understand language! SpeechRecognizer uses the microphone but also UNDERSTANDS what you say and converts it to text. TextToSpeech uses the speaker but also GENERATES natural speech from text. The hardware alone can't do this magic!",
                "socraticHint": "Can a microphone alone turn your speech into text? What's needed to understand the words?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Both SpeechRecognizer (to listen to questions) and TextToSpeech (to speak answers)",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "voice-assistant",
              "speech-components",
              "app-design"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l4-q4",
          "globalId": "exit-ticket-f2-019",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "vocabulary",
          "prompt": "Why is TTS technology considered an accessibility feature?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_TTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "It helps people with visual impairments by reading text out loud so they can hear instead of read",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "It makes apps faster and more efficient for everyone",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! Accessibility is about helping people with disabilities, not speed.",
                "detailed": "While TTS might be convenient, it's considered an ACCESSIBILITY feature because it helps people with disabilities use apps! People who are blind or have visual impairments can't read text on screens, but they CAN hear it. TTS reads the text aloud, making apps accessible to everyone!",
                "socraticHint": "Think about someone who can't see the screen. How would TTS help them use an app?"
              }
            },
            {
              "key": "C",
              "text": "It saves battery life by using voice instead of display",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! Accessibility is about including people with disabilities, not battery life.",
                "detailed": "TTS is an accessibility feature because it makes technology usable for people with disabilities, especially those with visual impairments! By reading text aloud, it allows blind and visually impaired people to access content they couldn't otherwise see. It has nothing to do with battery savings!",
                "socraticHint": "What does 'accessibility' mean in technology? Who does it help?"
              }
            },
            {
              "key": "D",
              "text": "It only helps people who speak different languages",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! While TTS can support multiple languages, it's mainly about visual accessibility.",
                "detailed": "TTS's main accessibility benefit is for people with visual impairments - it reads text aloud so they can hear instead of read! While TTS can work in different languages (which is helpful), the core reason it's an accessibility feature is that it makes apps usable for blind and visually impaired users.",
                "socraticHint": "If someone can't see the text on screen at all, how does TTS help them?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "It helps people with visual impairments by reading text out loud so they can hear instead of read",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "accessibility",
              "tts",
              "inclusive-design"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l4-q5",
          "globalId": "exit-ticket-f2-020",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "How do voice assistants like Siri and Alexa use both speech recognition and text-to-speech together?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_TTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "Speech recognition listens to your question and converts it to text, then TTS converts the answer back to speech",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "They only use one or the other, never both at the same time",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! Voice assistants use BOTH technologies working together!",
                "detailed": "Voice assistants absolutely use both technologies! When you ask Siri a question, it uses speech recognition to UNDERSTAND your words (speech  text). Then it finds the answer and uses TTS to SPEAK the response (text  speech). Both technologies work together to create a conversation!",
                "socraticHint": "When you ask Alexa 'What's the weather?' does it listen to you AND answer back? What's needed for each part?"
              }
            },
            {
              "key": "C",
              "text": "TTS is used only for listening, speech recognition is used only for speaking",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! You have them backwards - TTS speaks, speech recognition listens!",
                "detailed": "It's the opposite! Speech recognition is for LISTENING (converting your speech into text), and TTS is for SPEAKING (converting text into speech). Think of it this way: Speech recognition has ears (listens), and TTS has a mouth (speaks)!",
                "socraticHint": "What does 'Text-TO-Speech' mean? Which direction is the conversion going?"
              }
            },
            {
              "key": "D",
              "text": "Both components just play pre-recorded audio files, they don't actually convert anything",
              "isCorrect": false,
              "misconceptionId": "F2_TTS",
              "feedback": {
                "short": "Not quite! These technologies actively convert between speech and text in real-time.",
                "detailed": "Voice assistants don't just play recordings - they actually UNDERSTAND what you say and GENERATE natural speech! Speech recognition converts your unique voice and words into text (even if you ask something new). TTS generates speech from text on the fly. That's why Siri can answer questions it's never heard before!",
                "socraticHint": "Can you ask Siri something completely unique, like 'What's 784 times 92?' and get an answer? Could it do that with just recordings?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Speech recognition listens to your question and converts it to text, then TTS converts the answer back to speech",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "voice-assistants",
              "real-world",
              "integration"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-5",
      "lessonNumber": 5,
      "lessonTitle": "Barcode & QR Code",
      "lessonSlug": "barcode-qr-code",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l5-q1",
          "globalId": "exit-ticket-f2-021",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the main difference between a barcode and a QR code?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_BARCODE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Barcodes are 1D (lines) and store simple numbers; QR codes are 2D (squares) and can store much more data",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Barcodes are newer technology than QR codes",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! Barcodes are actually older technology - QR codes came later.",
                "detailed": "Barcodes (those black lines on products) have been around since the 1970s! QR codes (square patterns) were invented in 1994 as an improvement - they can store WAY more information. Barcodes are 1D (just lines), QR codes are 2D (patterns in both directions), so QR codes can hold URLs, text, and more!",
                "socraticHint": "Which one do you see more on old grocery store products? Which one is used for modern things like websites?"
              }
            },
            {
              "key": "C",
              "text": "Barcodes work on phones, QR codes only work on special scanners",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! Both can be scanned by phone cameras now.",
                "detailed": "Modern phones can scan BOTH barcodes and QR codes using their cameras! In fact, QR codes were specifically designed to be easy to scan with cameras. The main difference is what they store: barcodes hold simple product numbers, while QR codes can hold URLs, contact info, and much more data!",
                "socraticHint": "Have you used your phone's camera to scan QR codes for websites? Can it also scan product barcodes?"
              }
            },
            {
              "key": "D",
              "text": "They're the same thing, just different names",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! They're very different in structure and capability.",
                "detailed": "Barcodes and QR codes are quite different! Barcodes are 1D - just vertical black and white lines that encode a simple number (like a product ID). QR codes are 2D - square patterns with dots that can store much more data like websites, text messages, or contact info. Think: lines vs. squares!",
                "socraticHint": "Look at a grocery product barcode (lines) and a QR code (square pattern). Do they look the same?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Barcodes are 1D (lines) and store simple numbers; QR codes are 2D (squares) and can store much more data",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "barcode",
              "qr-code",
              "comparison"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l5-q2",
          "globalId": "exit-ticket-f2-022",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "In MIT App Inventor, which component would you use to scan QR codes?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_BARCODE"
          ],
          "options": [
            {
              "key": "A",
              "text": "BarcodeScanner - it can scan both barcodes and QR codes",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Camera - you need to use the regular camera component",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! The Camera component takes photos, but doesn't decode barcodes/QR codes.",
                "detailed": "While QR codes ARE scanned with a camera, you need the special BarcodeScanner component! The regular Camera component just takes pictures - it doesn't have the smarts to READ and DECODE the patterns in barcodes or QR codes. BarcodeScanner does both jobs: it opens the camera AND interprets what it sees!",
                "socraticHint": "Can a photo alone tell you what a QR code means? What's needed to convert the pattern into actual data?"
              }
            },
            {
              "key": "C",
              "text": "QRCodeReader - a separate component just for QR codes",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! There's no separate QRCodeReader - BarcodeScanner handles both types.",
                "detailed": "MIT App Inventor uses one component for both: BarcodeScanner! Even though the name says 'Barcode', it can scan BOTH traditional barcodes (lines) and QR codes (squares). It's like a universal scanner that understands multiple formats!",
                "socraticHint": "How many scanner components did the lesson introduce? What was it called?"
              }
            },
            {
              "key": "D",
              "text": "ImagePicker - to select an image with a QR code",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! ImagePicker selects existing photos, not live scanning.",
                "detailed": "ImagePicker lets users choose photos that are already saved on their phone - but scanning QR codes means using the camera LIVE to capture and decode the code right away! The BarcodeScanner component opens the camera and immediately interprets what it sees!",
                "socraticHint": "Do you scan a QR code from an old photo, or point your camera at it live?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "BarcodeScanner - it can scan both barcodes and QR codes",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "understand",
            "tags": [
              "barcodescanner",
              "components",
              "qr-code"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l5-q3",
          "globalId": "exit-ticket-f2-023",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You're building an inventory app for a store. Which type of code would be BEST for tracking individual products?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_BARCODE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Traditional barcodes - they're already on products and perfect for simple product IDs",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "QR codes only - barcodes don't work for inventory",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! Barcodes are actually perfect for inventory - that's what stores use!",
                "detailed": "Barcodes have been used for store inventory since the 1970s! They're perfect for this job because they store product ID numbers, which is all you need. While QR codes COULD work, barcodes are already on every product, cheaper to print, and fast to scan. QR codes are better when you need to store MORE data like URLs or descriptions!",
                "socraticHint": "Look at products in a real store. What type of code is printed on them? Why do stores use that type?"
              }
            },
            {
              "key": "C",
              "text": "Neither - you need RFID chips instead of visual codes",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! While RFID exists, barcodes work great and are already everywhere!",
                "detailed": "RFID chips are cool and some stores use them, but barcodes work perfectly for inventory! They're already printed on products, very cheap, and reliable. For a phone app, the BarcodeScanner component makes it easy to scan products. RFID would require special hardware, while barcodes just need your phone's camera!",
                "socraticHint": "What do cashiers scan at checkout? What can your phone camera easily read?"
              }
            },
            {
              "key": "D",
              "text": "QR codes only because barcodes are too old and outdated",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! 'Old' doesn't mean bad - barcodes still work perfectly for this job!",
                "detailed": "Just because something is older doesn't mean it's worse! Barcodes are PERFECT for inventory because: (1) they're already on every product, (2) they store exactly what you need (product IDs), (3) they're cheap to print, and (4) they scan super fast. QR codes are great when you need MORE data, but for simple inventory, barcodes are ideal!",
                "socraticHint": "Do successful stores like Walmart still use barcodes? Why haven't they all switched to QR codes?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Traditional barcodes - they're already on products and perfect for simple product IDs",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "barcode",
              "inventory",
              "real-world"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l5-q4",
          "globalId": "exit-ticket-f2-024",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "A restaurant wants to let customers scan a code to view their menu online. Which code type should they use and why?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_BARCODE"
          ],
          "options": [
            {
              "key": "A",
              "text": "QR code - it can store a URL that links directly to their website menu",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Traditional barcode - it's simpler and easier to scan",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! Barcodes can't store URLs, only simple numbers.",
                "detailed": "Traditional barcodes can only store simple numbers - they can't hold a website URL! QR codes can store much more data, including complete web addresses. That's why restaurants use QR codes for menus - one scan and your phone opens the website! Barcodes are great for product IDs but not for websites.",
                "socraticHint": "Can a series of black and white lines store 'https://restaurant.com/menu'? What's needed to store that much text?"
              }
            },
            {
              "key": "C",
              "text": "Barcode - because customers are more familiar with scanning barcodes",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! QR codes are actually very common now, and barcodes can't store URLs anyway.",
                "detailed": "QR codes are everywhere now, especially since COVID when restaurants started using them for menus! More importantly, barcodes CAN'T store website URLs - they only hold simple product numbers. QR codes can encode the full web address, so scanning it opens the menu directly. That's why restaurants use QR codes!",
                "socraticHint": "Have you seen QR codes at restaurants recently? What happens when you scan one?"
              }
            },
            {
              "key": "D",
              "text": "Either one works the same for storing website URLs",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! They're very different in what they can store.",
                "detailed": "They definitely don't work the same! Barcodes (1D lines) can only store simple numbers like '123456789' - not enough for a URL! QR codes (2D squares) can store much more data, including full website addresses like 'https://restaurant.com/menu'. That's why you see QR codes at restaurants, not barcodes!",
                "socraticHint": "Try counting the bars in a product barcode. Could that encode a full website address with letters and symbols?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "QR code - it can store a URL that links directly to their website menu",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "qr-code",
              "real-world",
              "data-storage"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l5-q5",
          "globalId": "exit-ticket-f2-025",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Where do you see QR codes used in everyday life? Why are they becoming more popular?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_BARCODE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Restaurant menus, payments, website links, event tickets - they're easy to scan with phone cameras and can store lots of data",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "QR codes aren't really used much in everyday life",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! QR codes are everywhere now, especially since 2020!",
                "detailed": "QR codes are super common now! Restaurants use them for menus, stores use them for payments (like Venmo, PayPal), events use them for tickets, posters have them for website links, and many apps use them to share information quickly. Since COVID-19, they became even more popular because they're contactless and convenient!",
                "socraticHint": "Have you been to a restaurant lately? How did you see the menu? Have you seen QR codes on posters or advertisements?"
              }
            },
            {
              "key": "C",
              "text": "Only in factories and warehouses, not in regular daily life",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! QR codes are everywhere in consumer life now!",
                "detailed": "While factories do use QR codes, they're also all over everyday life! You see them on restaurant tables (menus), in stores (payments), on posters (website links), at events (tickets), and in apps (sharing contacts or WiFi). QR codes are popular because anyone can scan them with their phone camera - no special equipment needed!",
                "socraticHint": "Think about the last time you went out. Did you see any square black-and-white patterns to scan?"
              }
            },
            {
              "key": "D",
              "text": "They're only used in Asian countries, not in other parts of the world",
              "isCorrect": false,
              "misconceptionId": "F2_BARCODE",
              "feedback": {
                "short": "Not quite! QR codes are now worldwide, especially after 2020.",
                "detailed": "While QR codes were very popular in Asia first (especially China), they're now used globally! The COVID-19 pandemic made them common worldwide for contactless menus, payments, and check-ins. Today, restaurants, stores, and events in North America, Europe, and everywhere use QR codes because smartphones are universal!",
                "socraticHint": "Have you seen QR codes at restaurants or stores in your area? Are they only in Asian restaurants?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Restaurant menus, payments, website links, event tickets - they're easy to scan with phone cameras and can store lots of data",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "qr-code",
              "real-world",
              "trends"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-6",
      "lessonNumber": 6,
      "lessonTitle": "Database",
      "lessonSlug": "database",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l6-q1",
          "globalId": "exit-ticket-f2-026",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is TinyDB and what does it do in MIT App Inventor?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DATABASE"
          ],
          "options": [
            {
              "key": "A",
              "text": "A database component that stores data on the phone so it persists even after closing the app",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "A component that makes your app smaller in file size",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! TinyDB is for storing DATA, not reducing app size.",
                "detailed": "The 'Tiny' in TinyDB doesn't mean it makes your app smaller! TinyDB is a DATABASE component that lets you save data (like usernames, scores, settings) on the phone. The data stays saved even after you close the app. It's called 'Tiny' because it's a simple database compared to big server databases!",
                "socraticHint": "What does 'DB' stand for? What do databases do?"
              }
            },
            {
              "key": "C",
              "text": "An online cloud storage service for apps",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! TinyDB stores data locally ON THE PHONE, not in the cloud.",
                "detailed": "TinyDB saves data directly on the user's phone, not in the cloud! This means the data stays on that specific device. If you want cloud storage that syncs across devices, you'd use CloudDB instead. TinyDB is perfect for saving settings, scores, or preferences that only need to stay on one phone!",
                "socraticHint": "If you save data with TinyDB and switch phones, will the data move to the new phone?"
              }
            },
            {
              "key": "D",
              "text": "A component for displaying small images in your app",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! TinyDB is about storing DATA, not displaying images.",
                "detailed": "TinyDB has nothing to do with images! It's a DATABASE for storing information like text, numbers, or lists. Think of it like a filing cabinet where your app can save and retrieve data. For images, you'd use Image components. TinyDB stores invisible data that your app remembers!",
                "socraticHint": "What does the 'DB' in TinyDB stand for? What do those letters mean?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "A database component that stores data on the phone so it persists even after closing the app",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "tinydb",
              "database",
              "storage"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l6-q2",
          "globalId": "exit-ticket-f2-027",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "In TinyDB, what is a 'tag' and why is it important?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DATABASE"
          ],
          "options": [
            {
              "key": "A",
              "text": "A unique name that identifies stored data, like a label on a storage box",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "A keyword that helps search engines find your app",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! Tags in TinyDB are for organizing data INSIDE your app, not for search engines.",
                "detailed": "TinyDB tags aren't about search engines or the internet! A tag is like a LABEL you put on data so you can find it later. If you save a username with tag 'username', you can retrieve it later using that same tag. It's like labeling folders in a filing cabinet - each tag helps you find specific data!",
                "socraticHint": "When you store something in a box, how do you remember what's inside? What helps you find it later?"
              }
            },
            {
              "key": "C",
              "text": "A special component type in MIT App Inventor",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! A tag is not a component - it's a text label for stored data.",
                "detailed": "A tag isn't a component at all! TinyDB is the component, and 'tag' is just a text label you use to identify data. Think of it like this: TinyDB is the filing cabinet (component), and tags are the labels on folders (names for data). You use tags to store and retrieve specific pieces of information!",
                "socraticHint": "When you use TinyDB.StoreValue, what parameter helps you later retrieve that exact value?"
              }
            },
            {
              "key": "D",
              "text": "A security feature that protects your data from hackers",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! Tags are for organization, not security.",
                "detailed": "Tags aren't about security - they're about ORGANIZATION! A tag is a unique name (like 'highScore' or 'username') that identifies stored data. When you want to retrieve data, you use the same tag. It's like labeling containers - the label helps you find what's inside, but it doesn't lock or protect it!",
                "socraticHint": "If you save data with tag 'score', what do you need to provide to get that data back?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "A unique name that identifies stored data, like a label on a storage box",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "tinydb",
              "tags",
              "data-storage"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l6-q3",
          "globalId": "exit-ticket-f2-028",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You're building a game that needs to remember the player's high score. Which blocks would you use?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DATABASE"
          ],
          "options": [
            {
              "key": "A",
              "text": "TinyDB.StoreValue (to save the score) and TinyDB.GetValue (to retrieve it later)",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Only TinyDB.StoreValue - you don't need to retrieve it",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! You need to RETRIEVE the saved score to display it!",
                "detailed": "Storing is only half the job! You need TinyDB.StoreValue to SAVE the high score when the game ends, but you also need TinyDB.GetValue to RETRIEVE and DISPLAY that score when the app opens again. Think about it: what good is saving a high score if you can't show it to the player later?",
                "socraticHint": "When your app opens, how will it know what the high score is if you only saved it but never retrieved it?"
              }
            },
            {
              "key": "C",
              "text": "Only TinyDB.GetValue - that automatically saves and retrieves data",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! GetValue only retrieves - you need StoreValue to save first!",
                "detailed": "TinyDB.GetValue can only retrieve data that was previously saved! You MUST use TinyDB.StoreValue first to save the high score, and then TinyDB.GetValue to get it back later. GetValue doesn't save anything - it only reads what was already stored. You need both blocks working together!",
                "socraticHint": "Can you get something out of a box if you never put anything in? What has to happen first?"
              }
            },
            {
              "key": "D",
              "text": "Variables are enough - TinyDB isn't needed for scores",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! Variables reset when the app closes - TinyDB remembers forever!",
                "detailed": "Variables are temporary - they forget their values when you close the app! If you just use a variable for high score, it'll reset to 0 every time the player reopens the game. TinyDB SAVES the score permanently on the phone, so it's still there days, weeks, or months later. That's why games use databases!",
                "socraticHint": "What happens to variables when you close an app and open it again? Do they remember their values?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "TinyDB.StoreValue (to save the score) and TinyDB.GetValue (to retrieve it later)",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "tinydb",
              "game-development",
              "data-persistence"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l6-q4",
          "globalId": "exit-ticket-f2-029",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "What happens to data stored in TinyDB when you close the app and reopen it?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DATABASE"
          ],
          "options": [
            {
              "key": "A",
              "text": "The data stays saved and can be retrieved when you reopen the app",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "The data is deleted and you have to save it again",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! TinyDB keeps data saved permanently - that's its whole purpose!",
                "detailed": "The magic of TinyDB is that it PERSISTS data! That means data stays saved on the phone even after closing the app, turning off the phone, or weeks later. That's why it's called a database - it permanently stores information. If data disappeared when you closed the app, TinyDB would be useless for things like high scores or settings!",
                "socraticHint": "Why would games use TinyDB for high scores if the scores disappeared every time you closed the game?"
              }
            },
            {
              "key": "C",
              "text": "The data moves to the cloud automatically",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! TinyDB data stays on the phone, it doesn't move anywhere.",
                "detailed": "TinyDB stores data LOCALLY on the phone - it never moves to the cloud! The data stays right where it is, on that specific device. This means it's fast and works offline, but it won't sync to other devices. If you want cloud storage, you'd use CloudDB instead. TinyDB = local storage only!",
                "socraticHint": "If you save data on your phone with TinyDB and your friend opens the same app on their phone, will they see your data?"
              }
            },
            {
              "key": "D",
              "text": "The data only stays saved for 24 hours, then it's deleted",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! TinyDB data stays saved FOREVER until you delete it!",
                "detailed": "TinyDB has no time limit! Data stays saved for as long as the app is installed - days, months, even years! It only gets deleted if: (1) you explicitly clear it with code, (2) the user uninstalls the app, or (3) the user manually clears app data. Otherwise, it stays saved permanently!",
                "socraticHint": "Do your high scores in games disappear after 24 hours? How long does saved data typically last?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "The data stays saved and can be retrieved when you reopen the app",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "understand",
            "tags": [
              "tinydb",
              "persistence",
              "data-storage"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l6-q5",
          "globalId": "exit-ticket-f2-030",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why is data persistence (remembering data after closing an app) important for many apps?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DATABASE"
          ],
          "options": [
            {
              "key": "A",
              "text": "Users expect apps to remember their settings, progress, and data - it creates a better experience",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "It's not really important - most users don't mind re-entering data every time",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! Users would be very frustrated re-entering everything constantly!",
                "detailed": "Imagine if every time you opened Instagram, you had to log in again! Or if games forgot your progress! Or if your calculator reset all its history! Users expect apps to REMEMBER their data. Without persistence, apps would be incredibly frustrating. That's why TinyDB and databases are so important!",
                "socraticHint": "How would you feel if every app forgot who you were and made you start over each time you opened it?"
              }
            },
            {
              "key": "C",
              "text": "It only matters for games, not other types of apps",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! ALL types of apps need to remember data!",
                "detailed": "Data persistence is crucial for ALL apps! Games remember scores, social apps remember logins, calculators remember history, shopping apps remember carts, music apps remember playlists, fitness apps remember workouts, note apps remember notes... basically EVERY app needs to save some kind of data! Without TinyDB or similar storage, apps would be nearly useless!",
                "socraticHint": "Think of your favorite non-game app. What data does it remember? What would happen if it forgot everything every time?"
              }
            },
            {
              "key": "D",
              "text": "Persistent data is only for making apps run faster",
              "isCorrect": false,
              "misconceptionId": "F2_DATABASE",
              "feedback": {
                "short": "Not quite! Persistence is about REMEMBERING data, not speed.",
                "detailed": "Data persistence isn't about speed - it's about MEMORY! TinyDB ensures your app REMEMBERS important information like user preferences, login status, game progress, or saved content. Without it, users would have to re-enter everything every single time they open the app. Speed is a bonus, but remembering data is the main purpose!",
                "socraticHint": "What's the difference between an app running fast and an app remembering your data? Are they the same thing?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Users expect apps to remember their settings, progress, and data - it creates a better experience",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "persistence",
              "ux",
              "databases"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-7",
      "lessonNumber": 7,
      "lessonTitle": "Lists of Data",
      "lessonSlug": "lists-of-data",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l7-q1",
          "globalId": "exit-ticket-f2-031",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is a list in programming and why is it useful?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_LISTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "A collection that stores multiple items in order, like a shopping list or playlist",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "A component that displays items on screen",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! A list is a DATA STRUCTURE that stores items, not a visual component.",
                "detailed": "A list isn't a visual component - it's a data structure that exists in your code! Lists STORE multiple items in memory (like ['apple', 'banana', 'orange']). To DISPLAY a list on screen, you'd use a ListView or ListPicker component, but the list itself is the invisible collection of data!",
                "socraticHint": "Can you have a list of items in your code that you never show to the user? What does that tell you?"
              }
            },
            {
              "key": "C",
              "text": "A way to organize blocks in MIT App Inventor",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! Lists store DATA items, not programming blocks.",
                "detailed": "Lists aren't about organizing blocks - they're about storing MULTIPLE DATA VALUES! For example, a list could store student names ['Alice', 'Bob', 'Charlie'] or scores [95, 87, 92]. It's like having one variable that can hold many items instead of needing separate variables for each one!",
                "socraticHint": "If you need to store 100 names, would you create 100 variables or one list? What's the benefit?"
              }
            },
            {
              "key": "D",
              "text": "Another name for variables in MIT App Inventor",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! Lists and variables are different - lists can hold MULTIPLE items!",
                "detailed": "While both store data, lists are special! A regular variable holds ONE value (like score = 100). A list holds MULTIPLE values in order (like scores = [100, 85, 92]). Lists are perfect when you need to store and manage many related items together, like a shopping list or a playlist!",
                "socraticHint": "How many items can a regular variable hold? How many can a list hold?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "A collection that stores multiple items in order, like a shopping list or playlist",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "lists",
              "data-structures",
              "vocabulary"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l7-q2",
          "globalId": "exit-ticket-f2-032",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "In MIT App Inventor lists, what does 'index' mean?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_LISTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "The position number of an item in the list (starting from 1)",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "The name you give to a list when you create it",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! That's the variable name, not the index.",
                "detailed": "The name of a list is its variable name (like 'shoppingList'). The INDEX is the position number of items INSIDE the list! If your list is ['apple', 'banana', 'orange'], then 'apple' is at index 1, 'banana' is at index 2, and 'orange' is at index 3. Index = position number!",
                "socraticHint": "If you have a list of fruits, how do you tell the app 'get me the 2nd fruit'? What's that number called?"
              }
            },
            {
              "key": "C",
              "text": "A special block for searching through lists",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! Index is a NUMBER showing position, not a block.",
                "detailed": "Index isn't a block - it's a CONCEPT! The index is the number that tells you WHERE an item is in the list. If you want the first item, use index 1. Second item? Index 2. MIT App Inventor has blocks like 'select list item' where you provide an index number to pick which item you want!",
                "socraticHint": "In a numbered line of people, what number tells you someone's position? What's that called in lists?"
              }
            },
            {
              "key": "D",
              "text": "The total number of items in a list",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! That's the LENGTH of the list, not the index.",
                "detailed": "The total number of items is called the LENGTH (or size) of the list! The INDEX is the position number of each individual item. If a list has 5 items, the length is 5, but the items have indices 1, 2, 3, 4, and 5. Index = position of one item; Length = total count!",
                "socraticHint": "In a list with 10 items, there's one length (10). How many index positions are there?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "The position number of an item in the list (starting from 1)",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "lists",
              "index",
              "data-structures"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l7-q3",
          "globalId": "exit-ticket-f2-033",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You have a list: ['cat', 'dog', 'bird', 'fish']. What is at index 3?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_LISTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "bird",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "dog",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! Remember, MIT App Inventor lists start counting at 1, not 0.",
                "detailed": "In MIT App Inventor, lists start at index 1! So 'cat' is at index 1, 'dog' is at index 2, 'bird' is at index 3, and 'fish' is at index 4. If you're thinking index 3 is 'dog', you might be counting from 0 like some other programming languages do. But App Inventor counts from 1!",
                "socraticHint": "Count on your fingers starting from 1: first finger = 'cat', second finger = 'dog', third finger = ?"
              }
            },
            {
              "key": "C",
              "text": "fish",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! That's at index 4, not 3.",
                "detailed": "Let's count: 'cat' is at index 1 (first position), 'dog' is at index 2 (second position), 'bird' is at index 3 (third position), and 'fish' is at index 4 (fourth position). Index 3 means the THIRD item, which is 'bird'!",
                "socraticHint": "What does 'index 3' mean? The third position. What's the third animal in the list?"
              }
            },
            {
              "key": "D",
              "text": "There is no index 3 - the list only has 4 items",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! A list with 4 items HAS an index 3 (the third item).",
                "detailed": "If a list has 4 items, it has indices 1, 2, 3, and 4! Index 3 is the THIRD item in the list. MIT App Inventor counts from 1, so a 4-item list uses indices 1 through 4. Index 3 exists and points to 'bird', the third animal!",
                "socraticHint": "If you have 4 people in line, can you point to the 3rd person? What does that tell you about index 3?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "bird",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "lists",
              "index",
              "problem-solving"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l7-q4",
          "globalId": "exit-ticket-f2-034",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "blockmodel",
          "prompt": "Which block would you use to add a new item to the end of an existing list?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_LISTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "add items to list",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "create empty list (that's only for starting new lists)",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! 'Create empty list' makes a NEW list, it doesn't add to existing ones.",
                "detailed": "'Create empty list' is used when you first create a list - it starts with zero items. To ADD items to a list that already exists, you need 'add items to list'. Think of it like this: 'create empty' is opening a new shopping list, and 'add items' is writing items on that list!",
                "socraticHint": "If you already have a list with items and want to add more, do you start a whole new list or add to the existing one?"
              }
            },
            {
              "key": "C",
              "text": "select list item (that's only for reading, not adding)",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! 'Select list item' READS from a list, it doesn't add items.",
                "detailed": "'Select list item' is for GETTING an item from a list at a specific index - it's for reading data! To ADD new items to a list, you need 'add items to list'. Think: 'select' = read/get; 'add items' = write/insert!",
                "socraticHint": "What's the difference between reading something on a list and writing a new item on a list?"
              }
            },
            {
              "key": "D",
              "text": "make a list (that creates a new list with initial items)",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! 'Make a list' creates a NEW list, not adding to existing ones.",
                "detailed": "'Make a list' creates a brand NEW list with specific starting items. To add items to an EXISTING list, use 'add items to list'. Think of it like: 'make a list' = create a new shopping list with items; 'add items to list' = add more items to your current shopping list!",
                "socraticHint": "If you already have a list [1, 2, 3] and want to add 4, do you create a whole new list or add to the existing one?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "add items to list",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "apply",
            "tags": [
              "lists",
              "list-operations",
              "add-items"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l7-q5",
          "globalId": "exit-ticket-f2-035",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why would you use a list instead of creating many separate variables?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_LISTS"
          ],
          "options": [
            {
              "key": "A",
              "text": "Lists keep related data organized together and make it easy to loop through all items",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Lists use less memory than variables",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! The main benefit is organization and ease of use, not memory.",
                "detailed": "While memory efficiency can be a factor, the MAIN reason to use lists is organization! Imagine storing 50 student names - would you create name1, name2, name3... name50? That's messy! A list keeps them all together, lets you loop through them easily, and makes code much cleaner. It's about making your code easier to work with!",
                "socraticHint": "If you need to print all 50 names, would it be easier with 50 separate variables or one list you can loop through?"
              }
            },
            {
              "key": "C",
              "text": "Variables can't store text, only lists can",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! Variables CAN store text - that's not the difference.",
                "detailed": "Variables can absolutely store text! The difference is that a variable stores ONE value (like name = 'Alice'), while a list stores MULTIPLE values (like names = ['Alice', 'Bob', 'Charlie']). Use lists when you have many related items that you want to manage together, like a playlist, shopping list, or scoreboard!",
                "socraticHint": "Can you store 'Hello' in a variable? What CAN'T a single variable do that a list can?"
              }
            },
            {
              "key": "D",
              "text": "You always need lists - variables are outdated and shouldn't be used",
              "isCorrect": false,
              "misconceptionId": "F2_LISTS",
              "feedback": {
                "short": "Not quite! Both variables AND lists are important - they serve different purposes!",
                "detailed": "Variables are NOT outdated - they're perfect for storing single values like currentScore, playerName, or isGameOver! Use a regular variable when you need ONE value, and use a list when you need MULTIPLE related values. Both are essential tools! It's about choosing the right tool for the job!",
                "socraticHint": "Do you need a list to store the current score (one number)? Or is a variable fine? When would you actually need a list?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Lists keep related data organized together and make it easy to loop through all items",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "lists",
              "data-organization",
              "best-practices"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-8",
      "lessonNumber": 8,
      "lessonTitle": "Clock",
      "lessonSlug": "clock",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l8-q1",
          "globalId": "exit-ticket-f2-036",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the Clock component in MIT App Inventor used for?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CLOCK"
          ],
          "options": [
            {
              "key": "A",
              "text": "A timer that can trigger events at regular intervals and provide time information",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "A visible clock that displays the time on your app screen",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! The Clock component is NON-VISIBLE - it doesn't show on screen.",
                "detailed": "The Clock component is non-visible! It works behind the scenes to trigger timed events or get time information. If you want to DISPLAY a clock on screen, you'd use the Clock component to GET the time, then display it with a Label. The Clock itself is invisible!",
                "socraticHint": "Is Clock component in the visible or non-visible section of the palette? What does that tell you?"
              }
            },
            {
              "key": "C",
              "text": "A way to change your phone's system time",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! Clock component reads time, it doesn't change your phone's settings.",
                "detailed": "The Clock component can't change your phone's time - that's controlled by your device settings! The Clock component READS the current time and can set up timers. It's for making things happen at specific times or intervals, like updating a game every second or showing the current time!",
                "socraticHint": "Can an app change your phone's system clock? What security issues would that cause?"
              }
            },
            {
              "key": "D",
              "text": "A component that makes your app run faster",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! Clock is about TIME and TIMERS, not speed optimization.",
                "detailed": "Clock has nothing to do with making apps faster! It's for working with TIME - setting up timers that trigger events regularly (like every second), or getting the current time/date. Think of it like an alarm that goes off repeatedly to tell your app 'do something now!'",
                "socraticHint": "What does a real clock do? How is that related to what the Clock component does?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "A timer that can trigger events at regular intervals and provide time information",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "clock",
              "timer",
              "components"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l8-q2",
          "globalId": "exit-ticket-f2-037",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "What does the TimerInterval property of the Clock component control?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CLOCK"
          ],
          "options": [
            {
              "key": "A",
              "text": "How often the Timer event fires, measured in milliseconds (1000 = 1 second)",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "The total time before the clock stops working",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! TimerInterval is how OFTEN it fires, not when it stops.",
                "detailed": "TimerInterval controls the INTERVAL between timer events - how often the timer 'ticks'! If you set it to 1000 milliseconds, the Timer event fires every 1 second. It doesn't control when the clock stops - the timer keeps going indefinitely unless you disable it or stop the app!",
                "socraticHint": "What does 'interval' mean? Is it about spacing between events or when something ends?"
              }
            },
            {
              "key": "C",
              "text": "What time of day the clock will start working",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! TimerInterval is about repeating events, not scheduling by time of day.",
                "detailed": "TimerInterval doesn't schedule things for specific times of day! It controls how FREQUENTLY the timer fires - like every second (1000ms) or every half-second (500ms). The timer starts when you enable it and repeats at that interval. To do things at specific times, you'd check the current time in the Timer event!",
                "socraticHint": "If TimerInterval is 2000, does it mean 2000 o'clock, or something repeating every 2000 milliseconds?"
              }
            },
            {
              "key": "D",
              "text": "The speed at which your app runs animations",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! TimerInterval controls when the Timer EVENT fires, not animation speed directly.",
                "detailed": "While you COULD use the Timer event to update animations, TimerInterval itself just controls when the event fires! It's like setting an alarm to go off every X milliseconds. What you DO when that alarm goes off (like moving a sprite) is up to you. The interval is just the spacing between 'ticks'!",
                "socraticHint": "Does TimerInterval tell animations how to move, or does it just create regular events that YOUR code can respond to?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "How often the Timer event fires, measured in milliseconds (1000 = 1 second)",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "clock",
              "timer-interval",
              "milliseconds"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l8-q3",
          "globalId": "exit-ticket-f2-038",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You want to create a countdown timer that updates a label every second. What would you set the TimerInterval to?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CLOCK"
          ],
          "options": [
            {
              "key": "A",
              "text": "1000 (because 1000 milliseconds = 1 second)",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "1 (because you want it to update every 1 second)",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! TimerInterval is in milliseconds, not seconds!",
                "detailed": "A TimerInterval of 1 would fire every 1 MILLISECOND - that's 1000 times per second! Way too fast! TimerInterval is measured in milliseconds. Since 1 second = 1000 milliseconds, you'd set it to 1000 to update every second. Always remember: milliseconds are tiny!",
                "socraticHint": "How many milliseconds are in 1 second? That's your answer!"
              }
            },
            {
              "key": "C",
              "text": "60 (because there are 60 seconds in a minute)",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! The number 60 doesn't relate to milliseconds.",
                "detailed": "While 60 is important for time (60 seconds in a minute), TimerInterval needs to be in MILLISECONDS! To update every second, you need 1000 milliseconds (1 second = 1000 milliseconds). The number 60 would mean firing every 60 milliseconds - over 16 times per second!",
                "socraticHint": "Is TimerInterval measured in seconds, minutes, or milliseconds? How do you convert 1 second to that unit?"
              }
            },
            {
              "key": "D",
              "text": "100 (a nice round number for timing)",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! 100ms would update 10 times per second, not once per second.",
                "detailed": "100 milliseconds = 0.1 seconds, so setting TimerInterval to 100 would fire 10 times per second! That's way faster than you need. To update every 1 second, you need 1000 milliseconds. Always calculate: 1 second = 1000 milliseconds!",
                "socraticHint": "If 100 milliseconds is 0.1 seconds, how many milliseconds do you need for 1 full second?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "1000 (because 1000 milliseconds = 1 second)",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "clock",
              "milliseconds",
              "countdown-timer"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l8-q4",
          "globalId": "exit-ticket-f2-039",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "blockmodel",
          "prompt": "What event would you use to make something happen repeatedly with the Clock component?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CLOCK"
          ],
          "options": [
            {
              "key": "A",
              "text": "Clock.Timer event - it fires repeatedly at the interval you set",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Clock.Click event - you click it repeatedly",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! Clock is non-visible, so there's nothing to click!",
                "detailed": "The Clock component is non-visible - it doesn't appear on screen, so you can't click it! The Clock.Timer event is what fires automatically at regular intervals. You don't need to click anything - just set the TimerInterval and enable the timer, then the Timer event fires repeatedly on its own!",
                "socraticHint": "Can you click something that's invisible and doesn't appear on screen?"
              }
            },
            {
              "key": "C",
              "text": "Clock.Start event - it starts the repeating action",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! There's no Clock.Start event - use Clock.Timer instead!",
                "detailed": "There isn't a Clock.Start event! To make things happen repeatedly, use the Clock.Timer event, which automatically fires at the interval you set (like every second). You enable the timer by setting TimerEnabled to true, then the Timer event keeps firing repeatedly!",
                "socraticHint": "What events does Clock actually have? Check the lesson - which one fires repeatedly?"
              }
            },
            {
              "key": "D",
              "text": "Clock.Update event - it updates repeatedly",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! There's no Clock.Update event - use Clock.Timer instead!",
                "detailed": "There isn't a Clock.Update event! The Clock component uses the Clock.Timer event to handle repeating actions. When you set TimerEnabled to true and set a TimerInterval, the Timer event fires automatically at that interval, over and over!",
                "socraticHint": "What's the actual name of the repeating event in Clock? Hint: it's related to the TimerInterval property!"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Clock.Timer event - it fires repeatedly at the interval you set",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "apply",
            "tags": [
              "clock",
              "timer-event",
              "events"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l8-q5",
          "globalId": "exit-ticket-f2-040",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why is the Clock component useful for games and animations?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CLOCK"
          ],
          "options": [
            {
              "key": "A",
              "text": "It lets you update the game state or move objects at regular intervals, creating smooth motion and timed events",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "It makes games load faster when you first open them",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! Clock is for TIMING during gameplay, not loading speed.",
                "detailed": "The Clock component doesn't affect loading speed! It's useful for games because it creates REGULAR UPDATES - like moving a character every 50ms (20 times per second), updating a countdown timer, or checking for collisions repeatedly. This creates smooth animations and timed gameplay mechanics!",
                "socraticHint": "In a game, does the Clock help with the initial loading, or with things that happen WHILE you're playing?"
              }
            },
            {
              "key": "C",
              "text": "It's only useful for displaying what time of day it is in the game",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! Clock's main use in games is TIMING events, not showing time!",
                "detailed": "While you COULD use Clock to show the current time, its main value for games is creating TIMERS! Games use the Timer event to update the screen many times per second (smooth animation), create countdowns, spawn enemies at intervals, or check for collisions repeatedly. It's all about timing game events!",
                "socraticHint": "Do most games show you what time of day it is? Or do they use timers for movement and gameplay?"
              }
            },
            {
              "key": "D",
              "text": "It prevents the game from running on older phones",
              "isCorrect": false,
              "misconceptionId": "F2_CLOCK",
              "feedback": {
                "short": "Not quite! Clock works on all phones and is essential for games!",
                "detailed": "Clock absolutely works on all phones - it's a basic component! Games NEED the Clock component to work properly. Without it, you couldn't create smooth animations or timed events. The Timer event is how games update the screen frame-by-frame, creating the illusion of movement and making gameplay happen!",
                "socraticHint": "Would it make sense for a basic timing component to block older devices? What would games do without timers?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "It lets you update the game state or move objects at regular intervals, creating smooth motion and timed events",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "clock",
              "games",
              "animation"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-9",
      "lessonNumber": 9,
      "lessonTitle": "Drawing & Animation",
      "lessonSlug": "drawing-animation",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l9-q1",
          "globalId": "exit-ticket-f2-041",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is the Canvas component in MIT App Inventor?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CANVAS"
          ],
          "options": [
            {
              "key": "A",
              "text": "A drawing surface where you can draw shapes, lines, and place sprites for animations",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "A type of fabric material for designing clothes in apps",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! In programming, Canvas is a drawing surface, not fabric!",
                "detailed": "While 'canvas' in art means fabric for painting, in MIT App Inventor it's a DIGITAL drawing surface! Like a blank screen where you can draw circles, lines, and move sprites (like game characters). Think of it like a whiteboard in your app where graphics and animations happen!",
                "socraticHint": "Are you building clothing design apps or apps with graphics and games? What makes more sense?"
              }
            },
            {
              "key": "C",
              "text": "A database for storing images and photos",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Canvas is for DRAWING and ANIMATION, not storing data.",
                "detailed": "Canvas isn't about storage - it's about DRAWING! You use Canvas as a surface to draw shapes, display sprites (like balls or characters), and create animations. To store images, you'd use Media or TinyDB. Canvas is where the visual action happens in real-time!",
                "socraticHint": "Does 'Drawing & Animation' suggest storing files or creating visual graphics?"
              }
            },
            {
              "key": "D",
              "text": "A button that users click to submit drawings",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Canvas is a DRAWING SURFACE, not a button.",
                "detailed": "Canvas is a component that provides a SPACE for drawing - it's like a rectangular area on your screen where graphics appear! It's not a button you click. Users can draw ON the canvas (with touch or code), and sprites move WITHIN the canvas. It's the stage where visual things happen!",
                "socraticHint": "What do artists use a canvas for? How is that similar to what Canvas does in App Inventor?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "A drawing surface where you can draw shapes, lines, and place sprites for animations",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "canvas",
              "drawing",
              "animation"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l9-q2",
          "globalId": "exit-ticket-f2-042",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "What is the difference between Ball and ImageSprite components?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CANVAS"
          ],
          "options": [
            {
              "key": "A",
              "text": "Ball is a simple colored circle; ImageSprite displays a custom image that can move",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Ball can move but ImageSprite can't move",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! BOTH Ball and ImageSprite can move!",
                "detailed": "Both Ball and ImageSprite are movable sprites! They both have X, Y properties and can move around the Canvas. The difference is appearance: Ball is a simple colored circle, while ImageSprite can display any custom image (like a character, car, or spaceship). Both are great for animations and games!",
                "socraticHint": "The word 'Sprite' usually refers to movable game objects. Can an ImageSprite move?"
              }
            },
            {
              "key": "C",
              "text": "Ball is for sports games only; ImageSprite is for all other games",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Ball can be used for ANY round moving object, not just sports!",
                "detailed": "Ball is just a simple colored circle sprite - you can use it for anything round! Bouncing balls, collectible coins, bullets, bubbles, planets... anything circular! The name 'Ball' describes its SHAPE, not what type of game it's for. Use Ball when you want a simple circle, and ImageSprite when you want a custom image!",
                "socraticHint": "Can a circle be useful in non-sports games? What other things are round?"
              }
            },
            {
              "key": "D",
              "text": "They're the same thing with different names",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! They're different in what they display.",
                "detailed": "Ball and ImageSprite are different! Ball is specifically a colored CIRCLE that you can customize (size, color). ImageSprite can display ANY image you upload (a car, character, spaceship, etc.). Both can move and both live on the Canvas, but Ball is always circular while ImageSprite shows your custom picture!",
                "socraticHint": "If you wanted a spaceship character in your game, would a circle (Ball) or a custom image (ImageSprite) make more sense?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Ball is a simple colored circle; ImageSprite displays a custom image that can move",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "ball",
              "imagesprite",
              "sprites"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l9-q3",
          "globalId": "exit-ticket-f2-043",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "How would you make a Ball sprite move to the right across the Canvas?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CANVAS"
          ],
          "options": [
            {
              "key": "A",
              "text": "Use the Clock Timer event to repeatedly increase the Ball's X property",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Just set the Ball's X property once to a large number",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Setting X once would JUMP the ball, not create smooth movement.",
                "detailed": "Setting X to a large number once would instantly teleport the ball to that position - no animation! To create SMOOTH movement across the screen, you need to REPEATEDLY increase X by small amounts using a Clock Timer. For example, every 50ms add 5 to the X position. That creates the illusion of smooth motion!",
                "socraticHint": "How do cartoons create the illusion of movement? By showing many positions quickly, right? How would you do that in code?"
              }
            },
            {
              "key": "C",
              "text": "Change the Ball's color repeatedly",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Color changes appearance, not position!",
                "detailed": "Changing the Ball's color makes it look different but doesn't move it! To move a sprite, you need to change its POSITION properties - X (horizontal) or Y (vertical). To move right, keep increasing the X value in a Clock Timer event. Color and position are completely separate properties!",
                "socraticHint": "Does changing the color of a ball make it move to a different location? What property controls location?"
              }
            },
            {
              "key": "D",
              "text": "Ball components move automatically, you don't need code",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Sprites don't move on their own - YOU control their movement with code!",
                "detailed": "Sprites (Ball and ImageSprite) don't move automatically! YOU have to write code to move them. Typically, you use a Clock Timer event to repeatedly update the X or Y position. The sprite stays put until your code changes its position. It's like a puppet - you're the puppeteer!",
                "socraticHint": "If sprites moved automatically, how would you control games? Who decides where and how sprites move?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Use the Clock Timer event to repeatedly increase the Ball's X property",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "animation",
              "movement",
              "sprites"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l9-q4",
          "globalId": "exit-ticket-f2-044",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "What properties control the position of a sprite on the Canvas?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CANVAS"
          ],
          "options": [
            {
              "key": "A",
              "text": "X (horizontal position) and Y (vertical position)",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Width and Height",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Width and Height control SIZE, not position!",
                "detailed": "Width and Height determine how BIG the sprite is, not WHERE it is! To control POSITION, you use X (horizontal - left/right) and Y (vertical - up/down). Think of it this way: Width/Height = size, X/Y = location. Both are important but serve different purposes!",
                "socraticHint": "If you make something wider, does it move to a different location, or just get bigger?"
              }
            },
            {
              "key": "C",
              "text": "Left and Right properties",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Sprites use X and Y coordinates, not Left and Right.",
                "detailed": "While 'left' and 'right' describe direction, sprites use X and Y COORDINATES! X represents horizontal position (low X = left, high X = right), and Y represents vertical position (low Y = top, high Y = bottom). This coordinate system is standard in computer graphics!",
                "socraticHint": "What coordinate system did you learn about in math class? How do graphs show position?"
              }
            },
            {
              "key": "D",
              "text": "Speed and Direction properties",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Speed and direction control MOVEMENT, not the current position.",
                "detailed": "Speed and Direction are for MOTION (how the sprite moves when using automatic movement methods). But the actual POSITION at any moment is stored in X and Y properties! X tells you the horizontal location, Y tells you the vertical location. Speed/Direction affect HOW position changes over time!",
                "socraticHint": "If you want to place a sprite at a specific spot right now, do you need to know its speed, or its exact coordinates?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "X (horizontal position) and Y (vertical position)",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "coordinates",
              "position",
              "sprites"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l9-q5",
          "globalId": "exit-ticket-f2-045",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why do games and animations need to update many times per second?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_CANVAS"
          ],
          "options": [
            {
              "key": "A",
              "text": "To create the illusion of smooth, continuous movement instead of jumpy, choppy motion",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "To make the app file size larger",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Frequent updates create smooth motion, not larger files.",
                "detailed": "Updating frequently has nothing to do with file size! It's about PERCEPTION - our eyes see smooth motion when images change fast enough (usually 30-60 times per second). If you only update once per second, movement looks jumpy and choppy. Fast updates (like every 50ms) create the illusion of smooth animation, just like movies!",
                "socraticHint": "Do movies look smooth because the film is bigger, or because they show many frames per second?"
              }
            },
            {
              "key": "C",
              "text": "Because phones can only process one update per second",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Phones can update MANY times per second - that's why we do it!",
                "detailed": "Phones are very fast and can update screens 60+ times per second! We WANT to update frequently (like every 16-50 milliseconds) because it creates SMOOTH animation. If we only updated once per second, games would be super choppy and unplayable. Fast updates = smooth motion!",
                "socraticHint": "Do games look smooth or choppy on phones? What does that tell you about update frequency?"
              }
            },
            {
              "key": "D",
              "text": "They don't need to - updating once per second is enough",
              "isCorrect": false,
              "misconceptionId": "F2_CANVAS",
              "feedback": {
                "short": "Not quite! Once per second would look VERY choppy - we need many updates!",
                "detailed": "Updating just once per second would make movement look terrible - like watching a slideshow! Professional games update 30-60 times per second (every 16-33 milliseconds) to create SMOOTH motion. Our brains perceive smooth movement when we see many small position changes quickly. That's how movies and animations work!",
                "socraticHint": "Imagine a ball moving across the screen but only updating its position once every second. Would that look smooth or jumpy?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "To create the illusion of smooth, continuous movement instead of jumpy, choppy motion",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "animation",
              "frame-rate",
              "perception"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-10",
      "lessonNumber": 10,
      "lessonTitle": "Miss Parrot",
      "lessonSlug": "miss-parrot",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l10-q1",
          "globalId": "exit-ticket-f2-046",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is collision detection in games?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COLLISION"
          ],
          "options": [
            {
              "key": "A",
              "text": "A way to detect when two sprites touch or overlap, triggering events like scoring or game over",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "A method to prevent sprites from moving on the screen",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Collision detection doesn't stop movement, it DETECTS when sprites touch!",
                "detailed": "Collision detection doesn't prevent movement! It DETECTS when two sprites overlap or touch, then your code decides what happens - maybe bounce off, lose a life, collect points, etc. The sprites can still move freely; collision detection just alerts you when they touch so you can respond!",
                "socraticHint": "In a game like Pac-Man, do the characters stop moving, or does the game detect when Pac-Man touches a ghost?"
              }
            },
            {
              "key": "C",
              "text": "A bug that happens when sprites crash into each other",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Collision detection is a FEATURE, not a bug!",
                "detailed": "Collision detection is an intentional FEATURE that game developers program! It's how games know when a player touches an enemy, catches a power-up, or hits a wall. Without collision detection, objects would pass through each other like ghosts! It's essential for gameplay, not an error!",
                "socraticHint": "Would games work if characters could pass through walls and enemies without anything happening? Is that a bug or missing feature?"
              }
            },
            {
              "key": "D",
              "text": "A way to make sprites automatically avoid each other",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Collision detection DETECTS touches, it doesn't automatically make sprites avoid each other.",
                "detailed": "Collision detection tells you WHEN sprites touch - it doesn't automatically make them avoid each other! YOU write code to decide what happens when a collision is detected. Maybe they bounce, maybe the player loses a life, maybe points are scored. Detection = knowing it happened; response = what you program!",
                "socraticHint": "Does your code need to decide what happens when sprites collide, or does it happen automatically?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "A way to detect when two sprites touch or overlap, triggering events like scoring or game over",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "collision-detection",
              "sprites",
              "game-mechanics"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l10-q2",
          "globalId": "exit-ticket-f2-047",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "blockmodel",
          "prompt": "Which event detects when two sprites collide in MIT App Inventor?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COLLISION"
          ],
          "options": [
            {
              "key": "A",
              "text": "CollidedWith event - it fires when a sprite touches another sprite",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Touched event - it fires when you touch the screen",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Touched is for finger touches, not sprite collisions!",
                "detailed": "The Touched event happens when a user's FINGER touches the Canvas - it's for user input! For detecting when two SPRITES touch each other, you need the CollidedWith event. Think of it: Touched = user interaction, CollidedWith = sprite interaction!",
                "socraticHint": "Does 'Touched' sound like it's about your finger or about sprites bumping into each other?"
              }
            },
            {
              "key": "C",
              "text": "Click event - it fires when sprites are clicked",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Click is for user clicks, not sprite-to-sprite contact!",
                "detailed": "Click events are for when a user CLICKS on something! To detect when two sprites touch EACH OTHER (like a ball hitting a paddle), you use the CollidedWith event. CollidedWith specifically handles sprite-to-sprite collisions during gameplay!",
                "socraticHint": "In a game, do sprites collide because you click them, or because they bump into each other while moving?"
              }
            },
            {
              "key": "D",
              "text": "EdgeReached event - it fires when sprites hit the edge",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! EdgeReached is for hitting canvas boundaries, not other sprites!",
                "detailed": "EdgeReached fires when a sprite hits the EDGE of the Canvas (boundary), not when it hits another sprite! For sprite-to-sprite collisions (like a player hitting an enemy), you need the CollidedWith event. EdgeReached is useful for bouncing off walls; CollidedWith is for interactions between sprites!",
                "socraticHint": "Is the edge of the Canvas another sprite, or is it the boundary? What event would handle sprite-to-sprite contact?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "CollidedWith event - it fires when a sprite touches another sprite",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "collidedwith",
              "events",
              "collision-detection"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l10-q3",
          "globalId": "exit-ticket-f2-048",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You're making a game where a player sprite should lose a life when it touches an enemy sprite. Where would you put this code?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COLLISION"
          ],
          "options": [
            {
              "key": "A",
              "text": "In the Player.CollidedWith event, check if 'other' is the enemy, then decrease lives",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "In the Clock.Timer event, continuously check positions",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! While this COULD work, CollidedWith is more efficient and easier!",
                "detailed": "Manually checking positions in Clock.Timer works, but it's inefficient and complicated! The CollidedWith event is DESIGNED for this - it automatically fires when sprites touch, and tells you which sprite was hit. Why do math when MIT App Inventor does it for you? Use CollidedWith!",
                "socraticHint": "If there's an event specifically designed to detect collisions, why would you manually check positions every timer tick?"
              }
            },
            {
              "key": "C",
              "text": "In the Screen.Initialize event, set it up at the start",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Screen.Initialize runs once at startup, not when collisions happen!",
                "detailed": "Screen.Initialize only runs ONCE when the app opens - it's for setup! But collisions happen during gameplay, potentially many times. You need code that runs WHEN the collision happens, not just at startup. Use the CollidedWith event, which fires every time sprites touch!",
                "socraticHint": "Does a player hit an enemy just once at the start, or potentially many times during the game?"
              }
            },
            {
              "key": "D",
              "text": "You can't detect sprite collisions in MIT App Inventor",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! MIT App Inventor has built-in collision detection!",
                "detailed": "MIT App Inventor absolutely supports collision detection! Every sprite (Ball, ImageSprite) has a CollidedWith event that fires when it touches another sprite. This is a fundamental feature for making games. Without it, you couldn't make playable games!",
                "socraticHint": "Could you make games like Pong or Pac-Man without detecting when sprites touch? What does that tell you?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "In the Player.CollidedWith event, check if 'other' is the enemy, then decrease lives",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "collision-detection",
              "game-logic",
              "events"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l10-q4",
          "globalId": "exit-ticket-f2-049",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "bebras",
          "prompt": "In the CollidedWith event, what does the 'other' parameter represent?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COLLISION"
          ],
          "options": [
            {
              "key": "A",
              "text": "The other sprite that collided with this sprite",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "All the other sprites on the Canvas",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! 'other' is the SPECIFIC sprite that just collided, not all sprites!",
                "detailed": "'Other' represents the ONE sprite that just collided with your sprite in that moment! If PlayerBall collides with Enemy1, then 'other' = Enemy1. It's not a list of all sprites - it's the specific sprite involved in THIS collision. This lets you check which sprite was hit and respond accordingly!",
                "socraticHint": "When two cars crash, do you need to know about all cars on the road, or just the specific car you hit?"
              }
            },
            {
              "key": "C",
              "text": "A different collision event",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! 'other' is a PARAMETER (data), not an event!",
                "detailed": "'Other' isn't an event - it's a PARAMETER that gets passed to the CollidedWith event! It's a piece of information telling you WHICH sprite was involved in the collision. Events are things that happen; parameters are information about what happened!",
                "socraticHint": "Is 'other' something that happens (event) or information you receive (parameter)?"
              }
            },
            {
              "key": "D",
              "text": "The previous sprite that was touched before this one",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! 'other' is the sprite you JUST collided with right now!",
                "detailed": "'Other' represents the sprite involved in the CURRENT collision that just triggered this event - not a previous collision! Each time CollidedWith fires, 'other' tells you which sprite was just hit in that moment. It's about the present collision, not the past!",
                "socraticHint": "When CollidedWith fires, is it telling you about something that happened before, or something that just happened now?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "The other sprite that collided with this sprite",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "collidedwith",
              "parameters",
              "events"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l10-q5",
          "globalId": "exit-ticket-f2-050",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why is collision detection essential for most games?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_COLLISION"
          ],
          "options": [
            {
              "key": "A",
              "text": "Without it, players couldn't interact with enemies, collect items, or trigger game events - everything would pass through everything else",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "It makes the game graphics look better",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Collision detection is about GAMEPLAY, not graphics!",
                "detailed": "Collision detection doesn't affect how things look - it affects how they BEHAVE! It's what makes Pac-Man eat dots, Mario jump on Goombas, or your spaceship shoot asteroids. Graphics (appearance) and collision detection (interaction) are separate! You could have beautiful graphics with no collisions, and the game would be unplayable!",
                "socraticHint": "Can a game look pretty but be unplayable because nothing interacts? What makes gameplay work?"
              }
            },
            {
              "key": "C",
              "text": "It's only needed for complex 3D games, not simple 2D games",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Even simple 2D games need collision detection!",
                "detailed": "Classic 2D games like Pong, Pac-Man, Space Invaders, and Angry Birds ALL use collision detection! Whether 2D or 3D, games need to know when objects touch. Without collision detection, you couldn't play Pong (ball passes through paddle), collect coins (player passes through coins), or anything! It's fundamental to ALL games!",
                "socraticHint": "Think of the simplest game you know. Does it need to detect when things touch?"
              }
            },
            {
              "key": "D",
              "text": "It's optional - games work fine without it",
              "isCorrect": false,
              "misconceptionId": "F2_COLLISION",
              "feedback": {
                "short": "Not quite! Without collision detection, most games would be impossible to play!",
                "detailed": "Try to imagine Pac-Man if he passed through ghosts and dots without anything happening! Or a soccer game where the ball passes through players! Collision detection is what makes gameplay EXIST - it's how games know when significant interactions happen. Without it, games would just be watching things move around with no way to play!",
                "socraticHint": "What would happen in your favorite game if nothing could touch anything else? Could you even call it a game?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Without it, players couldn't interact with enemies, collect items, or trigger game events - everything would pass through everything else",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "collision-detection",
              "game-design",
              "interaction"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    },
    {
      "lessonId": "f2-mobile-cs-principles-lesson-11",
      "lessonNumber": 11,
      "lessonTitle": "Prototype",
      "lessonSlug": "prototype",
      "totalQuestions": 5,
      "questions": [
        {
          "questionId": "f2-mobile-cs-principles-l11-q1",
          "globalId": "exit-ticket-f2-051",
          "questionNumber": 1,
          "questionType": "vocabulary",
          "questionTypeLabel": "Vocabulary/Concepts",
          "questionArchetype": "vocabulary",
          "prompt": "What is a prototype in app development?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DESIGN"
          ],
          "options": [
            {
              "key": "A",
              "text": "An early, testable version of an app used to gather feedback and improve the design",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "The final, perfect version of an app ready for the app store",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! Prototypes are EARLY versions, not final ones!",
                "detailed": "A prototype is an EARLY version - often rough and incomplete! It's specifically NOT the final version. The purpose is to test ideas quickly, get feedback, and make changes BEFORE investing time in perfecting everything. Final versions come much later, after many rounds of prototyping and improvements!",
                "socraticHint": "Would you show a perfect, finished product to users asking 'what should I change?' What comes first - testing or finishing?"
              }
            },
            {
              "key": "C",
              "text": "A written document describing what the app will do",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! A prototype is a WORKING version, not just a description!",
                "detailed": "While written plans are useful, a PROTOTYPE is something you can actually use and test! Users can tap buttons, navigate screens, and experience (at least partially) how the app works. It's a working model, not just words on paper. Documents plan; prototypes demonstrate!",
                "socraticHint": "Can you test how an app feels to use by reading a description, or do you need something interactive?"
              }
            },
            {
              "key": "D",
              "text": "The first customer who buys your app",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! That's confusing prototype with 'first user' or 'early adopter'!",
                "detailed": "A prototype is the early VERSION of the app itself, not a person! It's the incomplete, testable model you build to try out ideas and get feedback. The word 'prototype' in product design always refers to the product, not the users or customers!",
                "socraticHint": "Is a prototype a person or a thing? What are you building and testing?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "An early, testable version of an app used to gather feedback and improve the design",
          "metadata": {
            "difficulty": "easy",
            "estimatedTime": 30,
            "bloomsTaxonomy": "remember",
            "tags": [
              "prototype",
              "design-process",
              "iterative-design"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l11-q2",
          "globalId": "exit-ticket-f2-052",
          "questionNumber": 2,
          "questionType": "code_understanding",
          "questionTypeLabel": "Code Understanding",
          "questionArchetype": "vocabulary",
          "prompt": "Why is user testing important in the design process?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DESIGN"
          ],
          "options": [
            {
              "key": "A",
              "text": "Real users find problems and confusion you didn't notice, helping you make the app better",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "It's a way to get free labor for testing bugs",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! User testing is about learning and improving, not cheap labor!",
                "detailed": "User testing isn't about getting free work! It's about learning how REAL PEOPLE experience your app. You're not exploiting users - you're genuinely trying to understand their perspective so you can make something better for them. Their confusion teaches you what to fix. It's about empathy and improvement!",
                "socraticHint": "Are you asking users to find bugs for you, or trying to understand their experience to make it better?"
              }
            },
            {
              "key": "C",
              "text": "You're required to test with exactly 100 users before launching",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! There's no magic number - even testing with 3-5 users helps!",
                "detailed": "You don't need 100 users! Research shows even 3-5 users can reveal most usability problems. The important thing is to TEST, learn, and improve - not hit a specific number. Quality testing with a few people is better than mindless testing with many. It's about insight, not counting!",
                "socraticHint": "If 3 users all get confused at the same screen, do you need 97 more to tell you there's a problem?"
              }
            },
            {
              "key": "D",
              "text": "Users will tell you exactly what features to build",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! Users show you PROBLEMS; YOU design SOLUTIONS!",
                "detailed": "User testing shows you what's confusing or frustrating, but users don't design solutions for you! Henry Ford said 'If I asked people what they wanted, they'd say faster horses' - not cars! You listen to their problems and struggles, then use YOUR creativity to solve them. They identify issues; you create solutions!",
                "socraticHint": "Do users know the best solution, or do they just experience the problem? Who's the designer?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Real users find problems and confusion you didn't notice, helping you make the app better",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "user-testing",
              "feedback",
              "design-process"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l11-q3",
          "globalId": "exit-ticket-f2-053",
          "questionNumber": 3,
          "questionType": "problem_solving",
          "questionTypeLabel": "Problem Solving",
          "questionArchetype": "bebras",
          "prompt": "You show your prototype to users and they get confused at the same step. What should you do?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DESIGN"
          ],
          "options": [
            {
              "key": "A",
              "text": "Redesign that step to make it clearer - if multiple users struggled, there's definitely a problem",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Ignore it - those users must not be smart enough",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! If users are confused, it's YOUR design problem, not their intelligence!",
                "detailed": "Good design means ANYONE can use it easily! If multiple users get confused at the same spot, that's YOUR design failing, not them being 'not smart enough.' Your job as a designer is to make things clear for everyone. User confusion is valuable feedback showing you what to improve!",
                "socraticHint": "Do millions of people use simple apps because they're all geniuses, or because the apps are well-designed for everyone?"
              }
            },
            {
              "key": "C",
              "text": "Write better instructions explaining that step",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! If it needs explanation, the design itself should be clearer!",
                "detailed": "While instructions can help, they're often a band-aid for bad design! If something is truly well-designed, it should be intuitive without needing explanation. Before adding instructions, try to make the design itself clearer - better labels, simpler flow, visual hints. Good design is self-explanatory!",
                "socraticHint": "Do you read instruction manuals for apps like Instagram or TikTok, or are they just obvious? What makes them work?"
              }
            },
            {
              "key": "D",
              "text": "Keep the design the same - users will figure it out eventually",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! If users struggle, most will just give up and uninstall!",
                "detailed": "Users won't 'figure it out eventually' - they'll get frustrated and DELETE your app! When multiple users struggle at the same step, that's a CLEAR signal to redesign. Users have thousands of other apps to choose from - they won't work hard to understand yours. Make it easy or lose them!",
                "socraticHint": "When you find an app confusing, do you spend hours trying to figure it out, or just download something else?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Redesign that step to make it clearer - if multiple users struggled, there's definitely a problem",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "apply",
            "tags": [
              "iteration",
              "user-feedback",
              "problem-solving"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l11-q4",
          "globalId": "exit-ticket-f2-054",
          "questionNumber": 4,
          "questionType": "application",
          "questionTypeLabel": "Application",
          "questionArchetype": "vocabulary",
          "prompt": "What does 'iteration' mean in the design process?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DESIGN"
          ],
          "options": [
            {
              "key": "A",
              "text": "Repeatedly testing, learning from feedback, and improving your design in cycles",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Making your first design absolutely perfect before showing anyone",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! Iteration is the OPPOSITE - you improve through repeated cycles, not perfection upfront!",
                "detailed": "Iteration means accepting that your first version won't be perfect! Instead of trying to make it perfect before testing, you make something good enough to test, get feedback, improve it, test again, improve more... and repeat! Each cycle (iteration) makes it better. Perfection comes through many iterations, not before them!",
                "socraticHint": "Is it easier to predict what users want, or to test something and learn from real reactions?"
              }
            },
            {
              "key": "C",
              "text": "Building multiple completely different apps to see which one works",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! Iteration improves ONE design through cycles, not building multiple different apps!",
                "detailed": "Iteration means taking ONE design and improving it through cycles of testing and refinement. You're not starting over with completely different ideas - you're making the SAME design better and better based on what you learn. Think of it like editing an essay: you improve the same essay, you don't write five different essays!",
                "socraticHint": "When you edit a paper, do you rewrite it completely different each time, or improve the same paper?"
              }
            },
            {
              "key": "D",
              "text": "Creating many copies of the same design without changes",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! Iteration means CHANGING and IMPROVING each version!",
                "detailed": "Making copies without changes is just duplication! Iteration means each version is DIFFERENT and IMPROVED based on what you learned. Version 1  test  learn  Version 2 (better)  test  learn  Version 3 (even better). Each iteration incorporates lessons from the previous one!",
                "socraticHint": "If each version is exactly the same, are you learning and improving anything?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "Repeatedly testing, learning from feedback, and improving your design in cycles",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "understand",
            "tags": [
              "iteration",
              "design-process",
              "continuous-improvement"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        },
        {
          "questionId": "f2-mobile-cs-principles-l11-q5",
          "globalId": "exit-ticket-f2-055",
          "questionNumber": 5,
          "questionType": "reflection",
          "questionTypeLabel": "Reflection/Meta-learning",
          "questionArchetype": "vocabulary",
          "prompt": "Why is it better to test early prototypes instead of waiting until the app is completely finished?",
          "hasCodeBlock": false,
          "codeLanguage": null,
          "codeContent": null,
          "misconceptionTargets": [
            "F2_DESIGN"
          ],
          "options": [
            {
              "key": "A",
              "text": "It's easier and cheaper to fix problems early, before you've invested months building the wrong thing",
              "isCorrect": true
            },
            {
              "key": "B",
              "text": "Finished apps can't be changed, so you must test prototypes",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! Finished apps CAN be changed, but it's much harder and more expensive!",
                "detailed": "You CAN change finished apps (through updates), but it's MUCH more work! If you discover a fundamental design problem after months of building, you might have to redo huge amounts of work. Testing early prototypes lets you catch problems when they're easy to fix - before you've built everything on that flawed foundation!",
                "socraticHint": "Is it easier to change the blueprint of a house or to renovate the finished building? When are changes cheaper?"
              }
            },
            {
              "key": "C",
              "text": "Users won't give honest feedback on finished apps",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! Users will give feedback anytime, but early testing saves time and money!",
                "detailed": "Users will give honest feedback at any stage! The reason to test early isn't about honesty - it's about EFFICIENCY. If you find a major problem in a prototype, you can fix it in days. If you find the same problem after building a finished app, fixing it might take months! Test early to catch problems while they're cheap to fix!",
                "socraticHint": "When is it easier to change direction - at the beginning of a project or after months of work?"
              }
            },
            {
              "key": "D",
              "text": "It's not better - you should always finish before testing",
              "isCorrect": false,
              "misconceptionId": "F2_DESIGN",
              "feedback": {
                "short": "Not quite! Early testing is a core principle of good design!",
                "detailed": "Professional designers and successful companies ALL test early prototypes! Building everything before testing is risky and wasteful. You might spend months building features users don't want or can't understand. Early testing means you discover problems when they're cheap to fix and validate ideas before investing heavily!",
                "socraticHint": "Do companies like Apple, Google, and Microsoft test prototypes or only test finished products? Why?"
              }
            }
          ],
          "correctAnswer": "A",
          "correctAnswerText": "It's easier and cheaper to fix problems early, before you've invested months building the wrong thing",
          "metadata": {
            "difficulty": "medium",
            "estimatedTime": 45,
            "bloomsTaxonomy": "evaluate",
            "tags": [
              "prototyping",
              "early-testing",
              "design-efficiency"
            ],
            "source": "exit-ticket",
            "version": "1.1",
            "createdDate": "2025-12-23",
            "lastModified": "2025-12-23"
          }
        }
      ]
    }
  ],
  "metadata": {
    "version": "1.1",
    "schemaDescription": "Enhanced feedback structure with short/detailed explanations and Socratic hints",
    "lastUpdated": "2025-12-24",
    "feedbackFormat": "structured",
    "features": [
      "misconceptionTargets",
      "structuredFeedback",
      "socraticHints"
    ]
  },
  "staticVersion": "1.0.0",
  "generatedAt": "2025-12-24T00:53:48.711Z"
}